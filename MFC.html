<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>MFC - &#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</title>

    
    <link rel="stylesheet" href="assets/css/expand-macro.css">

            <meta name="scroll-content-language-key" content="">
    
    <meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=2.0, user-scalable=yes">

<script type="text/javascript" src="assets/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/js/jquery.scrollTo.min.js"></script>


<script type="text/javascript" src="assets/js/translate.js"></script>


<script type="text/javascript" src="assets/js/scroll-tree.js"></script>

<script type="text/javascript" src="assets/js/theme.main.js"></script>

    <script type="text/javascript" src="assets/js/iframeResizer.min.js"></script>

<link rel="stylesheet" href="assets/css/content-style.css">
    <link rel="stylesheet" href="assets/css/search.css">

<link rel="stylesheet" href="assets/css/theme.main.css">
<link rel="stylesheet" href="assets/css/theme.colors.css">

            <!-- ES5 support for older browsers, needed by lunr -->
        <script src="js/augment.js"></script>
        <script id="worker" type="javascript/worker">

        startIndex = function() {
            idx = lunr.Index.load(lunrIndex);
            idx.pipeline.remove(lunr.stopWordFilter);
            postMessage({type: "setup-complete"});
        }

        onmessage = function (event) {
            var message = event.data;

            if ((message.type === 'setup') && message.baseUrl) {
                var url = message.baseUrl;
                importScripts(url + 'js/lunr.js');
                importScripts(url + 'js/lunr-extras.js');
                importScripts(url + 'js/lunr-index.js');
                importScripts(url + 'js/lunr-data.js');
                startIndex();
            }

            if (idx && (message.type === 'search-request') && message.query) {
                var searchWord = message.query;
                var results = idx.search(searchWord).map(function (result) {
                    return lunrData.filter(function (d) {
                        return d.id === parseInt(result.ref, 10)
                    })[0]
                });
                postMessage({type: 'search-results', results: results, query: searchWord, queryId: message.queryId});
            }
        }

    </script>
    </head>

<body pageid="8684305">

<div id="ht-loader">
    <noscript>
        <p style="width: 100%; text-align:center; position: absolute; margin-top: 200px;">This content cannot be displayed without JavaScript.<br>Please enable JavaScript and reload the page.</p>
    </noscript>
</div>

<div>
   	<header id="ht-headerbar">
    <div class="ht-headerbar-left">
        <a href="" id="ht-menu-toggle" class="sp-aui-icon-small sp-aui-iconfont-appswitcher"></a>
    </div>
    <div class="ht-headerbar-right">
            <div class="sp-aui-icon-small ht-search-index-loader ht-header-icon"></div>

        <div id="ht-search">
            <div class="ht-search-input" style="display: none;">
              	<a href="#" class="sp-aui-icon-small sp-aui-iconfont-remove ht-search-clear"></a>

                <form action="#" method="GET" id="search">
                    <input class="search-input" type="text" placeholder="Search" tabindex="-1" autocomplete="off" name="q" value="">
                    <input type="hidden" name="max" value="15" />
                    <input type="submit" style="display:none" tabindex="-4"/>
                </form>

                <a href="#" id="ht-search-button" class="ht-header-icon ht-header-icon-svg">
                                        <svg width="40px" height="40px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <g>
                            <path d="M29.572,28.802 L28.801,29.571 C28.515,29.857 28.187,30 27.816,30 C27.445,30 27.116,29.857 26.831,29.571 L21.392,24.134 C20.193,24.762 18.908,25.076 17.538,25.076 C15.396,25.076 13.605,24.348 12.163,22.892 C10.721,21.436 10,19.651 10,17.538 C10,15.397 10.721,13.605 12.163,12.163 C13.605,10.721 15.396,10 17.538,10 C19.651,10 21.434,10.721 22.89,12.163 C24.347,13.605 25.075,15.397 25.075,17.538 C25.075,18.937 24.761,20.222 24.132,21.393 L29.572,26.832 C29.857,27.118 30,27.446 30,27.817 C30,28.188 29.857,28.517 29.572,28.802 L29.572,28.802 Z M13.662,21.414 C14.732,22.485 16.024,23.02 17.538,23.02 C19.051,23.02 20.343,22.485 21.413,21.414 C22.484,20.344 23.019,19.052 23.019,17.538 C23.019,16.025 22.484,14.733 21.413,13.662 C20.343,12.592 19.051,12.056 17.538,12.056 C16.024,12.056 14.732,12.592 13.662,13.662 C12.591,14.733 12.056,16.025 12.056,17.538 C12.056,19.052 12.591,20.344 13.662,21.414 L13.662,21.414 Z"></path>
                        </g>
                    </svg>
              	</a>

                <div class="ht-search-dropdown ht-dropdown">
                    <ul></ul>
                </div>
            </div>
        </div>
    </div>
    </header>   	<aside id="ht-sidebar">
    <div class="ht-sidebar-content">
        <div class="ht-sidebar-content-scroll-container">
            <header class="ht-sidebar-header">
                <h1 class="ht-logo">
                    <span class="ht-logo-label">BinaryLearning</span>
                    <img class="space-logo" src="global.logo" />
                </h1>
                <a href="Binary-Learning.html" class="ht-space-link">
                    <h2>&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</h2>
                </a>
                <p><br>ᴀᴜᴛʜᴏʀ: ᴋᴇʏ<br><br>不积跬步，无以至千里；<br>不积小流，无以成江海。</p>
            </header>
                            <iframe id="ht-nav" src="toc.html?pageId=17301744"></iframe>
                <script>
                    $('iframe#ht-nav').iFrameResize(
                            { 'log': true, 'autoResize': true, 'heightCalculationMethod': 'lowestElement', 'checkOrigin': false });
                </script>
                    </div>
    </div>

</aside></div>

<div id="ht-wrap-container">

            
    <div id="ht-sidebar-dragbar">
    <div class="ht-sidebar-drag-handle">
        <span class="drag-handle-1"></span>
        <span class="drag-handle-2"></span>
        <span class="drag-handle-3"></span>
    </div>
</div>
    <article id="ht-content" class="ht-content">
        <header class="ht-content-header">
            <div id="ht-breadcrumb">
    <ul>
        <li><a href="Binary-Learning.html">&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</a></li>
                                                                                     <li><a href="%E5%88%9D%E7%BA%A7%E7%AF%87.html">&#21021;&#32423;&#31687;</a></li>
                                                            </ul>
</div>            <h1 id="src-17301744"> <span>MFC</span></h1>
        </header>

        <div id="main-content" class="wiki-content sp-grid-section" data-index-for-search="true">

    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-eahOacrOi0qA">
        <h1 class="heading "><span>MFC&#30340;&#26412;&#36136;</span></h1>
<p   
>MFC的本质就是对Win32的封装</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLU1GQ-S7i-e7jQ">
        <h2 class="heading "><span>MFC&#20171;&#32461;</span></h2>
<p   
>MFC（Microsoft Foundation Classes，微软基础类）是通过 WIN API 提供面向对象的精简包装，MFC6.0中大约封装了200个类，分别封装了WIN API和WIN SDK中的结构和过程；另外MFC还提供了一个应用程序框架，例如程序向导和类向导自动生成的代码，这样大大减少了程序语言的工作量，提高了开发效率。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLVZDNuWIm-W7uk1GQ-mhueebrg">
        <h2 class="heading "><span>VC6&#21019;&#24314;MFC&#39033;&#30446;</span></h2>
<p   
>新建项目，选择MFC AppWizard：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-9-18.png" alt="images/download/attachments/17301744/image2021-6-8_17-9-18.png" width="400"  />
    </p>
<p   
>点击OK选择Dialog Based：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-9-50.png" alt="images/download/attachments/17301744/image2021-6-8_17-9-50.png" width="400"  />
    </p>
<p   
>点击Finish然后点击OK：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-10-9.png" alt="images/download/attachments/17301744/image2021-6-8_17-10-9.png" width="400"  />
    </p>
<p   
>成功创建MFC项目（MFC画窗口是可视化拖动控件，直接点击右边的Controls然后在窗口中创建对应的控件即可）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-10-23.png" alt="images/download/attachments/17301744/image2021-6-8_17-10-23.png" width="600"  />
    </p>
<p   
>看似这是一个窗口实际上，在其背后已经替我们写了很多的代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-12-21.png" alt="images/download/attachments/17301744/image2021-6-8_17-12-21.png" width="600"  />
    </p>
<p   
>我们可以双击某个控件然后创建控件事件函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-13-39.png" alt="images/download/attachments/17301744/image2021-6-8_17-13-39.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-8_17-14-1.png" alt="images/download/attachments/17301744/image2021-6-8_17-14-1.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLU1GQ-S4jldJTjMy">
        <h2 class="heading "><span>MFC&#19982;WIN32</span></h2>
<p   
>MFC的本质就是Win32的封装，那么使用MFC实际上会更加方便、效率更高；</p>
<p   
><strong class=" ">其缺点</strong>就是根据<strong class=" ">项目引导生成的代码繁杂冗余</strong>，对初学者来说不利用学习和驾驭。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLeesrOS4gOS4qk1GQ-eoi-W6jw">
        <h1 class="heading "><span>&#31532;&#19968;&#20010;MFC&#31243;&#24207;</span></h1>
<p   
>由于根据<strong class=" ">项目引导生成的代码繁杂冗余</strong>，所以我们可以自己来手写MFC来创建Windows窗口程序，这样就可以避免一些不必要的代码。</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuQ">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点：</p>
<ul class=" "><li class=" "><p   
>CWinApp可以覆盖的虚函数 InitInstance</p>
</li><li class=" "><p   
>CWinApp成员变量m_pMainWnd</p>
</li><li class=" "><p   
>CFramWnd的成员函数create以及参数</p>
</li></ul><p   
>2、需要简单了解的内容：</p>
<ul class=" "><li class=" "><p   
>通过MSDN去看MFC的层次结构图</p>
</li><li class=" "><p   
>对CWinApp有个初步的认识</p>
</li><li class=" "><p   
>对CFramWnd有个初步的认识</p>
</li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLU1GQ-eahOWxguasoee7k-aehOWbvg">
        <h2 class="heading "><span>MFC&#30340;&#23618;&#27425;&#32467;&#26500;&#22270;</span></h2>
<p   
>在MSDN Library中搜索hierarchy chart即可获得MFC的层次结构图：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-15_17-35-28.png" alt="images/download/attachments/17301744/image2021-6-15_17-35-28.png" width="600"  />
    </p>
<p   
>本章我们只需要了解CWinApp、CFramWnd</p>
    </div>
    <div class="section section-2" id="src-17301744_MFC-CWinApp">
        <h2 class="heading "><span>CWinApp</span></h2>
<p   
>CWinApp类是Windows应用程序对象基类（父类）的派生类（子类），应用程序对象提供了用于初始化应用程序和运行应用程序的成员函数；使用MFC的每个应用程序<strong class=" ">只能（也必须）包含一个</strong><strong class=" ">CWinApp类的派生类（子类）</strong>的对象；当你从<strong class=" ">CWinApp</strong>派生应用程序类时，需要覆盖<strong class=" ">InitInstance</strong>成员函数以创建应用程序的主窗口对象；它还有一个成员变量<strong class=" ">m_pMainWnd</strong>用来记录创建的主窗口的对象。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-15_17-36-55.png" alt="images/download/attachments/17301744/image2021-6-15_17-36-55.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_MFC-CFrameWnd">
        <h2 class="heading "><span>CFrameWnd</span></h2>
<p   
>CFrameWnd类提供了Windows单文档界面（SDI）重叠或弹出框架窗口的功能，<strong class=" ">以及用于管理窗口的成员</strong>；要为应用程序创建有用的框架窗口，请从CFrameWnd派生类（子类）；向派生类（子类）添加成员变量以存储特定于您的应用程序的数据；在派生类（子类）中实现消息处理程序成员函数和消息映射，以指定在将消息定向到窗口时会发生什么。</p>
<p   
>有三种方法来构造框架窗口：</p>
<p   
>1.使用Create直接构造它 （本节需要掌握的内容）<br/>2.使用LoadFrame直接构造它（后续课程讲解）<br/>3.使用文档模板间接构建它 （后续课程讲解）</p>
<p   
>注：<strong class=" ">我们可以认为CFrameWnd类取代了窗口过程函数</strong>。</p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUNyZWF0ZeaIkOWRmOWHveaVsA">
        <h3 class="heading "><span>Create &#25104;&#21592;&#20989;&#25968;</span></h3>
<p   
>CFrameWnd :: Create 成员函数语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL Create(LPCTSTR lpszClassName, </code><code class="comments">// 如果类名为NULL，则以MFC内建的窗口类产生一个标准的外框窗口</code></div>
<div class="line"><code class="plain">           LPCTSTR lpszWindowName,</code></div>
<div class="line"><code class="plain">           DWORD dwStyle = WS_OVERLAPPEDWINDOW,</code></div>
<div class="line"><code class="plain">           </code><code class="keyword">const</code><code class="plain"> RECT&amp; rect = rectDefault,</code></div>
<div class="line"><code class="plain">           CWnd* pParentWnd = NULL,        </code><code class="comments">// != NULL for popups</code></div>
<div class="line"><code class="plain">           LPCTSTR lpszMenuName = NULL,</code></div>
<div class="line"><code class="plain">          DWORD dwExStyle = </code><code class="value">0</code><code class="plain">,</code></div>
<div class="line"><code class="plain">         CCreateContext* pContext = NULL);</code></div>
<div class="line"><code class="comments">// 返回值: 非零表示初始化成功，否则为0</code></div>
</div>
    </div>
<p   
>通过<strong class=" ">两个步骤构造一个CFrameWnd对象</strong>：</p>
<ol class=" "><li class=" "><p   
>首先调用构造函数，它构造<strong class=" ">CFrameWnd类的对象</strong>，然后调用<strong class=" ">Create成员方法</strong>，创建<strong class=" ">Windows框架窗口并将其附加到CFrameWnd类的对象</strong>；</p>
</li><li class=" "><p   
>创建初始化窗口的类名和窗口名称，并注册其样式，父级和关联菜单的默认值。</p>
</li></ol>    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeaJi-WKqOe8luWGmU1GQ-eoi-W6jw">
        <h2 class="heading "><span>&#25163;&#21160;&#32534;&#20889;MFC&#31243;&#24207;</span></h2>
<p   
>基于VC6手动编写MFC程序需要注意的事项：</p>
<ol class=" "><li class=" "><p   
>使用Win32 Application去创建项目</p>
</li><li class=" "><p   
>项目需要包含MFC运行库，VC6设置：Project &rarr; Setting &rarr; General &rarr; Use MFC In Static Library</p>
</li><li class=" "><p   
>使用头文件afxwin.h</p>
</li></ol><p   
>头文件：<strong class=" ">stdafx.h</strong></p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// stdafx.h : include file for standard system include files,</code></div>
<div class="line"><code class="comments">//  or project specific include files that are used frequently, but</code></div>
<div class="line"><code class="comments">//      are changed infrequently</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#</code><code class="keyword">if</code><code class="plain"> !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)</code></div>
<div class="line"><code class="plain">#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#</code><code class="keyword">if</code><code class="plain"> _MSC_VER &gt; </code><code class="value">1000</code></div>
<div class="line"><code class="plain">#pragma once</code></div>
<div class="line"><code class="plain">#endif </code><code class="comments">// _MSC_VER &gt; 1000</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define WIN32_LEAN_AND_MEAN        </code><code class="comments">// Exclude rarely-used stuff from Windows headers</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include &lt;afxwin.h&gt; </code><code class="comments">// 包含需要的头文件</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> CMyWinApp:</code><code class="keyword">public</code><code class="plain"> CWinApp { </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    virtual BOOL InitInstance();</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> CMainWindow:</code><code class="keyword">public</code><code class="plain"> CFrameWnd { </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    CMainWindow();</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// TODO: reference additional headers your program requires here</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">//{{AFX_INSERT_LOCATION}}</code></div>
<div class="line"><code class="comments">// Microsoft Visual C++ will insert additional declarations immediately before the previous line.</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#endif </code><code class="comments">// !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)</code></div>
</div>
    </div>
<p   
>源代码：HelloCode.cpp</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CMyWinApp theApp;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL CMyWinApp::InitInstance() {</code></div>
<div class="line"><code class="plain">    m_pMainWnd = </code><code class="keyword">new</code><code class="plain"> CMainWindow; </code><code class="comments">// 成员变量m_pMainWnd用来记录创建的主窗口的对象</code></div>
<div class="line"><code class="plain">    m_pMainWnd -&gt; ShowWindow(m_nCmdShow); </code><code class="comments">// 展示窗口，当调用ShowWindow时，你应该把m_nCmdShow作为一个参数传给它</code></div>
<div class="line"><code class="plain">    m_pMainWnd -&gt; UpdateWindow(); </code><code class="comments">// 更新窗口</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE; </code><code class="comments">// 返回值</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CMainWindow::CMainWindow() {</code></div>
<div class="line"><code class="plain">    Create(NULL, TEXT(</code><code class="string">"HELLO MFC"</code><code class="plain">)); </code><code class="comments">// Create成员函数创建一个框架窗口，需要注意的是这个函数前两个成员需要我们定义，但是后面的几个成员变量都有其默认参数，我们可以选择不写，第一个参数为NULL它会创建一个默认窗口类</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-21_15-15-26.png" alt="images/download/attachments/17301744/image2021-6-21_15-15-26.png" width="600"  />
    </p>
<p   
><strong class=" ">为什么代码里没有WinMain？MFC没有WinMain函数吗？</strong>其实MFC是在内部接管了WinMain，我们可以认为CWinApp就是WinMain，只不过我们没法很直观的看见WinMain函数。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeaAu-e7kw">
        <h2 class="heading "><span>&#24635;&#32467;</span></h2>
<ol class=" "><li class=" "><p   
>基于MFC的窗口程序必须也只能有一个由从CWinApp派生的对象；</p>
</li><li class=" "><p   
>我们必须覆盖CWinApp的虚函数InitInstance在里面创建窗口，并把窗口对象保存在它的成员变量m_pMainWnd；</p>
</li><li class=" "><p   
>通过CFrameWnd类的派生类（子类）的对象，在它的构造函数里面调用成员函数Create来创建窗口。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeivvuWQjuS9nOS4mg">
        <h2 class="heading "><span>&#35838;&#21518;&#20316;&#19994;</span></h2>
<p   
>创建一个带滚动条的，300x300的窗口：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CMainWindow::CMainWindow() {</code></div>
<div class="line"><code class="plain">    RECT rect = {</code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">300</code><code class="plain">, </code><code class="value">300</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    Create(NULL, TEXT(</code><code class="string">"HELLO MFC"</code><code class="plain">), WS_VSCROLL, rect); </code><code class="comments">// Create成员函数创建一个框架窗口</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-eahOWIneWni-WMlui_h-eoi--8iOS4gO-8iQ">
        <h1 class="heading "><span>MFC&#30340;&#21021;&#22987;&#21270;&#36807;&#31243;&#65288;&#19968;&#65289;</span></h1>
<p   
>本章通过代码来模拟MFC的初始化过程</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4x">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>为什么要声明全局的应用程序对象(CWinApp)</p>
</li><li class=" "><p   
>学会使用类视图快速添加类</p>
</li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>CWinApp的层次结构</p>
</li><li class=" "><p   
>CFramWnd的层次结构</p>
</li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS7o-eggeaooeaLnw">
        <h2 class="heading "><span>&#20195;&#30721;&#27169;&#25311;</span></h2>
<p   
>用代码模拟MFC的初始化过程，我们基于上一章中手动编写的MFC代码来模拟。</p>
<p   
>我们继承两个类CWinApp、CFrameWnd，这两个类的层次结构如下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-26-50.png" alt="images/download/attachments/17301744/image2021-6-22_19-26-50.png" width="400"  />
    </p>
<p   
>所以在这里我们需要重写<strong class=" ">CObject、CCmdTarget、CWinThread、CWnd、CWinApp、CFrameWnd</strong>这几个类...</p>
<p   
>仅仅是模拟代码，不用写实际功能，写上构造、析构函数即可，这里使用VC6的类视图来创建，教程如下所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-30-12.png" alt="images/download/attachments/17301744/image2021-6-22_19-30-12.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-31-41.png" alt="images/download/attachments/17301744/image2021-6-22_19-31-41.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-32-53.png" alt="images/download/attachments/17301744/image2021-6-22_19-32-53.png" width="600"  />
    </p>
<p   
>按照这样的层级结构我们创建了这些类，并使用上一章的代码去继承模拟实现一个MFC程序：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-58-55.png" alt="images/download/attachments/17301744/image2021-6-22_19-58-55.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-59-21.png" alt="images/download/attachments/17301744/image2021-6-22_19-59-21.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_19-59-42.png" alt="images/download/attachments/17301744/image2021-6-22_19-59-42.png" width="600"  />
    </p>
<p   
>最后执行，我们就可以很清晰的看见执行流程了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_20-0-53.png" alt="images/download/attachments/17301744/image2021-6-22_20-0-53.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeaAu-e7ky4x">
        <h2 class="heading "><span>&#24635;&#32467;</span></h2>
<p   
>全局对象的建构会比程序入口点更早，所以CWinApp类的对象构造函数将早于WinMain函数，而<strong class=" ">WinMain函数又广泛使用了应用程序对象</strong>，这就是为什么应该程序对象<strong class=" ">必须做全局声明</strong>的原因。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-eahOWIneWni-WMlui_h-eoi--8iOS6jO-8iQ">
        <h1 class="heading "><span>MFC&#30340;&#21021;&#22987;&#21270;&#36807;&#31243;&#65288;&#20108;&#65289;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4y">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>MFC是如何使用应用程序对象</p>
</li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>CWinApp类的二个可以覆盖的虚函数</p>
<ul class=" "><li class=" "><p   
>virtual BOOL InitInstance();</p>
</li><li class=" "><p   
>virtual int Run();</p>
</li></ul></li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS7o-eggeaooeaLny4x">
        <h2 class="heading "><span>&#20195;&#30721;&#27169;&#25311;</span></h2>
<p   
>在上一章节中我们是将<strong class=" ">InitInstance这个虚函数删除的</strong>，在本章中我们可以基于上一章节的代码重新定义一下该虚函数，在原MFC中（这里我们是模拟）这个虚函数在三个类中都存在：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_10-9-24.png" alt="images/download/attachments/17301744/image2021-6-24_10-9-24.png" width="400"  />
    </p>
<p   
>我们已经了解层次结构所以直接在最高一层去定义，也就是<strong class=" ">CWinThread这个类</strong>中去定义即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_21-40-46.png" alt="images/download/attachments/17301744/image2021-6-22_21-40-46.png" width="600"  />
    </p>
<p   
>在这我们在当前类中不想具体实现，所以使用纯虚函数去表示，而后在CMyWinApp类中去实现：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_21-42-48.png" alt="images/download/attachments/17301744/image2021-6-22_21-42-48.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_21-44-18.png" alt="images/download/attachments/17301744/image2021-6-22_21-44-18.png" width="600"  />
    </p>
<p   
>除此之外我们还有一个<strong class=" ">成员变量m_pMainWnd</strong>，这个也是在CWinThread类中定义：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_21-46-7.png" alt="images/download/attachments/17301744/image2021-6-22_21-46-7.png" width="600"  />
    </p>
<p   
>同样我们需要在<strong class=" ">CMainWindow类中定义Create函数</strong>，然后做一个简单的输出即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_21-51-26.png" alt="images/download/attachments/17301744/image2021-6-22_21-51-26.png" width="600"  />
    </p>
<p   
>因为需要完美的模拟，<strong class=" ">所以Create函数需要在构造函数中调用，InitInstance函数需要在main函数中调用</strong>（实际上是通过指针去调用的）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_22-0-27.png" alt="images/download/attachments/17301744/image2021-6-22_22-0-27.png" width="600"  />
    </p>
<p   
>在这里我们一个简化的模拟代码就完成了，执行顺序如下图：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-22_22-3-32.png" alt="images/download/attachments/17301744/image2021-6-22_22-3-32.png" width="600"  />
    </p>
<p   
>简单理解：CWinApp的Run函数就是用于消息循环的。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-i_kOihjOaXtuexu-Wei-ivhuWIq--8iFJUVEnvvIk">
        <h1 class="heading "><span>MFC&#36816;&#34892;&#26102;&#31867;&#22411;&#35782;&#21035;&#65288;RTTI&#65289;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS7gOS5iOaYr1JUVEk">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;RTTI</span></h2>
<p   
>MFC运行时类型识别（英文：Runtime Type Information，缩写：RTTI），能够使用基类（父类）的指针或引用来检查这些指针或引用所指的对象的实际派生类（子类），简单的意思就是<strong class=" ">它可以帮助我们在程序运行的过程中了解到某个对象所属类</strong>。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4z">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>MFC为什么要自己去构建RTTI</p>
</li><li class=" "><p   
>关键的宏</p>
<ul class=" "><li class=" "><p   
>DECLARE_DYNAMIC</p>
</li><li class=" "><p   
>IMPLEMENT_DYNAMIC</p>
</li><li class=" "><p   
>RUNTIME_CLASS</p>
</li></ul></li><li class=" "><p   
>关键的结构体 CRuntimeClass</p>
</li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>static关键字的作用</p>
</li><li class=" "><p   
>const关键字的作用</p>
</li><li class=" "><p   
>C++ RTTI typeid操作符</p>
</li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqFZDNuS4reiHquW4pueahFJUVEk">
        <h2 class="heading "><span>&#20351;&#29992;VC6&#20013;&#33258;&#24102;&#30340;RTTI</span></h2>
<p   
>在编译器（VC6）中有自带的RTTI，我们可以在Project-Setting中选择C/C++标签按如下图选择即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-2-44.png" alt="images/download/attachments/17301744/image2021-6-23_15-2-44.png" width="400"  />
    </p>
<p   
>在源代码中我们还需要引入一个头文件typeinfo.h，而后就可以使用typeid这个函数来进行动态识别，该函数只有一个传参，改参数可以为类名或已经创建的对象名。</p>
<p   
>如下图所示简单用一下typeid，我们定一个了一个类CAnimal并创建了一个对象pAnimal，使用typeid进行比较发现两者都属于同一个类：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-11-28.png" alt="images/download/attachments/17301744/image2021-6-23_15-11-28.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLXN0YXRpY-WFs-mUruivjeeahOS9nOeUqA">
        <h2 class="heading "><span>static&#20851;&#38190;&#35789;&#30340;&#20316;&#29992;</span></h2>
<p   
>static关键词之前课程中也有了解到，这里我们重新温故一下，当用这个关键词定义一个变量，该变量则存储在全局数据区而不是局部的，如果static关键词的变量为某类的成员，则该成员与类进行关联，但并不会与类创建的对象进行关联，也就表示我们不需要创建对象就可以使用这个成员，所以我们想要使用的话就要通过<strong class=" ">类名::成员名</strong>的方式去使用，并且我们不可以在类的内部去赋值初始化，只可以在外部。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-19-46.png" alt="images/download/attachments/17301744/image2021-6-23_15-19-46.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLWNvbnN05YWz6ZSu6K-N55qE5L2c55So">
        <h2 class="heading "><span>const&#20851;&#38190;&#35789;&#30340;&#20316;&#29992;</span></h2>
<p   
>使用const关键词定义的成员，同样没办法直接初始化，需要在初始化列表中进行初始化：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-38-48.png" alt="images/download/attachments/17301744/image2021-6-23_15-38-48.png" width="600"  />
    </p>
<p   
>跟static不同的是，我们想要使用const关键词的成员时应创建对象后<strong class=" ">根据对象名来使用</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-40-29.png" alt="images/download/attachments/17301744/image2021-6-23_15-40-29.png" width="600"  />
    </p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLXN0YXRpY-OAgWNvbnN05Y-M5YWz6ZSu6K-N">
        <h3 class="heading "><span>static&#12289;const&#21452;&#20851;&#38190;&#35789;</span></h3>
<p   
>如果一个成员使用了static const双关键词，我们还是按照static关键词的方法去使用，但是在初始化的时候需要加上const关键词：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_15-44-16.png" alt="images/download/attachments/17301744/image2021-6-23_15-44-16.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLU1GQ-S4uuS7gOS5iOimgeiHquW3seWOu-aehOW7ulJUVEk">
        <h2 class="heading "><span>MFC&#20026;&#20160;&#20040;&#35201;&#33258;&#24049;&#21435;&#26500;&#24314;RTTI</span></h2>
<p   
>在MFC出来的时候C++并没有RTTI这个概念，所以MFC自己设计了这样一套东西，其依靠的就是两个宏：DECLARE_DYNAMIC、IMPLEMENT_DYNAMIC，其中IMPLEMENT_DYNAMIC宏也包含了一个关键的宏RUNTIME_CLASS以及关键结构体CRuntime Class。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqOWuj-WcqOiHquW3seeahOexu-S4reaehOW7ug">
        <h2 class="heading "><span>&#20351;&#29992;&#23439;&#22312;&#33258;&#24049;&#30340;&#31867;&#20013;&#26500;&#24314;</span></h2>
<p   
>我们要在自己的类中构建RTTI就需要使用这两个宏（<strong class=" ">注意：宏单独使用的时候，结尾不加分号</strong>）：DECLARE_DYNAMIC、IMPLEMENT_DYNAMIC</p>
<p   
>首先在CWinApp类派生的CMyWinApp类中使用DECLARE_DYNAMIC这个宏（<strong class=" ">个人理解</strong>：声明这个类可以使用RTTI），其用法跟函数是一样的，传参为当前类名：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_22-58-35.png" alt="images/download/attachments/17301744/image2021-6-23_22-58-35.png" width="600"  />
    </p>
<p   
>其次在WinMain函数之前使用IMPLEMENT_DYNAMIC宏（<strong class=" ">个人理解</strong>：要在当前使用RTTI，又像建立一个父类和子类的关联），其用法跟函数是一样的，传参为类名、父类名：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_22-59-38.png" alt="images/download/attachments/17301744/image2021-6-23_22-59-38.png" width="600"  />
    </p>
<p   
>最后使用IsKindOf函数去判断当前是否继承某个类，其语法格式如下所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-2-56.png" alt="images/download/attachments/17301744/image2021-6-23_23-2-56.png" width="400"  />
    </p>
<p   
>传递的参数使用结构体指针，我们可以通过RUNTIME_CLASS这个宏来返回该格式：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-6-20.png" alt="images/download/attachments/17301744/image2021-6-23_23-6-20.png" width="600"  />
    </p>
<p   
>如上图所示我们通过判断当前类是否是基于CWinApp类派生的，不是则返回FALSE。</p>
    <div class="section section-3" id="src-17301744_MFC-RUNTIME_CLASS">
        <h3 class="heading "><span>RUNTIME_CLASS</span></h3>
<p   
>RUNTIME_CLASS这个宏就是返回处理传入的类名，返回一个CRuntimeClass的指针，其本质我们在VC6中鼠标点击按F12即可看见：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-13-32.png" alt="images/download/attachments/17301744/image2021-6-23_23-13-32.png" width="600"  />
    </p>
<p   
>就是 &rarr; <strong class=" ">((CRuntimeClass*)(&amp;class_name::class##class_name))</strong>，其中两个#号则代表拼接符（一个#号则表示转为字符串），也就是说这一段代码可以转换为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">((CRuntimeClass*)(&amp;CWinApp::classCWinApp))</code></div>
</div>
    </div>
<p   
>所以我们可以在判断中去替换一下使用：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-17-2.png" alt="images/download/attachments/17301744/image2021-6-23_23-17-2.png" width="600"  />
    </p>
<p   
>那这个也就很好理解了：这一段就表示返回的是<strong class=" ">CWinApp类中的classCWinApp的地址然后强转为了CRuntimeClass指针</strong>。</p>
<p   
>因此我们需要来看一下CRuntimeClass这个结构体。</p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNSdW50aW1lQ2xhc3Pnu5PmnoTkvZM">
        <h2 class="heading "><span>CRuntimeClass&#32467;&#26500;&#20307;</span></h2>
<p   
>CRuntimeClass结构体，中文名称叫类型记录链表结构，我们可以使用F12跟进看一下定义：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-20-16.png" alt="images/download/attachments/17301744/image2021-6-23_23-20-16.png" width="600"  />
    </p>
<p   
>由于这里结构体的内容比较多，我们可以简化一下，整理出本章需要学到的东西：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct CRuntimeClass</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">LPCSTR m_lpszClassName;  </code><code class="comments">// 类名称</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> m_nObjectSize;  </code><code class="comments">// 类的大小</code></div>
<div class="line"><code class="plain">UINT m_wSchema; </code><code class="comments">// 加载类的模式编号</code></div>
<div class="line"><code class="plain">...</code></div>
<div class="line"><code class="plain">CRuntimeClass* m_pBaseClass;   </code><code class="comments">// 父类指针</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 判断函数，判断是否父类</code></div>
<div class="line"><code class="plain">BOOL IsDerivedFrom(</code><code class="keyword">const</code><code class="plain"> CRuntimeClass* pBaseClass) </code><code class="keyword">const</code><code class="plain">;</code></div>
<div class="line"><code class="plain">...</code></div>
<div class="line"><code class="plain">CRuntimeClass* m_pNextClass;    </code><code class="comments">// 指向下一个CRuntimeClass结构体指针</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>这个是一个链表结构体，是用于记录类的结构，其中包含了很多类的信息。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLei9rOaNouWuj-S6huino-acrOi0qA">
        <h2 class="heading "><span>&#36716;&#25442;&#23439;&#20102;&#35299;&#26412;&#36136;</span></h2>
<p   
>我们可以将使用到的几个宏转换为原来的代码然后看一下本质，首先是DECLARE_DYNAMIC：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define DECLARE_DYNAMIC(class_name) \</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">: \</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> AFX_DATA CRuntimeClass </code><code class="keyword">class</code><code class="plain">##class_name; \</code></div>
<div class="line"><code class="plain">    virtual CRuntimeClass* GetRuntimeClass() </code><code class="keyword">const</code><code class="plain">; \</code></div>
</div>
    </div>
<p   
>在代码中改写为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> CRuntimeClass classCMyWinApp; </code><code class="comments">// 全局可读的变量，类型记录信息结构体CRuntimeClass</code></div>
<div class="line"><code class="plain">virtual CRuntimeClass* GetRuntimeClass() </code><code class="keyword">const</code><code class="plain">; </code><code class="comments">// 最后的const表示对该成员无法更改</code></div>
</div>
    </div>
<p   
>这里既然定义了一个成员为全局可读的变量，<strong class=" ">那么就会需要在一个地方进行初始化</strong>，而初始化的地方就在IMPLEMENT_DYNAMIC宏中，我们来看下IMPLEMENT_DYNAMIC的背后是什么：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \</code></div>
<div class="line"><code class="plain">    IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, </code><code class="value">0xFFFF</code><code class="plain">, NULL) </code><code class="comments">// 其背后又是一个宏，继续跟进</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \</code></div>
<div class="line"><code class="plain">    AFX_COMDAT </code><code class="keyword">const</code><code class="plain"> AFX_DATADEF CRuntimeClass class_name::</code><code class="keyword">class</code><code class="plain">##class_name = { \</code></div>
<div class="line"><code class="plain">        #class_name, sizeof(</code><code class="keyword">class</code><code class="plain"> class_name), wSchema, pfnNew, \</code></div>
<div class="line"><code class="plain">            RUNTIME_CLASS(base_class_name), NULL }; \</code></div>
<div class="line"><code class="plain">    CRuntimeClass* class_name::GetRuntimeClass() </code><code class="keyword">const</code><code class="plain"> \</code></div>
<div class="line"><code class="plain">        { </code><code class="keyword">return</code><code class="plain"> RUNTIME_CLASS(class_name); } \</code></div>
</div>
    </div>
<p   
>在代码中改写为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">const</code><code class="plain"> CRuntimeClass CMyWinApp::classCMyWinApp = {</code></div>
<div class="line"><code class="plain">    </code><code class="string">"CMyWinApp"</code><code class="plain">, sizeof(</code><code class="keyword">class</code><code class="plain"> CMyWinApp), </code><code class="value">0xFFFF</code><code class="plain">, NULL, </code><code class="comments">// CRuntimeClass结构体，初始化类信息</code></div>
<div class="line"><code class="plain">    ((CRuntimeClass*)(&amp;CWinApp::classCWinApp)), NULL</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CRuntimeClass* CMyWinApp::GetRuntimeClass() </code><code class="keyword">const</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> ((CRuntimeClass*)(&amp;CMyWinApp::classCMyWinApp)); </code><code class="comments">// 返回</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>整个代码转换下来，流程也清楚了，最后就是IsKindOf函数的原理了，我们可以下断点跟进：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-55-51.png" alt="images/download/attachments/17301744/image2021-6-23_23-55-51.png" width="600"  />
    </p>
<p   
>首先是获取类的<strong class=" ">CRuntimeClass结构体指针</strong>，然后根据这个指针调用<strong class=" ">IsDerivedFrom方法</strong>，传递的参数也是一个结构体指针，继续跟进该函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-23_23-57-14.png" alt="images/download/attachments/17301744/image2021-6-23_23-57-14.png" width="600"  />
    </p>
<p   
>前面的可以不用管，都是一些容错代码，进到这个while循环，我们可以很清晰的看见其会判断当前类和传递进来的类是否一样，如果一样则返回TRUE。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeivvuWQjuS9nOS4mi4x">
        <h2 class="heading "><span>&#35838;&#21518;&#20316;&#19994;</span></h2>
<p   
>通过拆分宏，让CMainWindow类也支持RTTI：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_0-11-11.png" alt="images/download/attachments/17301744/image2021-6-24_0-11-11.png" width="600"  />
    </p>
<p   
>分别自写函数打印出它父类的CRuntimeClass结构体信息：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> CMyWinApp : </code><code class="keyword">public</code><code class="plain"> CWinApp {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> PrintCRuntimeClass (CRuntimeClass* className) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">        sprintf(szOutBuff, </code><code class="string">"%s \n"</code><code class="plain">, className-&gt;m_lpszClassName);</code></div>
<div class="line"><code class="plain">        OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">        CRuntimeClass* baseRuntimeClass = className-&gt;m_pBaseClass;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (baseRuntimeClass != NULL) {</code></div>
<div class="line"><code class="plain">            PrintCRuntimeClass(baseRuntimeClass);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    virtual BOOL InitInstance();</code></div>
<div class="line"><code class="plain">    CMyWinApp();</code></div>
<div class="line"><code class="plain">    ~CMyWinApp();</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> CRuntimeClass classCMyWinApp; </code><code class="comments">// 全局可读的变量，类型记录信息结构体CRuntimeClass</code></div>
<div class="line"><code class="plain">    virtual CRuntimeClass* GetRuntimeClass() </code><code class="keyword">const</code><code class="plain">; </code><code class="comments">// 最后的const表示对该成员无法更改</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> RunIt () {</code></div>
<div class="line"><code class="plain">        CRuntimeClass* thisRuntimeClass = </code><code class="keyword">this</code><code class="plain">-&gt;GetRuntimeClass();</code></div>
<div class="line"><code class="plain">        PrintCRuntimeClass(thisRuntimeClass);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_0-28-45.png" alt="images/download/attachments/17301744/image2021-6-24_0-28-45.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLeWKqOaAgeWIm-W7ug">
        <h1 class="heading "><span>&#21160;&#24577;&#21019;&#24314;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWFs-S6jk1GQ-eahOWKqOaAgeWIm-W7ug">
        <h2 class="heading "><span>&#20851;&#20110;MFC&#30340;&#21160;&#24577;&#21019;&#24314;</span></h2>
<p   
>MFC的动态创建基本和C++的new运算符创建没有区别，但是他弥补了C++语言中不让如下语句执行的缺点：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">char</code><code class="plain">* className = </code><code class="string">"MyClass"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">CObject* obj = </code><code class="keyword">new</code><code class="plain"> className;</code></div>
</div>
    </div>
<p   
>如上代码我们的本意就是创建一个MyClass类的对象，但是C++是无法创建的。</p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeS7gOS5iOaXtuWAmemcgOimgeWKqOaAgeWIm-W7ug">
        <h3 class="heading "><span>&#20160;&#20040;&#26102;&#20505;&#38656;&#35201;&#21160;&#24577;&#21019;&#24314;</span></h3>
<p   
>MFC有一个永久保存机制，就是将内存中的东西写入到文件中，写入的数据可能是对象中的成员，所以我们需要根据文件中记载的信息去创建对象，才能将写入的数据读取保存。</p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS40">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>动态创建的作用</p>
</li><li class=" "><p   
>二个关键的宏:</p>
<ul class=" "><li class=" "><p   
>DECLARE_DYNCREATE</p>
</li><li class=" "><p   
>IMPLEMENT_DYNCREATE</p>
</li></ul></li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>CRuntimeClass::CreateObject（<strong class=" ">动态创建函数</strong>）</p>
</li></ul>    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">//类型记录链表结构</code></div>
<div class="line"><code class="plain">struct CRuntimeClass</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">LPCSTR m_lpszClassName;   </code><code class="comments">// 类名称</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> m_nObjectSize;    </code><code class="comments">// 类的大小</code></div>
<div class="line"><code class="plain">UINT m_wSchema; </code><code class="comments">// 加载类的模式编号</code></div>
<div class="line"><code class="plain">CObject* (PASCAL* m_pfnCreateObject)(); </code><code class="comments">// 函数指针，定义了一个函数指针m_pfnCreateObject用来存放需要支持动态创建类的CreateObject函数</code></div>
<div class="line"><code class="plain">m_pBaseClass;   </code><code class="comments">// 父类指针</code></div>
<div class="line"><code class="plain">CObject* CreateObject();   </code><code class="comments">// 动态创建函数</code></div>
<div class="line"><code class="comments">// 判断函数</code></div>
<div class="line"><code class="plain">BOOL IsDerivedFrom(</code><code class="keyword">const</code><code class="plain"> CRuntimeClass* pBaseClass) </code><code class="keyword">const</code><code class="plain">; …</code></div>
<div class="line"><code class="plain">CRuntimeClass* m_pNextClass;       </code><code class="comments">// 指向下一个CRuntimeClass </code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqOWKqOaAgeWIm-W7ug">
        <h2 class="heading "><span>&#20351;&#29992;&#21160;&#24577;&#21019;&#24314;</span></h2>
<p   
>我们可以跟进CFramWnd类、CWinApp类来看一下谁支持动态创建，也就是<strong class=" ">谁使用了相关的宏</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_10-32-2.png" alt="images/download/attachments/17301744/image2021-6-24_10-32-2.png" width="600"  />
    </p>
<p   
>如上图所示我们可以很清晰的看见<strong class=" ">CFrameWnd类使用了DECLARE_DYNCREATE宏</strong>，也就表示其支持动态创建。</p>
<p   
>所以我们可以在其派生的CMainWindow类也使用动态创建，这里宏的使用和RTTI宏的使用是一样的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_10-57-1.png" alt="images/download/attachments/17301744/image2021-6-24_10-57-1.png" width="600"  />
    </p>
<p   
>在InitInstance函数中<strong class=" ">将new运算符替代为动态创建函数CreateObject</strong>即可。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLei9rOaNouWuj-S6huino-acrOi0qC4x">
        <h2 class="heading "><span>&#36716;&#25442;&#23439;&#20102;&#35299;&#26412;&#36136;</span></h2>
<p   
>与上一章一样，我们将宏转换为其背后的代码来了解其本质。</p>
<p   
>首先是DECLARE_DYNCREATE宏，其代码为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define DECLARE_DYNCREATE(class_name) \</code></div>
<div class="line"><code class="plain">    DECLARE_DYNAMIC(class_name) \ </code><code class="comments">// RTTI宏</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> CObject* PASCAL CreateObject();</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define DECLARE_DYNAMIC(class_name) \</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">: \</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> AFX_DATA CRuntimeClass </code><code class="keyword">class</code><code class="plain">##class_name; \</code></div>
<div class="line"><code class="plain">    virtual CRuntimeClass* GetRuntimeClass() </code><code class="keyword">const</code><code class="plain">; \</code></div>
</div>
    </div>
<p   
>如上代码中文名可以看见在该宏中包含了DECLARE_DYNAMIC宏，也就是说动态创建是支持RTTI的，代码中改写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> CRuntimeClass classCMainWindow;</code></div>
<div class="line"><code class="plain">virtual CRuntimeClass* GetRuntimeClass() </code><code class="keyword">const</code><code class="plain">;</code></div>
<div class="line"><code class="keyword">static</code><code class="plain"> CObject* __stdcall CreateObject(); </code><code class="comments">// #define PASCAL      __stdcall</code></div>
</div>
    </div>
<p   
>其实通过这段代码我们就可以知道IMPLEMENT_DYNCREATE宏的作用就是声明classCMainWindow成员变量、GetRuntimeClass成员方法、CreateObject成员方法：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \</code></div>
<div class="line"><code class="plain">    CObject* PASCAL class_name::CreateObject() \</code></div>
<div class="line"><code class="plain">        { </code><code class="keyword">return</code><code class="plain"> </code><code class="keyword">new</code><code class="plain"> class_name; } \</code></div>
<div class="line"><code class="plain">    IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, </code><code class="value">0xFFFF</code><code class="plain">, \</code></div>
<div class="line"><code class="plain">        class_name::CreateObject) </code><code class="comments">// 其背后又是一个宏，继续跟进</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \</code></div>
<div class="line"><code class="plain">    AFX_COMDAT </code><code class="keyword">const</code><code class="plain"> AFX_DATADEF CRuntimeClass class_name::</code><code class="keyword">class</code><code class="plain">##class_name = { \</code></div>
<div class="line"><code class="plain">        #class_name, sizeof(</code><code class="keyword">class</code><code class="plain"> class_name), wSchema, pfnNew, \</code></div>
<div class="line"><code class="plain">            RUNTIME_CLASS(base_class_name), NULL }; \</code></div>
<div class="line"><code class="plain">    CRuntimeClass* class_name::GetRuntimeClass() </code><code class="keyword">const</code><code class="plain"> \</code></div>
<div class="line"><code class="plain">        { </code><code class="keyword">return</code><code class="plain"> RUNTIME_CLASS(class_name); } \</code></div>
</div>
    </div>
<p   
>在代码中改写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CObject* PASCAL CMainWindow::CreateObject() {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="keyword">new</code><code class="plain"> CMainWindow;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">const</code><code class="plain"> CRuntimeClass CMainWindow::classCMainWindow = {</code></div>
<div class="line"><code class="plain">    </code><code class="string">"CMainWindow"</code><code class="plain">, sizeof(</code><code class="keyword">class</code><code class="plain"> CMainWindow), </code><code class="value">0xFFFF</code><code class="plain">, CMainWindow::CreateObject,</code></div>
<div class="line"><code class="plain">    ((CRuntimeClass*)(&amp;CFrameWnd::classCFrameWnd)), NULL</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CRuntimeClass* CMainWindow::GetRuntimeClass() </code><code class="keyword">const</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> ((CRuntimeClass*)(&amp;CMainWindow::classCMainWindow));</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_11-18-21.png" alt="images/download/attachments/17301744/image2021-6-24_11-18-21.png" width="600"  />
    </p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLea1geeoi-i3n-i_mw">
        <h3 class="heading "><span>&#27969;&#31243;&#36319;&#36827;</span></h3>
<p   
>转换完宏之后在调用CreateObject函数时下断点跟进：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_11-23-38.png" alt="images/download/attachments/17301744/image2021-6-24_11-23-38.png" width="800"  />
    </p>
<p   
>这个就很好理解了就是调用CreateObject函数会判断<strong class=" ">m_pfnCreateObject</strong>（这是一个函数指针存放当前的CreateObject函数的地址），如果不为空则调用这个函数将其返回值给到pObject，最后再返回pObject也就是new CMainWindow。</p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeivvuWQjuS9nOS4mi4y">
        <h2 class="heading "><span>&#35838;&#21518;&#20316;&#19994;</span></h2>
<p   
>在CMainWindow类里面定义一个函数：<strong class=" ">CreateObjectByName(char* className);</strong>，这个函数就表示通过参数去动态创建对象。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_12-34-23.png" alt="images/download/attachments/17301744/image2021-6-24_12-34-23.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLea2iOaBr-aYoOWwhA">
        <h1 class="heading "><span>&#28040;&#24687;&#26144;&#23556;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS7gOS5iOaYr-a2iOaBr-aYoOWwhA">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#28040;&#24687;&#26144;&#23556;</span></h2>
<p   
>消息映射是MFC内建的一个消息分派机制，只要利用<strong class=" ">数个宏以及固定形式的写法</strong>（类似于填表格）就可以让我们的框架知道一旦消息发生，该往哪一个类去传递，每一个类只能拥有一个<strong class=" ">消息映射表格</strong>，也可以没有。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKguivvumcgOimgeaOjOaPoeeahOefpeivhueCuQ">
        <h2 class="heading "><span>&#26412;&#33410;&#35838;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>三个关键的宏</p>
<ul class=" "><li class=" "><p   
>DECLARE_MESSAGE_MAP</p>
</li><li class=" "><p   
>BEGIN_MESSAGE_MAP</p>
</li><li class=" "><p   
>END_MESSAGE_MAP</p>
</li></ul></li><li class=" "><p   
>如何添加一个消息</p>
</li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>AFX_MSGMAP_ENTRY结构和AFX_MSGMAP</p>
</li><li class=" "><p   
>MessageMapFunctions</p>
</li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqOS4ieS4quWFs-mUrueahOWujw">
        <h2 class="heading "><span>&#20351;&#29992;&#19977;&#20010;&#20851;&#38190;&#30340;&#23439;</span></h2>
<p   
>之前的学习中我们学了几个<strong class=" ">带有DECLARE_前缀的宏</strong>，就是声明的意思，将它放在类内部即可，所以宏<strong class=" ">DECLARE_MESSAGE_MAP</strong>直接写在类里头（声明里）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-12-56.png" alt="images/download/attachments/17301744/image2021-6-24_14-12-56.png" width="600"  />
    </p>
<p   
>另外两个宏就是实现，<strong class=" ">BEGIN_MESSAGE_MAP有两个参数分别是当前类、当前类的基类（父类</strong>），应该<strong class=" ">成对出现在类实现外</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-14-4.png" alt="images/download/attachments/17301744/image2021-6-24_14-14-4.png" width="600"  />
    </p>
<p   
>假设我们要添加一个鼠标左键按下的消息就需要在这里面去填写：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-16-19.png" alt="images/download/attachments/17301744/image2021-6-24_14-16-19.png" width="600"  />
    </p>
<p   
>但是这样我们还需要一个消息处理的函数，这个函数要写在<strong class=" ">CMainWindow</strong>类声明中：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-24-19.png" alt="images/download/attachments/17301744/image2021-6-24_14-24-19.png" width="600"  />
    </p>
<p   
><strong class=" ">AfxMessageBox函数就是一个弹框，弹框内容为Test</strong>，在这里我们允许程序左键按下就会出现弹框：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-25-8.png" alt="images/download/attachments/17301744/image2021-6-24_14-25-8.png" width="400"  />
    </p>
<p   
>按照这样的格式我们想添加什么消息处理都可以，但是因为是宏，使用简单，但不利于我们去了解基本原理，<strong class=" ">例如这个左键按下的消息处理函数OnLButtonDown，这个函数名为什么要这样写？不这么写可不可以？</strong>所以我们还需要通过转换宏去了解本质。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLei9rOaNouWuj-S6huino-acrOi0qC4y">
        <h2 class="heading "><span>&#36716;&#25442;&#23439;&#20102;&#35299;&#26412;&#36136;</span></h2>
<p   
>首先是<strong class=" ">DECLARE_MESSAGE_MAP宏</strong>：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define DECLARE_MESSAGE_MAP() \</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">: \</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP_ENTRY _messageEntries[]; \</code></div>
<div class="line"><code class="keyword">protected</code><code class="plain">: \</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> AFX_DATA </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP messageMap; \</code></div>
<div class="line"><code class="plain">    virtual </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP* GetMessageMap() </code><code class="keyword">const</code><code class="plain">; \</code></div>
</div>
    </div>
<p   
>在代码中改写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP_ENTRY _messageEntries[];</code></div>
<div class="line"><code class="keyword">protected</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP messageMap;</code></div>
<div class="line"><code class="plain">    virtual </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP* GetMessageMap() </code><code class="keyword">const</code><code class="plain">;</code></div>
</div>
    </div>
<p   
>其次是<strong class=" ">BEGIN_MESSAGE_MAP、END_MESSAGE_MAP宏（</strong>这两个宏是成双结对的所以一起看）和ON_WM_LBUTTONDOWN宏（<strong class=" ">因为这个宏在它们中间调用</strong>）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define BEGIN_MESSAGE_MAP(theClass, baseClass) \</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP* theClass::GetMessageMap() </code><code class="keyword">const</code><code class="plain"> \</code></div>
<div class="line"><code class="plain">        { </code><code class="keyword">return</code><code class="plain"> &amp;theClass::messageMap; } \</code></div>
<div class="line"><code class="plain">    AFX_COMDAT AFX_DATADEF </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP theClass::messageMap = \</code></div>
<div class="line"><code class="plain">    { &amp;baseClass::messageMap, &amp;theClass::_messageEntries[</code><code class="value">0</code><code class="plain">] }; \</code></div>
<div class="line"><code class="plain">    AFX_COMDAT </code><code class="keyword">const</code><code class="plain"> AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \</code></div>
<div class="line"><code class="plain">    { \</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define ON_WM_LBUTTONDOWN() \</code></div>
<div class="line"><code class="plain">    { WM_LBUTTONDOWN, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, AfxSig_vwp, \</code></div>
<div class="line"><code class="plain">        (AFX_PMSG)(AFX_PMSGW)(</code><code class="keyword">void</code><code class="plain"> (AFX_MSG_CALL CWnd::*)(UINT, CPoint))&amp;OnLButtonDown },</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define END_MESSAGE_MAP() \ </code><code class="comments">// BEGIN_MESSAGE_MAP 和 END_MESSAGE_MAP是要拼接在一块的</code></div>
<div class="line"><code class="plain">        {</code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, AfxSig_end, (AFX_PMSG)</code><code class="value">0</code><code class="plain"> } \</code></div>
<div class="line"><code class="plain">    }; \</code></div>
</div>
    </div>
<p  class="auto-cursor-target" 
>在代码中改写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">const</code><code class="plain"> AFX_MSGMAP* CMainWindow::GetMessageMap() </code><code class="keyword">const</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> &amp;CMainWindow::messageMap;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">const</code><code class="plain"> AFX_MSGMAP CMainWindow::messageMap = {</code></div>
<div class="line"><code class="plain">    &amp;CFrameWnd::messageMap, &amp;CMainWindow::_messageEntries[</code><code class="value">0</code><code class="plain">]</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">const</code><code class="plain"> AFX_MSGMAP_ENTRY CMainWindow::_messageEntries[] = {</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        WM_LBUTTONDOWN, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, AfxSig_vwp,</code></div>
<div class="line"><code class="plain">        (AFX_PMSG)(AFX_PMSGW)(</code><code class="keyword">void</code><code class="plain"> (AFX_MSG_CALL CWnd::*)(UINT, CPoint))&amp;OnLButtonDown</code></div>
<div class="line"><code class="plain">    },</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, AfxSig_end, (AFX_PMSG)</code><code class="value">0</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>如上代码转换完成之后就可以很清晰的知道使用宏的时候<strong class=" ">鼠标左键按下</strong>必须使用<strong class=" ">OnLButtonDown这个函数名是因为这里是写死在代码中的，没办法改变</strong>；我们还可以很清晰的看见<strong class=" ">_messageEntries</strong>这个数组就是存放着我们的消息，<strong class=" ">这就是一个消息映射的表格</strong>，而这个数组是一个结构体数组，所以我们来看一下<strong class=" ">AFX_MSGMAP_ENTRY</strong>这个结构体：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct AFX_MSGMAP_ENTRY</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    UINT nMessage;   </code><code class="comments">// windows message Windows 消息类型ID</code></div>
<div class="line"><code class="plain">    UINT nCode;      </code><code class="comments">// control code or WM_NOTIFY code 对于窗口消息该值为0，处理命令消息和控件通知的函数使用与此相同的消息映像。</code></div>
<div class="line"><code class="plain">    UINT nID;        </code><code class="comments">// control ID (or 0 for windows messages) 命令消息ID的起始范围</code></div>
<div class="line"><code class="plain">    UINT nLastID;    </code><code class="comments">// used for entries specifying a range of control id's 命令消息ID范围的终点</code></div>
<div class="line"><code class="plain">    UINT nSig;       </code><code class="comments">// signature type (action) or pointer to message # 消息的动作标识 enum AfxSig 里面的成员</code></div>
<div class="line"><code class="plain">    AFX_PMSG pfn;    </code><code class="comments">// routine to call (or special value) 响应消息时应执行的函数</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>根据注释可以非常清晰的看见每个参数的意义，主要说下后两个参数，<strong class=" ">AFX_PMSG pfn为响应消息时执行的函数，这里也就是OnLButtonDown函数的地址，UINT nSig为消息的动作标识 enum AfxSig 里面的成员，在当前值为AfxSig_vwp</strong>，这是一个宏，我们可以跟进查看一下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-56-2.png" alt="images/download/attachments/17301744/image2021-6-24_14-56-2.png" width="600"  />
    </p>
<p   
>它表示着<strong class=" ">AFX_PMSG pfn（响应消息时执行的函数）</strong>的<strong class=" ">返回值和参数的格式</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_14-56-54.png" alt="images/download/attachments/17301744/image2021-6-24_14-56-54.png" width="600"  />
    </p>
<p   
>所以在内部就可以通过<strong class=" ">UINT nSig来进行函数的调用</strong>。</p>
<p   
>在当前我们的<strong class=" ">UINT nMessage参数为WM_LBUTTONDOWN</strong>，这是一个标准消息，除了标准消息在MFC还有其他两类消息。</p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLU1GQ-S4ieWkp-exu-a2iOaBrw">
        <h3 class="heading "><span>MFC&#19977;&#22823;&#31867;&#28040;&#24687;</span></h3>
<p   
><strong class=" ">1.标准消息</strong></p>
<p   
>任何以WM打头的消息都属于标准消息(除WM_COMMAND)以外</p>
<p   
><strong class=" ">2.WM_COMMAND 命令消息</strong></p>
<p   
>这是来自菜单、工具条按钮、加速键等用户接口对象的WM_COMMAND通知消息，属于应用程序自己定义的消息。通过消息映射机制，MFC框架把命令按一定的路径分发给多种类型的对象（具备消息处理能力）处理，如文档、窗口、应用程序、文档模板等对象。能处理消息映射的类必须<strong class=" ">从CCmdTarget类派生</strong>。</p>
<p   
><strong class=" ">3.控件通知</strong></p>
<p   
>通常，控件通知在某些重要事件发生时，由控件窗口发送到父窗口，如打开一个组合框。控件通知为父窗口进一步控制子窗口提供了机会。例如，打开一个组合框时，父窗口可以用组合框初建时得不到的消息填充它。</p>
<p   
>BN_XXXX是CButton产生的消息，EN_XXXX是CEdit产生的消息，等等。</p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLeWRveS7pOS8oOmAkg">
        <h1 class="heading "><span>&#21629;&#20196;&#20256;&#36882;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS7gOS5iOaYr-WRveS7pOS8oOmAkg">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#21629;&#20196;&#20256;&#36882;</span></h2>
<p   
>消息会按照规定的路线，游走于各个对象之间，直到找到它的消息处理函数；如果找不到，则最终把它交给:<strong class=" ">:DefWindowPro函数</strong>去处理。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS41">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、本节必须掌握的知识点</p>
<ul class=" "><li class=" "><p   
>通过单步调试，熟悉窗口过程处理函数在MFC的实现和命令传递的方式</p>
</li></ul><p   
>2、需要简单了解的内容</p>
<ul class=" "><li class=" "><p   
>MessageMapFunctions</p>
</li></ul>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLemAmui_h0NyZWF0ZeWHveaVsOadpeeci-eql-WPo-WIm-W7uua1geeoiw">
        <h2 class="heading "><span>&#36890;&#36807;Create&#20989;&#25968;&#26469;&#30475;&#31383;&#21475;&#21019;&#24314;&#27969;&#31243;</span></h2>
<p   
>之前我们了解过<strong class=" ">Create函数</strong>，其第一个参数（类名）为NULL，则以MFC内建的窗口类产生一个标准的外框窗口，既然它有窗口类那肯定就有窗口过程处理函数，我们需要从这个函数入手下断点去跟进。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_17-11-41.png" alt="images/download/attachments/17301744/image2021-6-24_17-11-41.png" width="600"  />
    </p>
<p   
>首先会判断一个菜单名称：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_17-13-5.png" alt="images/download/attachments/17301744/image2021-6-24_17-13-5.png" width="600"  />
    </p>
<p   
>这里我们没有，所以继续向下我们会发现其调用了一个<strong class=" ">CreateEx</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_17-13-56.png" alt="images/download/attachments/17301744/image2021-6-24_17-13-56.png" width="600"  />
    </p>
<p   
>跟进<strong class=" ">CreateEx</strong>函数，其一开始对一些信息进行了填充，这个信息传递给了<strong class=" ">PreCreateWindow</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_23-40-53.png" alt="images/download/attachments/17301744/image2021-6-24_23-40-53.png" width="600"  />
    </p>
<p   
>这边就涉及到一个新的结构体<strong class=" ">CREATESTRUCT</strong>，我们跟进看一下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_23-44-57.png" alt="images/download/attachments/17301744/image2021-6-24_23-44-57.png" width="600"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct tagCREATESTRUCTA {</code></div>
<div class="line"><code class="plain">    LPVOID      lpCreateParams; </code><code class="comments">// 创建参数</code></div>
<div class="line"><code class="plain">    HINSTANCE   hInstance; </code><code class="comments">// 窗口模块的句柄</code></div>
<div class="line"><code class="plain">    HMENU       hMenu; </code><code class="comments">// 窗口使用的菜单句柄</code></div>
<div class="line"><code class="plain">    HWND        hwndParent; </code><code class="comments">// 如果该窗口是一个子窗口，则为父窗口的句柄；如果该窗口是自有的，这个成员标识了所有者窗口；如果该窗口不是一个子窗口或自有窗口，这个成员是NULL。</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">         cy; </code><code class="comments">// 窗口的高度，单位是像素。</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">         cx; </code><code class="comments">// 窗口的宽度，单位是像素。</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">         y; </code><code class="comments">// y坐标，如果窗口是一个子窗口，坐标是相对于父窗口的，否则，坐标是相对于屏幕原点的。</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">         x; </code><code class="comments">// x坐标</code></div>
<div class="line"><code class="plain">    LONG        style; </code><code class="comments">// 窗口的样式</code></div>
<div class="line"><code class="plain">    LPCSTR      lpszName; </code><code class="comments">// 窗口的名称</code></div>
<div class="line"><code class="plain">    LPCSTR      lpszClass; </code><code class="comments">// 窗口的类名</code></div>
<div class="line"><code class="plain">    DWORD       dwExStyle; </code><code class="comments">// 扩展窗口样式</code></div>
<div class="line"><code class="plain">} CREATESTRUCTA, *LPCREATESTRUCTA;</code></div>
</div>
    </div>
<p   
>我们继续跟进<strong class=" ">PreCreateWindow</strong>函数，我们可以看见如果窗口名称为空则帮我去注册一个默认的窗口类：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-24_23-42-31.png" alt="images/download/attachments/17301744/image2021-6-24_23-42-31.png" width="600"  />
    </p>
<p   
>其使用的是<strong class=" ">AfxDeferRegisterClass</strong>，这是一个宏，其背后就是<strong class=" ">AfxEndDeferRegisterClass</strong>这个函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_0-35-47.png" alt="images/download/attachments/17301744/image2021-6-25_0-35-47.png" width="600"  />
    </p>
<p   
>通过阅读代码我们发现这个函数不是我们想要知道其是如何处理消息的函数，继续跟进，跟到<strong class=" ">CreateEx</strong>函数里面会有一个<strong class=" ">AfxHookWindowCreate</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_0-37-44.png" alt="images/download/attachments/17301744/image2021-6-25_0-37-44.png" width="600"  />
    </p>
<p   
>通过这个名字我们就知道什么意思了，其就表示在窗口创建之前挂了一个钩子（HOOK），跟进这个函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_0-38-49.png" alt="images/download/attachments/17301744/image2021-6-25_0-38-49.png" width="600"  />
    </p>
<p   
>如上图所示我么久可以看到其挂钩子的函数是<strong class=" ">SetWindowsHookEx</strong>（其第一个参数是<strong class=" ">WH_CBT</strong>，这是一个宏，其就是一个钩子，其表示可以监听窗口激活、产生、释放（关闭）、最小化、最大化或改变；那么在这些事件之前使用的函数就是<strong class=" ">_AfxCbtFilterHook</strong>，也就是第二个参数），相当于<strong class=" ">安装了一个WH_CBT类型的钩子函数_AfxCbtFilterHook</strong>，通过它将默认的窗口过程处理函数替换成了<strong class=" ">afxWndProc</strong>，<strong class=" ">这一段通过调试是没办法看见的，</strong>我们需要去寻找<strong class=" ">_AfxCbtFilterHook</strong>函数的定义，代码很长我们简化一下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LRESULT CALLBACK</code></div>
<div class="line"><code class="plain">_AfxCbtFilterHook(</code><code class="keyword">int</code><code class="plain"> code, WPARAM wParam, LPARAM lParam)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">...</code></div>
<div class="line"><code class="plain">                </code><code class="comments">// subclass the window with standard AfxWndProc</code></div>
<div class="line"><code class="plain">                WNDPROC afxWndProc = AfxGetAfxWndProc();</code></div>
<div class="line"><code class="plain">                oldWndProc = (WNDPROC)SetWindowLong(hWnd, GWL_WNDPROC,</code></div>
<div class="line"><code class="plain">                    (DWORD)afxWndProc);</code></div>
<div class="line"><code class="plain">...</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们可以通过命名发现其将老的窗口过程处理函数替换为了<strong class=" ">afxWndProc</strong>，也就是函数<strong class=" ">AfxGetAfxWndProc</strong>，我们继续跟进这段代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_0-57-42.png" alt="images/download/attachments/17301744/image2021-6-25_0-57-42.png" width="600"  />
    </p>
<p   
>发现其会判断是否定义了<strong class=" ">_AFXDLL宏</strong>，经查阅发现这是判断是否使用了动态链接库，而我们现在使用的是静态链接库，在这自然不存在所以返回的就是<strong class=" ">AfxWndProc</strong>这个函数的地址。</p>
<p   
>如果你想通过调试去看见这个过程的话，我们就需要借助消息处理函数，例如之前学习的<strong class=" ">OnLButtonDown</strong>函数，在这下断点进行跟进即可（别忘记要左键按下触发事件才能跟进）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-7-12.png" alt="images/download/attachments/17301744/image2021-6-25_1-7-12.png" width="600"  />
    </p>
<p   
>跟着跟着你就发现跟到了<strong class=" ">AfxWndProc</strong>这个函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-11-9.png" alt="images/download/attachments/17301744/image2021-6-25_1-11-9.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLea2iOaBr-WkhOeQhua1geeoiw">
        <h2 class="heading "><span>&#28040;&#24687;&#22788;&#29702;&#27969;&#31243;</span></h2>
<p   
>在<strong class=" ">OnLButtonDown</strong>函数这下断点进行来看一下消息处理的流程。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-7-12.png" alt="images/download/attachments/17301744/image2021-6-25_1-7-12.png" width="600"  />
    </p>
<p   
>跟到函数<strong class=" ">AfxCallWndProc</strong>，在如下图所示的位置下断点：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-24-15.png" alt="images/download/attachments/17301744/image2021-6-25_1-24-15.png" width="600"  />
    </p>
<p   
>下一个条件断点，当<strong class=" ">nMsg == 0x0201（#define WM_LBUTTONDOWN 0x0201）</strong>，也就是当消息类型是左键按下时断点：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-29-1.png" alt="images/download/attachments/17301744/image2021-6-25_1-29-1.png" width="600"  />
    </p>
<p   
>下完条件断点之后我们可以重新运行程序：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-29-53.png" alt="images/download/attachments/17301744/image2021-6-25_1-29-53.png" width="600"  />
    </p>
<p   
>这时候就会有提示，那就说明断点下成功了，继续跟进代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-31-26.png" alt="images/download/attachments/17301744/image2021-6-25_1-31-26.png" width="600"  />
    </p>
<p   
>我们可以看见消息是通过<strong class=" ">WindowProc</strong>函数的，这个函数是一个虚函数，也就表示我们可以在类中改写这个函数，但是这里我们没有改写其调用的就是<strong class=" ">CWnd::WindowProc</strong>。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-33-26.png" alt="images/download/attachments/17301744/image2021-6-25_1-33-26.png" width="600"  />
    </p>
<p   
>而这里面的<strong class=" ">OnWndMsg</strong>同样也是一个虚函数，我们是可以改写的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-34-12.png" alt="images/download/attachments/17301744/image2021-6-25_1-34-12.png" width="600"  />
    </p>
<p   
>在这里我也没改写，所以进入的就是<strong class=" ">CWnd::OnWndMsg</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-36-4.png" alt="images/download/attachments/17301744/image2021-6-25_1-36-4.png" width="600"  />
    </p>
<p   
>开头几个判断就是判读你的消息类型，当都没有的情况下则表示这是一个<strong class=" ">标准消息</strong>。</p>
<p   
>其会有一个<strong class=" ">pMessageMap</strong>结构体，这个结构体存储的就是一个消息映射表，我们跟进之后会发现其会不停的基于<strong class=" ">pBaseMap</strong>成员去重新赋值直到没有为止：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-44-0.png" alt="images/download/attachments/17301744/image2021-6-25_1-44-0.png" width="600"  />
    </p>
<p   
>继续根据会发现其会通过<strong class=" ">AfxFindMessageEntry</strong>函数在消息映射表中去寻找第一个参数的<strong class=" ">nMessage</strong>与第二个参数<strong class=" ">message</strong>是否一致：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-46-11.png" alt="images/download/attachments/17301744/image2021-6-25_1-46-11.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-48-46.png" alt="images/download/attachments/17301744/image2021-6-25_1-48-46.png" width="600"  />
    </p>
<p   
>继续跟进代码你会发现<strong class=" ">MessageMapFunctions</strong>结构体，这个表就是告诉我们当前函数（左键按下）是什么返回值、什么参数，然后将pfn（当前函数地址）保存到其成员<strong class=" ">pfn</strong>里：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-49-49.png" alt="images/download/attachments/17301744/image2021-6-25_1-49-49.png"  height="142" />
    </p>
<p   
>然后通过<strong class=" ">nSig（消息的动作标识 enum AfxSig 里面的成员）</strong>去转换参数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-54-15.png" alt="images/download/attachments/17301744/image2021-6-25_1-54-15.png" width="600"  />
    </p>
<p   
>...</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_1-55-39.png" alt="images/download/attachments/17301744/image2021-6-25_1-55-39.png" width="600"  />
    </p>
<p   
>然后通过这样的方式将对应的参数传递给我们的消息处理函数，执行该函数。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-a6kOeggeWIhuaekA">
        <h1 class="heading "><span>MFC&#28304;&#30721;&#20998;&#26512;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOaYr-efpeivhueCuQ">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#26159;&#30693;&#35782;&#28857;</span></h2>
<p   
>1、通过从MFC的<strong class=" ">AfxWinmain</strong>入口函数下断，分析他的大概框架原理</p>
<p   
>2、CWinApp 取代 WinMain</p>
<p   
>3、CFrameWnd 取代 WndProc</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLU1GQ-eahFdpbk1haW7liIbmnpA">
        <h2 class="heading "><span>MFC&#30340;WinMain&#20998;&#26512;</span></h2>
<p   
>MFC的入口函数是<strong class=" ">AfxWinMain</strong>，其有四个参数都保存在保存在<strong class=" ">theApp</strong>的成员内（如下代码为删减版本）</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,</code></div>
<div class="line"><code class="plain">    LPTSTR lpCmdLine, </code><code class="keyword">int</code><code class="plain"> nCmdShow)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    CWinThread* pThread = AfxGetThread(); </code><code class="comments">// 获取当前线程</code></div>
<div class="line"><code class="plain">    CWinApp* pApp = AfxGetApp(); </code><code class="comments">// 获取当前实例化的对象</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 实际上其获取到的都是我们的theApp，因为一个进程肯定包含一个线程，所以这里我们可以认为pApp等价于pThread</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    AfxWinInit() </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 并在内部调用 AfxInitThread 把消息队列加大</code></div>
<div class="line"><code class="plain">    pApp-&gt;InitApplication() </code><code class="comments">// 原来的初始化，已经过时，不推荐使用</code></div>
<div class="line"><code class="plain">    pThread-&gt;InitInstance() </code><code class="comments">// 代替InitApplication，在里面创建窗口</code></div>
<div class="line"><code class="plain">    pThread-&gt;Run() </code><code class="comments">// 代替Win32的消息循环</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们F12跟进AfxWinMain函数然后下个断点来跟一下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-25_22-50-27.png" alt="images/download/attachments/17301744/image2021-6-25_22-50-27.png" width="600"  />
    </p>
<p   
>然后我们重新运行代码跟到断点的地方继续跟进会发现<strong class=" ">pThread、pApp</strong>确实如我们所说是等价的，都是获取的我们实例化的对象：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-40-44.png" alt="images/download/attachments/17301744/image2021-6-26_18-40-44.png" width="600"  />
    </p>
<p   
>然后我们进入<strong class=" ">AfxWinInit</strong>函数，跟进发现在该函数内部会在获取一次我们实例化的对象，然后判断是否存在，存在则把入口点的四个参数保存在我们实例化对象的成员里：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-42-40.png" alt="images/download/attachments/17301744/image2021-6-26_18-42-40.png" width="600"  />
    </p>
<p   
>所以我们在重写<strong class=" ">InitInstance函数直接使用m_nCmdShow变量</strong>实际上使用的就是自己的成员：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-44-51.png" alt="images/download/attachments/17301744/image2021-6-26_18-44-51.png" width="600"  />
    </p>
<p   
>而后继续跟进代码是<strong class=" ">AfxInitThread</strong>函数，该函数就是增加消息队列，初始化线程特别数据（<strong class=" ">为主线程作了一些初始化工作</strong>）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-47-48.png" alt="images/download/attachments/17301744/image2021-6-26_18-47-48.png" width="600"  />
    </p>
<p   
>再回到<strong class=" ">AfxWinMain</strong>函数，接下来就是一个<strong class=" ">InitApplication</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-50-2.png" alt="images/download/attachments/17301744/image2021-6-26_18-50-2.png" width="600"  />
    </p>
<p   
>我们之前提到这是MFC原来使用的初始化函数，在现在已经过时了，所以不推荐使用，我们可以忽略，继续跟进：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-51-31.png" alt="images/download/attachments/17301744/image2021-6-26_18-51-31.png" width="600"  />
    </p>
<p   
><strong class=" ">InitInstance函数</strong>就是我们的核心，在该函数内创建窗口，它是一个虚函数，因为我们在<strong class=" ">CMyWinApp类</strong>继承并重写了该函数，现在我们进入的就是我们重写的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-53-40.png" alt="images/download/attachments/17301744/image2021-6-26_18-53-40.png" width="600"  />
    </p>
<p   
>这段代码写了很多遍了，首先我们创建了一个对象，并在<strong class=" ">CMainWindow</strong>类的构造函数中使用<strong class=" ">Create</strong>函数创建了窗口，而后就是一些流程化的东西，<strong class=" ">最后一个返回为TRUE</strong>，这个相信很多人会疑惑，其实在代码中写的就很明确了，<strong class=" ">如果你不为TRUE，则会异常打印、销毁窗口（如果没有创建窗口则退出实例）</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_18-51-31.png" alt="images/download/attachments/17301744/image2021-6-26_18-51-31.png" width="600"  />
    </p>
<p   
>接下来继续跟进就是<strong class=" ">Run</strong>函数，该函数实现的就是我们Win32里面的消息循环：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-1-10.png" alt="images/download/attachments/17301744/image2021-6-26_19-1-10.png" width="600"  />
    </p>
<p   
>这里又调用了<strong class=" ">CWinThread::Run()</strong>，我们继续跟进，在很多书中将该函数称为MFC的控制中心，因为在MFC中所有消息队列、消息分派都在<strong class=" ">CWinThread::Run()</strong>中去完成，它与<strong class=" ">AfxWinMain</strong>一样是对普通程序员来说是不可见的。</p>
<p   
>其处理流程就是先根据两个标志（空闲标志）去判断当前线程是否是空闲状态，首先在这里我们发现在这里调用并不是<strong class=" ">GetMessage</strong>函数而是<strong class=" ">PeekMessage</strong>函数，该两者区别如下：</p>
<p   
><strong class=" ">相同点：PeekMessage函数与GetMessage函数都用于查看应用程序消息队列</strong>，有消息时将队列中的消息派发出去。</p>
<p   
><strong class=" ">不同点：</strong>无论应用程序消息队列是否有消息，<strong class=" ">PeekMessage</strong>函数都立即返回，程序得以继续执行后面的语句（无消息则执行其它指令，有消息时一般要将消息派发出去，再执行其它指令）；<strong class=" ">GetMessage</strong>函数只有在消息对立中有消息时返回，队列中无消息就会一直等，直至下一个消息出现时才返回。在等的这段时间，应用程序不能执行任何指令。</p>
<p   
>而后如果是空闲状态则调用<strong class=" ">OnIdle</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-2-26.png" alt="images/download/attachments/17301744/image2021-6-26_19-2-26.png" width="600"  />
    </p>
<p   
><strong class=" ">OnIdle</strong>函数是一个虚函数，是<strong class=" ">CWinApp</strong>的成员方法，所以我们可以重写该函数以便让我们的程序在空闲状态下做一些操作：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-8-4.png" alt="images/download/attachments/17301744/image2021-6-26_19-8-4.png" width="600"  />
    </p>
<p   
>继续跟进发现是一个<strong class=" ">PumpMessage</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-32-48.png" alt="images/download/attachments/17301744/image2021-6-26_19-32-48.png" width="600"  />
    </p>
<p   
>在这个函数内就会去使用<strong class=" ">GetMessage</strong>函数去判断有没有消息，由于我们之前是已经判断过了才进的这个函数，所以这里会立即返回：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-33-25.png" alt="images/download/attachments/17301744/image2021-6-26_19-33-25.png" width="600"  />
    </p>
<p   
>继续跟进就会发现我们熟悉的消息转换、分发：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-35-23.png" alt="images/download/attachments/17301744/image2021-6-26_19-35-23.png" width="600"  />
    </p>
<p   
>再回到<strong class=" ">Run</strong>函数接下里调用的就是<strong class=" ">IsIdleMessage</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-36-36.png" alt="images/download/attachments/17301744/image2021-6-26_19-36-36.png" width="600"  />
    </p>
<p   
>至此，我们就分析完Run函数了，其与Win32的消息循环本质没有区别，唯一的区别就是其多了一个空闲状态。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWIm-W7uuWcqOWghuS4iueahENNYWluV2luZG93">
        <h2 class="heading "><span>&#21019;&#24314;&#22312;&#22534;&#19978;&#30340;CMainWindow</span></h2>
<p   
>分析完Run函数，其实我们还有一个问题没有解决，那就是我们实例化CMainWodw，使用的关键词是new，该关键词是在堆上创建的，而我们不使用需要去释放，否则则会造成安全隐患（内存泄漏），我们在代码中没有去写这类操作，实际上这些都在MFC内部去完成的。</p>
<p   
>当窗口关闭的时候程序都会调用一个虚函数CMainWodw:PostNcDestroy，这个函数是CFrameWnd的，其默认就是一个<strong class=" ">delete this</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-52-8.png" alt="images/download/attachments/17301744/image2021-6-26_19-52-8.png" width="600"  />
    </p>
<p   
>我们可以在自己的类中去重写一下，在delete之前做一些别的操作：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_19-53-0.png" alt="images/download/attachments/17301744/image2021-6-26_19-53-0.png" width="600"  />
    </p>
<p   
><strong class=" ">但需要注意的是</strong>如果你继承的不是CFrameWnd而是CWnd，其是没有<strong class=" ">delete this</strong>这样一个操作的，你就需要自己写。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLUdESeWfuuehgOamguW_teWSjE1GQ-eahENEQ-exuw">
        <h1 class="heading "><span>GDI&#22522;&#30784;&#27010;&#24565;&#21644;MFC&#30340;CDC&#31867;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS42">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>对GDI和DC有一定的理解</p>
</li><li class=" "><p   
>MFC所封装的三个主要设备描述表</p>
<ol class=" "><li class=" "><p   
>CPaintDC</p>
</li><li class=" "><p   
>CClientDC</p>
</li><li class=" "><p   
>CWindowDC</p>
</li></ol></li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWfuuehgOamguW_tQ">
        <h2 class="heading "><span>&#22522;&#30784;&#27010;&#24565;</span></h2>
<p   
><strong class=" ">GDI图形设备接口</strong>：Window中负责图形输出的是Graphics Device Interface(图形设备接口)，它为应用程序提供了可调用的多种服务，这些服务一起构成了强大和通用的图形编程语言。</p>
<p   
><strong class=" ">DC设备描述表（设备上下文）</strong>：当Window程序在屏幕、打印机或者其它输出设备上画图时，它并不将像素直接输出到设备上，而是将图绘制到设备描述表DC当中，表示逻辑意义上的显示平面，它是Window中的一种数据结构，包含了GDI需要的所有关于显示平面情况的描述。</p>
<p   
>早期，要开发一个图形软件，我需要知道输出设备的显卡，然后根据厂家提供的不同地接口去编写，所以我们开发软件就会非常困难；在Windows里面通过对驱动程序的统一管理，将设备接口细节隐藏在系统内部，我们不需要去管那么多东西，我们在编写图形软件的时候用一个公用的虚拟设备即可，这个虚拟设备就是DC。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNEQ-exuw">
        <h2 class="heading "><span>CDC&#31867;</span></h2>
<p   
>MFC的CDC类将DC和HDC（DC的句柄）的GDI函数就近封装到了一起，派生了四个不同场景下的DC类，以下是常用的三个：</p>
<ul class=" "><li class=" "><p   
>CPaintDC：用于在窗口客户区画图，仅限于OnPaint函数内</p>
</li><li class=" "><p   
>CClientDC：用于在窗口客户区画图，除了OnPaint外的函数内</p>
</li><li class=" "><p   
>CWindowDC：用于在窗口内任意地方画图，抱括非客户区</p>
</li></ul>    <div class="section section-3" id="src-17301744_safe-id-TUZDLeS9v-eUqENEQ-exuw">
        <h3 class="heading "><span>&#20351;&#29992;CDC&#31867;</span></h3>
<p   
>Win32 API和MFC的<strong class=" ">CPaintDC</strong>类对比，很明显我们可以看出代码量变得非常少：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_20-53-30.png" alt="images/download/attachments/17301744/image2021-6-26_20-53-30.png" width="600"  />
    </p>
<p   
>如上代码中Win32 API的代码我们使用了双冒号这是因为使用<u class=" "><strong class=" ">::双冒号</strong></u>指的是从全局调用，如果在Win32这种工程中加与不加影响倒是不大，但在MFC的工程中，默认MFC中的窗口类<strong class=" ">CWnd其成员函数</strong>有很多都是跟Win32 API重名，比如：<strong class=" ">ShowWindow、GetMessage、GetWindowText等等</strong>，所以这时候如果你在CWnd或其派生类中调用了<strong class=" ">ShowWindow</strong>之后，<strong class=" ">默认调用的就是CWnd的成员函数ShowWindow</strong>，如果你想要调用全局的，<strong class=" ">那么就必须使用双冒号前缀</strong>。</p>
<p   
>我们使用<strong class=" ">CPaintDC</strong>类需要注意：1. 在声明类的时候创建对应的函数 2. 在消息映射区（BEGIN_MESSAGE_MAP宏和END_MESSAGE_MAP宏之前）声明，例如如上的OnPaint函数我就就需要声明ON_WM_PAINT 3. 重写函数</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_21-3-2.png" alt="images/download/attachments/17301744/image2021-6-26_21-3-2.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLURD6K6-5aSH5o-P6L-w6KGo55qE5LiA5Lqb5bGe5oCn">
        <h3 class="heading "><span>DC&#35774;&#22791;&#25551;&#36848;&#34920;&#30340;&#19968;&#20123;&#23646;&#24615;</span></h3>
<p   
>如下图所示为DC设备描述表的一些属性：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_20-57-52.png" alt="images/download/attachments/17301744/image2021-6-26_20-57-52.png" width="400"  />
    </p>
<p   
>你可以通过设置方法来设置属性，通过获取方法来获取属性：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_21-10-2.png" alt="images/download/attachments/17301744/image2021-6-26_21-10-2.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_MFC-WindowsGDI">
        <h1 class="heading "><span>Windows GDI</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS43">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>理解GDI中的页面空间和设备空间(逻辑坐标和设备坐标)以及映射模式</p>
</li><li class=" "><p   
>理解窗口和视口以及对应的原点和范围</p>
</li><li class=" "><p   
>理解设备空间的三大坐标系：</p>
<ol class=" "><li class=" "><p   
>客户区域坐标</p>
</li><li class=" "><p   
>屏幕坐标</p>
</li><li class=" "><p   
>窗口坐标</p>
</li></ol></li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUdESeeahOaYoOWwhOaooeW8jw">
        <h2 class="heading "><span>GDI&#30340;&#26144;&#23556;&#27169;&#24335;</span></h2>
<p   
>映射模式是设备描述表的属性，用于确定逻辑坐标值到设备坐标值的转换，传送给CDC输出函数的是逻辑坐标值，设备坐标值是指窗口中相应的像素位置。</p>
<p   
>调用成员函数<strong class=" ">CDC::SetMapMod</strong>来修改映射模式，我们正常的映射模式是一个像素点，也就是MM_TEXT，其x轴向右，y轴向下，如下图表有很多种映射模式：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_22-2-29.png" alt="images/download/attachments/17301744/image2021-6-26_22-2-29.png" width="400"  />
    </p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>映射模式</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>一个逻辑单位</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>x和y轴的方向(右，下)</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_TEXT</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>1像素</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y+ （x向右则是+，y向下则是+）</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_LOMETRIC</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0.1毫米</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y- （x向右则是+，y向下则是-）</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_HIMETRIC</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0.01毫米</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y-</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_LOENGLISH</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0.01英寸</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y-</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_HIENGLISH</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0.001英寸</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y-</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_TWIPS</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>1/1440英寸</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>x+ y-</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_ISOTROPIC</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用户自定义(x,y同等缩放)</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用户自定义</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MM_ANISOTROPIC</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用户自定义(x和y独立缩放)</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用户自定义</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUdESeeahOWdkOagh-epuumXtA">
        <h2 class="heading "><span>GDI&#30340;&#22352;&#26631;&#31354;&#38388;</span></h2>
<p   
>Windows下的程序运用坐标空间和转换来对图形输出进行缩放、旋转、平移、斜切和反射；坐标空间是一个平面的空间，通过使用两个互相垂直并且长度相等的轴来定位二维对象。</p>
<p   
>Win32 API使用四种坐标空间：</p>
<ol class=" "><li class=" "><p   
>世界坐标系空间：在应用程序调用SetWorldTransform函数之前，不会出现世界坐标空间到页面空间的转换</p>
</li><li class=" "><p   
>页面空间（窗口）：逻辑坐标与设备无关，在窗口中进行描述时使用逻辑坐标</p>
</li><li class=" "><p   
>设备空间（视口）：图形输出时，Windows将GDI函数中指定的逻辑坐标映射为设备坐标</p>
</li><li class=" "><p   
>物理设备：屏幕、打印机等</p>
</li></ol><p   
>如下图所示，通过将页面空间的原点映射到设备空间的原点，再将设备空间的原点映射到物理设备上，通过一层层的转换才可以通过物理设备看最终显示的结果：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_22-23-51.png" alt="images/download/attachments/17301744/image2021-6-26_22-23-51.png" width="400"  />
    </p>
<p   
>将页面空间转到设备空间，就是通过映射模式，在设备空间里的单位是像素，而在逻辑坐标内则是我们自定义，这取决于映射模式。</p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeS_ruaUueaYoOWwhOaooeW8jw">
        <h3 class="heading "><span>&#20462;&#25913;&#26144;&#23556;&#27169;&#24335;</span></h3>
<p   
>我们来尝试一下修改映射模式，然后画一个圆，首先我们看下正常的映射模式：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-6-59.png" alt="images/download/attachments/17301744/image2021-6-26_23-6-59.png" width="600"  />
    </p>
<p   
>选择<strong class=" ">MM_LOMETRIC</strong>，一个逻辑单位是0.1毫米，x向右则加，y向下则减，所以参数最后要改成-300：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-5-1.png" alt="images/download/attachments/17301744/image2021-6-26_23-5-1.png" width="600"  />
    </p>
<p   
>因为不同的设备有不同的屏幕，也就造成了像素点不一样的情况，通过指定逻辑单位，我们只需要操作逻辑坐标而不需要去管设备，更换不同的设备依然可以精准的显示我们指定的长度。</p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeeUqOaIt-iHquWumuS5ieaYoOWwhOaooeW8jw">
        <h3 class="heading "><span>&#29992;&#25143;&#33258;&#23450;&#20041;&#26144;&#23556;&#27169;&#24335;</span></h3>
<p   
>用户自定义的映射模式有：MM_ISOTROPIC、MM_ANISOTROPIC</p>
<p   
><strong class=" ">MM_ISOTROPIC</strong>这个映射模式其x、y同等缩放，示例代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rect;</code></div>
<div class="line"><code class="plain">    GetClientRect(&amp;rect); </code><code class="comments">// 这个函数将CWnd的客户区的客户坐标拷贝到指向的结构中</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.SetMapMode(MM_ISOTROPIC); </code><code class="comments">// 设置映射模式</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.SetWindowExt(</code><code class="value">100</code><code class="plain">,</code><code class="value">100</code><code class="plain">); </code><code class="comments">// 设置窗口大小</code></div>
<div class="line"><code class="plain">    dc.SetViewportExt(rect.Width(), rect.Height()); </code><code class="comments">// 设置视口大小</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.Ellipse(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">100</code><code class="plain">,</code><code class="value">100</code><code class="plain">); </code><code class="comments">// 画圆</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>无论我的窗口有多大都是同等比例去缩放的，并且都是一个正圆形：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-24-16.png" alt="images/download/attachments/17301744/image2021-6-26_23-24-16.png" width="400"  />
    </p>
<p   
><strong class=" ">MM_ANISOTROPIC</strong>这个映射模式其x、y独立缩放，在这个模式下画的圆就会填满整个窗口，x、y也都各自按照各自的来缩放：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-27-20.png" alt="images/download/attachments/17301744/image2021-6-26_23-27-20.png" width="400"  />
    </p>
<p   
>GDI的文本和图形输出函数使用逻辑坐标，而在客户区移动或按下鼠标的鼠标位置是采用设备坐标；在我们没有修改映射模式的时候则逻辑坐标与设备坐标等同。</p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLU9uTEJ1dHRvbkRvd27lh73mlbA">
        <h3 class="heading "><span>OnLButtonDown&#20989;&#25968;</span></h3>
<p   
>我们在<strong class=" ">OnLButtonDown</strong>函数中写一个当鼠标左键按下则画一个圆形的功能：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-50-14.png" alt="images/download/attachments/17301744/image2021-6-26_23-50-14.png" width="600"  />
    </p>
<p   
>这里的<strong class=" ">point</strong>实际上就是设备坐标，当我们修改了映射模式为<strong class=" ">MM_LOMETRIC</strong>则就没有办法看见圆形了，我们就需要使用函数<strong class=" ">DPtoLP</strong>来转换：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-26_23-54-13.png" alt="images/download/attachments/17301744/image2021-6-26_23-54-13.png" width="600"  />
    </p>
<p   
>但是这个这个实际上与我们的功能差了一些，因为模式为<strong class=" ">MM_LOMETRIC</strong>，其x向右则加，y向下则减，所以在代码中的<strong class=" ">point.y+100</strong>需要改成<strong class=" ">point.y-100</strong>。</p>
<p   
>同理，我们想转换逻辑坐标为设备坐标可以使用函数<strong class=" ">LPtoDP</strong>。</p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeabtOaUueWOn-eCuQ">
        <h2 class="heading "><span>&#26356;&#25913;&#21407;&#28857;</span></h2>
<p   
>我们可以通过<strong class=" ">SetWindowOrg</strong>函数来更改窗口的原点，所以呈现给我们的100,100那一部分实际上就是一个缺失的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_0-5-42.png" alt="images/download/attachments/17301744/image2021-6-27_0-5-42.png" width="600"  />
    </p>
<p   
>我们想要画一个正常的原就需要在画圆的时候指定坐标：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_0-16-50.png" alt="images/download/attachments/17301744/image2021-6-27_0-16-50.png" width="600"  />
    </p>
<p   
>同样我们可以更改设备空间的原点，使用函数<strong class=" ">SetViewportOrg</strong>：</p>
<p   
><strong class=" "><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_0-19-29.png" alt="images/download/attachments/17301744/image2021-6-27_0-19-29.png" width="600"  />
</strong></p>
<p   
>在这里就是将页面空间的0,0映射到设备空间的100,100，也就表示我们后续画圆从100,100开始也就是从设备空间的200开始。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeiuvuWkh-epuumXtOS4i-eahOWdkOagh-ezuw">
        <h2 class="heading "><span>&#35774;&#22791;&#31354;&#38388;&#19979;&#30340;&#22352;&#26631;&#31995;</span></h2>
<p   
>设备空间下的坐标系分为三类：1. 客户区坐标 2. 屏幕坐标 3. 全窗口坐标，如下图所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_0-27-19.png" alt="images/download/attachments/17301744/image2021-6-27_0-27-19.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLUdESee7mOWbvg">
        <h1 class="heading "><span>GDI&#32472;&#22270;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS44">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>对GDI的常用绘图函数有一个基本的了解</p>
</li><li class=" "><p   
>了解GDI的画笔、画刷以及字体</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeW4uOeUqOeahOe7mOWbvuWHveaVsA">
        <h2 class="heading "><span>&#24120;&#29992;&#30340;&#32472;&#22270;&#20989;&#25968;</span></h2>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>函数名</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>作用</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>MoveTo</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>在画线前设定当前位置（起始位置）</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LineTo</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>从当前位置画一条线到指定位置（终止位置）</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>Polyline</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>将一系列点用线段连接起来</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>PolylineTo</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>从当前位置开始将一系列点用线段连接起来</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>Ellipse</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>画一个圆或者椭圆</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>Rectangle</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>画一个带直角的矩形</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>FillRect</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用指定的画刷填充矩形</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>Draw3dRect</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>用来实现3D立体感</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUxpbmVUb-WHveaVsOeUu-e6vw">
        <h3 class="heading "><span>LineTo&#20989;&#25968;&#30011;&#32447;</span></h3>
<p   
>使用<strong class=" ">LineTo</strong>函数画线需要搭配<strong class=" ">MoveTo</strong>函数，<strong class=" ">MoveTo</strong>函数决定了画一条线的其实位置，<strong class=" ">LineTo</strong>函数则是开始画一条线然后到终止位置，而后如果你想再画一条线实际上就要遵循最后一次<strong class=" ">LineTo</strong>函数终止位置开始画。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    dc.MoveTo(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">); </code><code class="comments">// x=10 y=10开始</code></div>
<div class="line"><code class="plain">    dc.LineTo(</code><code class="value">30</code><code class="plain">,</code><code class="value">10</code><code class="plain">); </code><code class="comments">// 横着画，x增加，y不变</code></div>
<div class="line"><code class="plain">    dc.LineTo(</code><code class="value">30</code><code class="plain">,</code><code class="value">30</code><code class="plain">); </code><code class="comments">// 竖着画，遵循上一LineTo的x，y坐标为起点，x不变，y增加</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_23-20-50.png" alt="images/download/attachments/17301744/image2021-6-27_23-20-50.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLVBvbHlsaW5l5Ye95pWw57q_5q616L-e5o6l">
        <h3 class="heading "><span>Polyline&#20989;&#25968;&#32447;&#27573;&#36830;&#25509;</span></h3>
<p   
><strong class=" ">Polyline</strong>函数就是将一系列点用线段连接起来，其参数就是一个<strong class=" ">LPPOINT</strong>的指针（直接使用数组名就表示是数组首地址，所以我们可以直接使用POINT来定义一个数组传入进去）和一个int类型的参数（这个表示有多少个点，每个点都是基于x, y坐标的）。</p>
<p   
>如下代码我们可以构建连接点绘制一个正方形：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    POINT pt[</code><code class="value">5</code><code class="plain">] = {{</code><code class="value">40</code><code class="plain">, </code><code class="value">40</code><code class="plain">}, {</code><code class="value">100</code><code class="plain">, </code><code class="value">40</code><code class="plain">}, {</code><code class="value">100</code><code class="plain">, </code><code class="value">100</code><code class="plain">}, {</code><code class="value">40</code><code class="plain">, </code><code class="value">100</code><code class="plain">}, {</code><code class="value">40</code><code class="plain">, </code><code class="value">40</code><code class="plain">}}; </code><code class="comments">// 定义数组 x, y</code></div>
<div class="line"><code class="plain">    dc.Polyline(pt, </code><code class="value">5</code><code class="plain">); </code><code class="comments">// 连接成一个正方形，</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_23-40-39.png" alt="images/download/attachments/17301744/image2021-6-27_23-40-39.png" width="600"  />
    </p>
<p   
>有很多人可能会好奇为什么连接4个点需要5组x, y坐标，如下图就是其绘制正方形的流程：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_23-40-10.png" alt="images/download/attachments/17301744/image2021-6-27_23-40-10.png" width="400"  />
    </p>
<p   
>如果你不想这么复杂，我们可以使用<strong class=" ">PolylineTo</strong>函数。</p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLVBvbHlsaW5lVG_lh73mlbDnur_mrrXov57mjqU">
        <h3 class="heading "><span>PolylineTo&#20989;&#25968;&#32447;&#27573;&#36830;&#25509;</span></h3>
<p   
><strong class=" ">PolylineTo</strong>函数和<strong class=" ">Polyline</strong>函数没有本质区别，唯一的区别其在使用上需要指定一个起始位置，并且不需要5组x, y坐标，只需要4组就可以了。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    POINT pt[</code><code class="value">5</code><code class="plain">] = {{</code><code class="value">100</code><code class="plain">, </code><code class="value">40</code><code class="plain">}, {</code><code class="value">100</code><code class="plain">, </code><code class="value">100</code><code class="plain">}, {</code><code class="value">40</code><code class="plain">, </code><code class="value">100</code><code class="plain">}, {</code><code class="value">40</code><code class="plain">, </code><code class="value">40</code><code class="plain">}}; </code><code class="comments">// 定义数组 x, y</code></div>
<div class="line"><code class="plain">    dc.MoveTo(</code><code class="value">40</code><code class="plain">, </code><code class="value">40</code><code class="plain">); </code><code class="comments">// 指定一个起始位置</code></div>
<div class="line"><code class="plain">    dc.PolylineTo(pt, </code><code class="value">4</code><code class="plain">); </code><code class="comments">// 连接成一个正方形</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_23-45-3.png" alt="images/download/attachments/17301744/image2021-6-27_23-45-3.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUVsbGlwc2Xlh73mlbDnlLvlnIY">
        <h3 class="heading "><span>Ellipse&#20989;&#25968;&#30011;&#22278;</span></h3>
<p   
><strong class=" ">Ellipse</strong>函数用来画圆，之前也使用到过但是没有仔细讲解其细节，首先我们看下它可以接受的传参：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_23-50-6.png" alt="images/download/attachments/17301744/image2021-6-27_23-50-6.png" width="600"  />
    </p>
<p   
>4个int类型的参数，或者一个<strong class=" ">LPCRECT</strong>类型的参数（这个可以通过<strong class=" ">CRect</strong>来创建，原因如下图所示，<strong class=" ">LPCRECT</strong>本质上就是一个宏，其用于表示<strong class=" ">RECT指针</strong>，而<strong class=" ">RECT</strong>则是<strong class=" ">tagRECT</strong>实例化的对象，<strong class=" ">CRect</strong>又继承于<strong class=" ">tagRECT</strong>，所以我们可以直接使用<strong class=" ">CRect</strong>来创建），而如果你使用<strong class=" ">CRect</strong>创建对象传入的还是四个int类型的参数，其实本质上和直接传入4个int类型的参数没有区别：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-49-56.png" alt="images/download/attachments/17301744/image2021-6-28_0-49-56.png" width="600"  />
    </p>
<p   
>四个参数依次都分别表示左、上、右、下，实际上也可以理解为前2个参数为左上角的x, y坐标，后2个参数为右下角的x, y坐标。</p>
<p   
>例如如下代码，我们指定左上角坐标为：<strong class=" "><u class=" ">10, 10</u></strong>，指定右下角坐标为：<u class=" "><strong class=" ">20, 20</strong></u>然后画圆：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    dc.Ellipse(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">20</code><code class="plain">,</code><code class="value">20</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-7-34.png" alt="images/download/attachments/17301744/image2021-6-28_0-7-34.png" width="600"  />
    </p>
<p   
>其原理如下图所示（<strong class=" ">个人见解</strong>），从10, 10到20, 20画一条直线，而后取中心点，在中心点开始画圆（类似圆规）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-2-48.png" alt="images/download/attachments/17301744/image2021-6-28_0-2-48.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLVJlY3RhbmdsZeWHveaVsOeUu-ebtOinkuefqeW9og">
        <h3 class="heading "><span>Rectangle&#20989;&#25968;&#30011;&#30452;&#35282;&#30697;&#24418;</span></h3>
<p   
><strong class=" ">Rectangle</strong>函数画直角矩形，其参数与<strong class=" ">Ellipse</strong>函数是一样的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-11-37.png" alt="images/download/attachments/17301744/image2021-6-28_0-11-37.png" width="600"  />
    </p>
<p   
>所以使用方法也是一样的，如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    dc.Rectangle(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">20</code><code class="plain">,</code><code class="value">20</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-12-29.png" alt="images/download/attachments/17301744/image2021-6-28_0-12-29.png" width="600"  />
    </p>
<p   
>其原理如下图所示（<strong class=" ">个人见解</strong>），<strong class=" ">10, 10和20, 20就是为了确定位置，另外两个点就是10, 20和20, 10了</strong>，这个就可以通过给的对角线的两个点来确定：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-17-18.png" alt="images/download/attachments/17301744/image2021-6-28_0-17-18.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUZpbGxSZWN05Ye95pWw5oyH5a6a55S75Yi35aGr5YWF55-p5b2i">
        <h3 class="heading "><span>FillRect&#20989;&#25968;&#25351;&#23450;&#30011;&#21047;&#22635;&#20805;&#30697;&#24418;</span></h3>
<p   
>我们之前画的矩形都没有任何颜色，默认的就是一共跟底色一样的颜色，所以我们可以通过<strong class=" ">FillRect</strong>函数指定画刷来填充矩形。</p>
<p   
><strong class=" ">FillRect</strong>函数的语法格式如下所示：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> FillRect(LPCRECT lpRect, CBrush* pBrush)</code></div>
</div>
    </div>
<p   
>该函数第一个参数为LPCRECT，所以我们Rectangle函数也使用LPCRECT，这样便于使用；第二个参数是一个CBrush类指针，也就是我们的画刷。</p>
<p   
>如下代码，我们使用亮灰色画刷来填充矩形：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rect(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">20</code><code class="plain">,</code><code class="value">20</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CBrush brush;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.Rectangle(rect);</code></div>
<div class="line"><code class="plain">    brush.CreateStockObject(LTGRAY_BRUSH); </code><code class="comments">// 初始化画刷，LTGRAY_BRUSH -&gt; 亮灰色画刷</code></div>
<div class="line"><code class="plain">    dc.FillRect(rect, &amp;brush); </code><code class="comments">// 由于该函数第一个参数为LPCRECT，所以我们Rectangle函数也使用LPCRECT，这样便于使用。</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-44-44.png" alt="images/download/attachments/17301744/image2021-6-28_0-44-44.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLURyYXczZFJlY3Tlh73mlbDlrp7njrAzROeri-S9k-aEnw">
        <h3 class="heading "><span>Draw3dRect&#20989;&#25968;&#23454;&#29616;3D&#31435;&#20307;&#24863;</span></h3>
<p   
>为了让程序看起来更加丰满，我们可以使用Draw3dRect函数实现3D立体感，其第一个参数与<strong class=" ">Ellipse</strong>函数、<strong class=" ">Rectangle</strong>函数一样，可以为四个int类型的参数，也可以是一个<strong class=" ">LPCRECT</strong>，另外两个参数就是3D实体图形左边与上边的颜色和右边和下边的颜色。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_0-45-58.png" alt="images/download/attachments/17301744/image2021-6-28_0-45-58.png" width="600"  />
    </p>
<p   
>如下代码，我们创建一个200x200的矩形，其左边与上边的颜色为绿色，右边和下边的颜色为红色：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rect(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">200</code><code class="plain">,</code><code class="value">200</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CBrush brush;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.Rectangle(&amp;rect);</code></div>
<div class="line"><code class="plain">    brush.CreateStockObject(LTGRAY_BRUSH); </code><code class="comments">// 初始化画刷，LTGRAY_BRUSH -&gt; 亮灰色画刷</code></div>
<div class="line"><code class="plain">    dc.FillRect(&amp;rect, &amp;brush); </code><code class="comments">// 由于该函数第一个参数为LPCRECT，所以我们Rectangle函数也使用LPCRECT，这样便于使用。</code></div>
<div class="line"><code class="plain">    dc.Draw3dRect(&amp;rect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">0</code><code class="plain">), RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">255</code><code class="plain">));</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_1-6-48.png" alt="images/download/attachments/17301744/image2021-6-28_1-6-48.png" width="600"  />
    </p>
<p   
><strong class=" ">注意：</strong>这里的rect对象名，如果我们直接写对象名称不要那个取地址符也是可以的，因为这样实际上就是拷贝一份过去，而如果传入指针实际上就是将当前对象的地址传过去，两者唯一区别就是前者拷贝过去的对象被修改了不会影响本身，但后者则会影响本身，前者需要重新开辟一块空间，其实也是一种资源浪费，我们这些代码理论上也不会修改我们的坐标点，所以我们还是直接使用取地址符传指针进去较好。</p>
    <div class="section section-4" id="src-17301744_safe-id-TUZDLeWunueOsOaMiemSruWKn-iDvQ">
        <h4 class="heading "><span>&#23454;&#29616;&#25353;&#38062;&#21151;&#33021;</span></h4>
<p   
>如下代码，我们可以借助3D立体化让我们的矩形看起来像一个按钮，然后在左键按下事件中添加对应的弹框，实现一个简单的按钮单击触发功能：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rect(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">100</code><code class="plain">,</code><code class="value">50</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CBrush brush;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.Rectangle(&amp;rect);</code></div>
<div class="line"><code class="plain">    brush.CreateStockObject(LTGRAY_BRUSH); </code><code class="comments">// 初始化画刷，LTGRAY_BRUSH -&gt; 亮灰色画刷</code></div>
<div class="line"><code class="plain">    dc.FillRect(&amp;rect, &amp;brush); </code><code class="comments">// 由于该函数第一个参数为LPCRECT，所以我们Rectangle函数也使用LPCRECT，这样便于使用。</code></div>
<div class="line"><code class="plain">    rect.top++;</code></div>
<div class="line"><code class="plain">    rect.left++;</code></div>
<div class="line"><code class="plain">    dc.Draw3dRect(&amp;rect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">128</code><code class="plain">,</code><code class="value">128</code><code class="plain">,</code><code class="value">128</code><code class="plain">)); </code><code class="comments">// 3D</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    dc.SetBkMode(TRANSPARENT); </code><code class="comments">// SetBkMode函数来设置DrawText函数的输出方式</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        显示设备共有两种输出方式：OPAQUE和TRANSPARENT。</code></div>
<div class="line"><code class="comments">        OPAQUE是使用当前背景的画刷的颜色输出显示文字的背景</code></div>
<div class="line"><code class="comments">        TRANSPARENT是使用透明的输出，也就是文字的背景是不改变的。</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    dc.DrawText(</code><code class="string">"Click"</code><code class="plain">, &amp;rect, DT_CENTER|DT_VCENTER|DT_SINGLELINE); </code><code class="comments">// 该函数在指定的矩形里写入格式化的正文</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        DT_CENTER：文本水平居中显示</code></div>
<div class="line"><code class="comments">        DT_VCENTER：文本垂直居中显示</code></div>
<div class="line"><code class="comments">        DT_SINGLELINE：文本单行显示</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonDown(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断point的点是否在当前CRect的范围中</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (rect.PtInRect(point)) {</code></div>
<div class="line"><code class="plain">        dc.Draw3dRect(&amp;rect, RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">), RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">)); </code><code class="comments">// 增加动画效果</code></div>
<div class="line"><code class="plain">        AfxMessageBox(</code><code class="string">"Click"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        dc.Draw3dRect(&amp;rect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">128</code><code class="plain">,</code><code class="value">128</code><code class="plain">,</code><code class="value">128</code><code class="plain">)); </code><code class="comments">// 复原</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_1-26-1.png" alt="images/download/attachments/17301744/image2021-6-28_1-26-1.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqOeUu-WIt-OAgeeUu-eslOOAgeWtl-S9kw">
        <h2 class="heading "><span>&#20351;&#29992;&#30011;&#21047;&#12289;&#30011;&#31508;&#12289;&#23383;&#20307;</span></h2>
<p   
>在GDI中我们有画刷（CBrush类）、画笔（CPen类）、字体（CFont类），如上案例中我们使用了画刷来填充矩形，那么假设要改别一个矩形四边的线条，我们可以通过画笔来完成。</p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeeUu-eslO-8iOeUu-WIt-WQjOeQhuWPr-W-l--8iQ">
        <h3 class="heading "><span>&#30011;&#31508;&#65288;&#30011;&#21047;&#21516;&#29702;&#21487;&#24471;&#65289;</span></h3>
<p   
>画笔使用<strong class=" ">CPen</strong>类创建，我们可以直接通过构造函数去创建一个画笔：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CPen pen(PS_DASH, </code><code class="value">1</code><code class="plain">, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">));</code></div>
</div>
    </div>
<p   
>其三个参数分别是画笔样式：虚线、线条宽度：1（<strong class=" ">注意使用非实线只能使用1</strong>）、画笔颜色：红色。</p>
<p   
>除了构造函数外我们还可以使用成员方法<strong class=" ">CreatePen</strong>来创建画笔：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CPen pen;</code></div>
<div class="line"><code class="plain">pen.CreatePen(PS_DASH, </code><code class="value">1</code><code class="plain">, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">))</code></div>
</div>
    </div>
<p   
>创建画笔并不代表画笔被我们所使用了，要使用的话则需要<strong class=" ">SelectObject</strong>来使用：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_1-43-9.png" alt="images/download/attachments/17301744/image2021-6-28_1-43-9.png" width="600"  />
    </p>
<p   
>当我们使用该函数来设置了画笔，我们还需要保存一个原来的画笔，在使用完之后恢复原画笔（<strong class=" ">只要你使用了SelectObject方法就一定要保存原内容最后还原</strong>），这是因为：</p>
<ol class=" "><li class=" "><p   
>窗口（视图）类，在任何地方（包括基础代码）都能获取DC并调整画笔，你无法确认上次使用的画笔是否被更换了</p>
</li><li class=" "><p   
>通常画笔都是使用临时变量<strong class=" ">CPen</strong>，这样在函数执行后，这个画笔会失效，如果不将OldPen放回去，会造成内存泄露（应该释放但因DC绑定而无法释放，下次放弃使用的时候又无法判断是否应该释放）</p>
</li></ol><p   
>因为<strong class=" ">SelectObject</strong>方法返回的结果是未被替代前的<strong class=" ">CPen</strong>对象（指针），所以我们可以这样写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="false" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rect(</code><code class="value">10</code><code class="plain">,</code><code class="value">10</code><code class="plain">,</code><code class="value">100</code><code class="plain">,</code><code class="value">50</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    CPen pen;</code></div>
<div class="line"><code class="plain">    CPen* oldPen;</code></div>
<div class="line"><code class="plain">    pen.CreatePen(PS_DASH, </code><code class="value">1</code><code class="plain">, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">)); </code><code class="comments">// 创建画笔，画笔样式为虚线，线条宽度(使用非实线只能使用1)，颜色为红色</code></div>
<div class="line"><code class="plain">    oldPen = dc.SelectObject(&amp;pen);</code></div>
<div class="line"><code class="plain">    dc.Rectangle(&amp;rect);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// end</code></div>
<div class="line"><code class="plain">    dc.SelectObject(oldPen);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    <div class="section section-4" id="src-17301744_safe-id-TUZDLVRleHRPdXTlh73mlbDovpPlh7rmlofmnKw">
        <h4 class="heading "><span>TextOut&#20989;&#25968;&#36755;&#20986;&#25991;&#26412;</span></h4>
<p   
>我们之前使用<strong class=" ">DrawText</strong>函数输出文本，其参数较多，我们可以通过<strong class=" ">TextOut</strong>函数来省略一些参数，但同时我们还需要使用<strong class=" ">SetTextAlign</strong>函数来设置文本对齐：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">dc.SetTextAlign(TA_CENTER); </code><code class="comments">// 设置文本对齐</code></div>
<div class="line"><code class="plain">dc.TextOut(rect.left, rect.top, </code><code class="string">"Test"</code><code class="plain">); </code><code class="comments">// x, y, 文字</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_2-1-42.png" alt="images/download/attachments/17301744/image2021-6-28_2-1-42.png" width="600"  />
    </p>
<p   
><strong class=" ">个人见解</strong>：说实话，这样的效果有些差强人意，还需要我们手动去调整，才能在矩形中对齐，所以如果你想在矩形中居中对齐建议使用<strong class=" ">DrawText</strong>函数。</p>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWtl-S9kw">
        <h2 class="heading "><span>&#23383;&#20307;</span></h2>
<p   
>字体使用<strong class=" ">CFont</strong>类创建，我们可以通过其成员方法<strong class=" ">CreatePointFont</strong>去创建一个字体样式：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CFont font;</code></div>
<div class="line"><code class="plain">font.CreatePointFont(</code><code class="value">2000</code><code class="plain">, </code><code class="string">"Tahoma"</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>其参数分别为字体大小、字体名称。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-28_2-16-29.png" alt="images/download/attachments/17301744/image2021-6-28_2-16-29.png" width="600"  />
    </p>
<p   
>如果你想字体样式更花哨一点，例如支持斜体之类的，我们可以使用成员方法<strong class=" ">CreatePointFontIndirect</strong>，其参数是一个LOGFONT结构体：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CFont font;</code></div>
<div class="line"><code class="plain">LOGFONT lf;</code></div>
<div class="line"><code class="plain">memset(&amp;lf, </code><code class="value">0</code><code class="plain">, sizeof(lf)); </code><code class="comments">// 初始化，用0填充</code></div>
<div class="line"><code class="plain">lf.lfWeight = </code><code class="value">120</code><code class="plain">; </code><code class="comments">// 字体大小</code></div>
<div class="line"><code class="plain">lf.lfHeight = FW_BOLD; </code><code class="comments">// 字体宽度</code></div>
<div class="line"><code class="plain">lf.lfItalic = TRUE; </code><code class="comments">// 字体是否倾斜</code></div>
<div class="line"><code class="plain">strcpy(lf.lfFaceName, </code><code class="string">"Tahoma"</code><code class="plain">); </code><code class="comments">// 字体名称</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">font.CreatePointFontIndirect(&amp;lf);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeivvuWQjuS9nOS4mi4z">
        <h2 class="heading "><span>&#35838;&#21518;&#20316;&#19994;</span></h2>
<p   
>画一个Excel表格的UI，有一说一这个课后作业的目标还是很有挑战性的，了解了MFC的一些细节。</p>
<p   
>代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnPaint() {</code></div>
<div class="line"><code class="plain">    CPaintDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CBrush brush(RGB(</code><code class="value">128</code><code class="plain">, </code><code class="value">128</code><code class="plain">, </code><code class="value">128</code><code class="plain">));</code></div>
<div class="line"><code class="plain">    CBrush brushA(RGB(</code><code class="value">245</code><code class="plain">, </code><code class="value">245</code><code class="plain">, </code><code class="value">245</code><code class="plain">));</code></div>
<div class="line"><code class="plain">    CBrush* oldBrush = dc.SelectObject(&amp;brush);</code></div>
<div class="line"><code class="plain">    CRect clientRect;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    GetClientRect(&amp;clientRect);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> tabWidth = </code><code class="value">100</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> tabHeight = </code><code class="value">20</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    CRect tableRect(</code><code class="value">25</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">125</code><code class="plain">,</code><code class="value">20</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    CRect rightTableRect(</code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">25</code><code class="plain">, </code><code class="value">20</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> test[] = </code><code class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置字体</code></div>
<div class="line"><code class="plain">    dc.SetBkMode(TRANSPARENT);</code></div>
<div class="line"><code class="plain">    dc.SetTextAlign(TA_CENTER);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置表坐上角</code></div>
<div class="line"><code class="plain">    dc.Rectangle(&amp;rightTableRect);</code></div>
<div class="line"><code class="plain">    dc.Draw3dRect(&amp;rightTableRect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">));</code></div>
<div class="line"><code class="plain">    dc.TextOut(rightTableRect.right/</code><code class="value">2</code><code class="plain">, </code><code class="value">1</code><code class="plain">, </code><code class="string">"\\"</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 列、行循环创建</code></div>
<div class="line"><code class="plain">        tableRect.top = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        tableRect.bottom = </code><code class="value">20</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        dc.Rectangle(&amp;tableRect);</code></div>
<div class="line"><code class="plain">        dc.Draw3dRect(&amp;tableRect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">));</code></div>
<div class="line"><code class="plain">        dc.SelectObject(&amp;brush);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> x = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            dc.Rectangle(&amp;tableRect);</code></div>
<div class="line"><code class="plain">            dc.Draw3dRect(&amp;tableRect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">));</code></div>
<div class="line"><code class="plain">            tableRect.top += tabHeight;</code></div>
<div class="line"><code class="plain">            tableRect.bottom += tabHeight;</code></div>
<div class="line"><code class="plain">            dc.SelectObject(&amp;brushA);</code></div>
<div class="line"><code class="plain">            x++;</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">while</code><code class="plain"> (clientRect.bottom / x / tabHeight != </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        tableRect.left += tabWidth;</code></div>
<div class="line"><code class="plain">        tableRect.right += tabWidth;</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 写入表头字母</code></div>
<div class="line"><code class="plain">        dc.TextOut(</code><code class="value">75</code><code class="plain">+(i*tabWidth), </code><code class="value">1</code><code class="plain">, test[i]);</code></div>
<div class="line"><code class="plain">        i++;</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (clientRect.right / i / tabWidth != </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 行号</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> b = </code><code class="value">1</code><code class="plain">; clientRect.right / b / tabHeight != </code><code class="value">0</code><code class="plain">; b++) {</code></div>
<div class="line"><code class="plain">        rightTableRect.top += tabHeight;</code></div>
<div class="line"><code class="plain">        rightTableRect.bottom += </code><code class="value">25</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        dc.Rectangle(&amp;rightTableRect);</code></div>
<div class="line"><code class="plain">        dc.Draw3dRect(&amp;rightTableRect, RGB(</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">,</code><code class="value">255</code><code class="plain">), RGB(</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">,</code><code class="value">0</code><code class="plain">));</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">char</code><code class="plain"> c[</code><code class="value">2</code><code class="plain">];</code></div>
<div class="line"><code class="plain">        sprintf(c, </code><code class="string">"%d"</code><code class="plain">, b);</code></div>
<div class="line"><code class="plain">        dc.TextOut(</code><code class="value">12</code><code class="plain">, </code><code class="value">1</code><code class="plain">+(b*tabHeight), c);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    dc.SelectObject(oldBrush);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_13-17-28.png" alt="images/download/attachments/17301744/image2021-6-29_13-17-28.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLem8oOagh-a2iOaBrw">
        <h1 class="heading "><span>&#40736;&#26631;&#28040;&#24687;</span></h1>
<p   
>Window有20多种不同的消息用来报告与鼠标有关的输入事件，这些消息分为窗口客户区消息和非客户区消息，通常我们只需要关心客户区消息。</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS45">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>理解客户区鼠标消息和非客户区鼠标消息</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWuouaIt-WMuum8oOagh-a2iOaBrw">
        <h2 class="heading "><span>&#23458;&#25143;&#21306;&#40736;&#26631;&#28040;&#24687;</span></h2>
<p   
>如下表格中就是一些鼠标消息的名称和其对应含义：</p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>名称</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>含义</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_LBUTTONDOWN</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标左键按下</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_LBUTTONUP</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标左键抬起</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_LBUTTONDBLCLK</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标左键双击</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_MBUTTONDOWN</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标中键被按下</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_MBUTTONUP</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标中键抬起</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_MBUTTONDBLCLK</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标中键双击</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_RBUTTONDOWN</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>鼠标右键按下</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&hellip;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>..</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>WM_MOUSEMOVE</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>在窗口客户区移动了光标</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
<p   
>我们之前就已经使用过鼠标左键按下这个消息了，只要了解鼠标就知道对应的消息是什么了。</p>
<p   
>鼠标消息也有对应的消息处理函数，这种函数都是固定的名称和参数，其中参数为：<u class=" "><strong class=" ">UINT nFlags, CPoint point</strong></u>，第二个参数我们已经使用过了，其就是一个设备坐标（视口），第一个参数表示控制键状态，其可以表示：ctrl键按下、鼠标左键按下、鼠标中键按下、鼠标右键按下、shift键按下。</p>
<p   
>如下图中有其对应解释和相关的宏：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_13-52-5.png" alt="images/download/attachments/17301744/image2021-6-29_13-52-5.png" width="400"  />
    </p>
<p   
>假设现在我们想要在鼠标左键按下的消息处理函数中判断当shift键按下则触发弹框，可以这样写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonDown(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (nFlags &amp; MK_SHIFT) {</code></div>
<div class="line"><code class="plain">        AfxMessageBox(</code><code class="string">"123"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLemdnuWuouaIt-WMuum8oOagh-a2iOaBrw">
        <h2 class="heading "><span>&#38750;&#23458;&#25143;&#21306;&#40736;&#26631;&#28040;&#24687;</span></h2>
<p   
>我们了解了客户区消息之后，就需要了解一下非客户区，非客户区就是如下图所示红框之外的区域就是非客户区，我们这章所使用的实际上是基于窗口的非客户区，也就是紫框和红框中间那一部分：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-27_0-27-19.png" alt="images/download/attachments/17301744/image2021-6-27_0-27-19.png" width="600"  />
    </p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLemdnuWuouaIt-WMuum8oOagh-a2iOaBr-WkhOeQhg">
        <h3 class="heading "><span>&#38750;&#23458;&#25143;&#21306;&#40736;&#26631;&#28040;&#24687;&#22788;&#29702;</span></h3>
<p   
>非客户区鼠标消息处理其实跟我们之前使用的鼠标消息处理没有本质区别，唯一的就是名字里头多了NC这两个字母（<strong class=" ">个人理解</strong>为非客户区英文<strong class=" ">Not Client Area</strong>的首字母缩写），例如非客户区的鼠标左键相关的宏和函数：</p>
<p   
><img  class="confluence-embedded-image confluence-thumbnail"  src="images/download/thumbnails/17301744/image2021-6-29_14-18-24.png" alt="images/download/thumbnails/17301744/image2021-6-29_14-18-24.png" width="200"  />
 <img  class="confluence-embedded-image confluence-thumbnail"  src="images/download/thumbnails/17301744/image2021-6-29_14-18-38.png" alt="images/download/thumbnails/17301744/image2021-6-29_14-18-38.png" width="150"  />
</p>
<p   
>实际使用也没有本质差别：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_14-23-28.png" alt="images/download/attachments/17301744/image2021-6-29_14-23-28.png" width="600"  />
    </p>
<p   
>但需要注意的是，这里我们需要加入一个父类的<strong class=" ">CFrameWnd::OnNcLButtonDown</strong>，这是因为如果不加入的话，当前消息处理函数就没法处理放大、缩小、关闭这些按钮，而会一直触发弹框：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_14-28-38.png" alt="images/download/attachments/17301744/image2021-6-29_14-28-38.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_15-38-17.png" alt="images/download/attachments/17301744/image2021-6-29_15-38-17.png" width="600"  />
    </p>
<p   
>非客户去鼠标消息处理函数的第一个参数可以判断很多东西，例如窗口缩小、放大、关闭按钮之类的都是可以的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_15-48-19.png" alt="images/download/attachments/17301744/image2021-6-29_15-48-19.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLVdNX05DSElUVEVTVOa2iOaBrw">
        <h3 class="heading "><span>WM_NCHITTEST&#28040;&#24687;</span></h3>
<p   
>通过上文图片中的代码注释可以发现这些宏是属于<strong class=" ">WM_NCHITTEST</strong>和<strong class=" ">MOUSEHOOKSTRUCT</strong>的，第二个我们不用管，来看下第一个，从命名上就可以看的出来其是一个消息，其代表的具体消息为：光标移动到窗体或鼠标按下、抬起。</p>
<p   
>这个消息优先于所有其他的客户区域和非客户区域鼠标消息，Windows应用程序通常把消息传送给<strong class=" ">DefWindowProc</strong>函数，然后Windows用<strong class=" ">WM_NCHITTEST</strong>消息产生与鼠标位置相关的所有其他鼠标消息，通俗的讲就是<strong class=" ">从消息产生消息</strong>。</p>
<p   
>我们可以来实际使用一下这个消息，首先在消息映射表中加入该消息的映射，其次在类中声明对应消息处理函数，而后实现该函数即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-29_17-7-3.png" alt="images/download/attachments/17301744/image2021-6-29_17-7-3.png" width="600"  />
    </p>
<p   
>我们可以将客户区和非客户区做一个转换以此实现在客户区也可以拖动窗口：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">UINT CMainWindow::OnNcHitTest(CPoint point) {</code></div>
<div class="line"><code class="plain">    UINT ret;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 通过父类获取消息</code></div>
<div class="line"><code class="plain">    ret = CFrameWnd::OnNcHitTest(point);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断消息是否是客户区，是的话则将该消息转为非客户区消息</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (ret &amp; HTCLIENT) {</code></div>
<div class="line"><code class="plain">        ret = HTCAPTION;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> ret;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLem8oOagh-eUu-e6vw">
        <h2 class="heading "><span>&#40736;&#26631;&#30011;&#32447;</span></h2>
<p   
>我们可以先实现一个鼠标画线的需求，要求鼠标左键按下为起点直到鼠标抬起为终点，两点一条直线：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CPoint testPoint; </code><code class="comments">// 定义一个全局的CPoint，用于存放鼠标左键按下时的坐标</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 鼠标左键按下的消息处理函数，给全局的CPoint赋值</code></div>
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonDown(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    testPoint = point;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 鼠标左键按下抬起的消息处理函数，MoveTo移动起始位置到testPoint的坐标，而后LineTo画线为鼠标左键抬起的位置</code></div>
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonUp(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    CClientDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    dc.MoveTo(testPoint.x, testPoint.y);</code></div>
<div class="line"><code class="plain">    dc.LineTo(point.x, point.y);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>正常画是没有问题的，但是我们鼠标按下之后在非客户区抬起，这样就不会有一条直线出现：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_15-1-20.png" alt="images/download/attachments/17301744/image2021-6-30_15-1-20.png" width="400"  />
    </p>
<p   
>因为我们光标已经离开客户区域了，所以说它接收不到鼠标左键抬起的信息，我们可以借助函数<strong class=" ">SetCapture</strong>，该函数的意思就是在属于当前线程的指定窗口里设置鼠标捕获，一旦窗口捕获了鼠标，所有鼠标输入都针对该窗口，无论光标是否在客户区内；同样，对应的一个函数就是<strong class=" ">ReleaseCapture</strong>函数，当你不在需要继续获得鼠标消息就要应该调用它来释放，但在这里你要通过<strong class=" ">GetCapture</strong>来获取当前捕获鼠标信息的窗口的句柄来判断是否是当前窗口的句柄，如果是则释放。</p>
<p   
>如下为改写后的代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CPoint testPoint;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonDown(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    SetCapture();</code></div>
<div class="line"><code class="plain">    testPoint = point;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> CMainWindow::OnLButtonUp(UINT nFlags, CPoint point) {</code></div>
<div class="line"><code class="plain">    CClientDC dc(</code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    dc.MoveTo(testPoint.x, testPoint.y);</code></div>
<div class="line"><code class="plain">    dc.LineTo(point.x, point.y);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (GetCapture() == </code><code class="keyword">this</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        ReleaseCapture();</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_15-11-9.png" alt="images/download/attachments/17301744/image2021-6-30_15-11-9.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLemUruebmOa2iOaBrw">
        <h1 class="heading "><span>&#38190;&#30424;&#28040;&#24687;</span></h1>
<p   
>Windows通过给拥有输入焦点的窗口发送<strong class=" ">WM_KEYDOWN</strong>和<strong class=" ">WM_KEYUP</strong>消息来报靠按键被按下还是释放事件；这些消息被称为按键消息。除了ALT和F10以外的所有键都产生按下和抬起消息，ALT和F10是系统键，对Windows有特殊意义。</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xMA">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>Windows的键盘消息和处理</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLemUruebmOa2iOaBr-WkhOeQhuWHveaVsA">
        <h2 class="heading "><span>&#38190;&#30424;&#28040;&#24687;&#22788;&#29702;&#20989;&#25968;</span></h2>
<p   
>键盘消息处理函数的格式一般为如下所示：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">afx_msg </code><code class="keyword">void</code><code class="plain"> On消息名(UINT nChar, UINT nRepCnt, UINT nFlags);</code></div>
</div>
    </div>
<p   
>其有三个参数，第一个参数表示虚拟键码（就是你键盘某个键对应的代码），第二个参数表示重复数，第三个参数表示通过取位的方式来列出零个和多个标志位。</p>
<p   
>第三个参数表示标志位，其位数也有相应含义：</p>
    <div  class="tablewrap">
        <table class="relative-table wrapped confluenceTable">
                    <colgroup>
                                    <col  width="30.9278%"/>
                                    <col  width="69.0722%"/>
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>位数</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>含义</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0-7</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>OEM扫描码</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>8</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>扩展键标志</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>9-12</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>保留</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>14</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>先前状态，先前键被按下为1，抬起为0</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>15</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>过渡状态，被按下为0，释放为1</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
<p   
>前两个参数比较好理解，我们可以写代码来看一下第三个参数，这里我们用到的是<strong class=" ">WM_KEYDOWN</strong>消息：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-44-13.png" alt="images/download/attachments/17301744/image2021-6-30_16-44-13.png" width="600"  />
    </p>
<p   
>首先判断按下的键是否是CTRL键，其次左移14位来获取这个值，我们知道第14位获得的是先前状态，先前键被按下为1，抬起为0，我们按一下CTRL键然后抬起看看结果：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-46-37.png" alt="images/download/attachments/17301744/image2021-6-30_16-46-37.png" width="400"  />
    </p>
<p   
>结果为0，那我们一直按着CTRL键不抬起在看一下，结果就为1了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-47-23.png" alt="images/download/attachments/17301744/image2021-6-30_16-47-23.png" width="400"  />
    </p>
<p   
>所以我们可以根据这个来判断该键有没有松开。</p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLVdNX0NIQVLmtojmga8">
        <h2 class="heading "><span>WM_CHAR&#28040;&#24687;</span></h2>
<p   
>之前我们可以了解了键盘消息处理函数的几个参数，第一个参数可以用来获取键盘按下的键，并且使用<strong class=" ">WM_KEYDOWN</strong>消息来使用了，但是这有一个问题，就是通过<strong class=" ">WM_KEYDOWN</strong>消息对应处理函数获取的键只是针对字符键的永远都是大写的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-54-5.png" alt="images/download/attachments/17301744/image2021-6-30_16-54-5.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-53-52.png" alt="images/download/attachments/17301744/image2021-6-30_16-53-52.png" width="400"  />
    </p>
<p   
>所以如果对大小写很严谨的话可以使用<strong class=" ">WM_CHAR</strong>消息以及其对应消息处理函数来获取，换而言之，<strong class=" ">WM_CHAR</strong>消息就是专门来处理这种字符键的。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_16-59-41.png" alt="images/download/attachments/17301744/image2021-6-30_16-59-41.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLeWvueivneahhg">
        <h1 class="heading "><span>&#23545;&#35805;&#26694;</span></h1>
<p   
>对话框实际上就是一个窗口，它不仅可以接收消息，而且还可以被移动、关闭和在它的客户区域进行绘图；我们可以把它看成是一个大容器，在它上面能够放置各种各样的控件，使程序支持用户输入的手段更丰富。</p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xMQ">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>对向导生成的对话框工程进行结构分析</p>
</li><li class=" "><p   
>了解GDI的画笔、画刷以及字体</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeWQkeWvvOeUn-aIkOeahOWvueivneahhuW3peeoiw">
        <h2 class="heading "><span>&#21521;&#23548;&#29983;&#25104;&#30340;&#23545;&#35805;&#26694;&#24037;&#31243;</span></h2>
<p   
>按如下图所示创建对话框工程即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_17-56-43.png" alt="images/download/attachments/17301744/image2021-6-30_17-56-43.png" width="600"  />
    </p>
<p   
>需要注意的是我们生成了工程，其有一个头文件<strong class=" ">stdafx.h</strong>，该文件一定要放在第一行去使用，因为在使用该文件之前的，VC6编译器是不会将其去参与编译的，而是选择忽视掉：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_18-2-55.png" alt="images/download/attachments/17301744/image2021-6-30_18-2-55.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-6-30_18-4-26.png" alt="images/download/attachments/17301744/image2021-6-30_18-4-26.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLee7k-aehOWIhuaekA">
        <h2 class="heading "><span>&#32467;&#26500;&#20998;&#26512;</span></h2>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeWunuS-i-WMluWvueixoQ">
        <h3 class="heading "><span>&#23454;&#20363;&#21270;&#23545;&#35937;</span></h3>
<p   
>首先我们来看下<strong class=" ">HelloDialog.cpp</strong>文件，在这个文件中我们可以看见<strong class=" ">theApp</strong>这么一个熟悉的名字，通过该名字我们就可以知道这个文件实际上就是用来实例化的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-20-9.png" alt="images/download/attachments/17301744/image2021-7-1_18-20-9.png" width="600"  />
    </p>
<p   
>该代码和以前我们写的工程是没有区别的，它的<strong class=" ">CHelloDialogApp::InitInstance</strong>函数就是初始化一个对话框，同样我们可以根据MFC层次结构图看见其与<strong class=" ">CFrameWnd</strong>通用继承于CWnd，换而言之其实两者没有什么区别，无非就是表现出来的形式不一样罢了。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-25-45.png" alt="images/download/attachments/17301744/image2021-7-1_18-25-45.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeS4u-eql-WPow">
        <h3 class="heading "><span>&#20027;&#31383;&#21475;</span></h3>
<p   
>主窗口文件是<strong class=" ">HelloDialogDlg.cpp</strong>，在里面我们可以看见熟悉的消息映射以及相关的消息处理函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-29-5.png" alt="images/download/attachments/17301744/image2021-7-1_18-29-5.png" width="600"  />
    </p>
<p   
>接着向下看就会发现一个注释写着在这里添加额外的初始化代码，也就是<strong class=" ">CHelloDialogDlg::OnInitDialog</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-30-24.png" alt="images/download/attachments/17301744/image2021-7-1_18-30-24.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLei1hOa6kOiEmuacrA">
        <h3 class="heading "><span>&#36164;&#28304;&#33050;&#26412;</span></h3>
<p   
>其实在创建完项目的时候就应该感觉到有一个文件非常的显眼，那就是<strong class=" ">HelloDialog.rc</strong>，这个文件从没见过，其表示的是资源脚本文件，有了这个文件我们就可以添加图标、版本信息等等。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-32-48.png" alt="images/download/attachments/17301744/image2021-7-1_18-32-48.png" width="600"  />
    </p>
<p   
>在VC6中没法直接打开这个RC文件，但是我们可以在外部使用记事本去打开：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-36-45.png" alt="images/download/attachments/17301744/image2021-7-1_18-36-45.png" width="600"  />
    </p>
<p   
>在这里我们就可以很清晰的看见使用的字体，窗口名字之类的信息，当然这些信息我们也可以通过VC6直接去看：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-38-25.png" alt="images/download/attachments/17301744/image2021-7-1_18-38-25.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLURvRGF0YUV4Y2hhbmdl5Ye95pWw">
        <h3 class="heading "><span>DoDataExchange&#20989;&#25968;</span></h3>
<p   
>在主窗口文件中存在一个函数，其名为<strong class=" ">CHelloDialogDlg::DoDataExchange</strong>，这是用来实现动态绑定的，我们可以来举例说明下动态绑定的意思。</p>
<p   
>首先在VC6中去绘画两个控件：编辑框和按钮（从旁边的Controls拖过去就行），然后我需要单击按钮就可以改变编辑框的内容：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-45-5.png" alt="images/download/attachments/17301744/image2021-7-1_18-45-5.png" width="400"  />
    </p>
<p   
>双击新建的这个按钮，随便取你想要的按钮事件处理函数名称然后写对应的代码，如下代码中使用了<strong class=" ">GetDlgItem</strong>函数，该函数是根据控件ID来获取控件的句柄，而后再用其内部方法<strong class=" ">SetWindowText</strong>来改写编辑框的内容，控件ID我们可以点<strong class=" ">右键选择控件&rarr;Properties</strong>来获取：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-49-54.png" alt="images/download/attachments/17301744/image2021-7-1_18-49-54.png" width="600"  />
    </p>
<p   
>除此之外我们设置编辑框的内容，我们还可以用别的方法也就是动态绑定的思路来修改。</p>
<p   
>首先点<strong class=" ">右键选择控件&rarr;ClassWizard</strong>，按下图操作即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_19-2-36.png" alt="images/download/attachments/17301744/image2021-7-1_19-2-36.png" width="400"  />
    </p>
<p   
>而后就可以直接在代码中使用该变量即可用<strong class=" ">SetWindowText</strong>函数来修改编辑框内容：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_19-3-30.png" alt="images/download/attachments/17301744/image2021-7-1_19-3-30.png" width="600"  />
    </p>
<p   
>然后我们回到<strong class=" ">DoDataExchange</strong>函数，代码中多了一个<strong class=" ">DDX_Control</strong>函数，这是这是因为我们刚刚定义的时候<strong class=" ">Category</strong>选择的就是<strong class=" ">Control</strong>类型，其作用就是将我们的<strong class=" ">IDC_EDIT1</strong>控件和<strong class=" ">m_edit1</strong>变量关联起来，这时候我们操作<strong class=" ">m_edit1</strong>就会改变<strong class=" ">IDC_EDIT1</strong>这个控件。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_19-4-43.png" alt="images/download/attachments/17301744/image2021-7-1_19-4-43.png" width="600"  />
    </p>
<p   
>除了可以在定义的时候<strong class=" ">Category</strong>选择为<strong class=" ">Control</strong>类型，我们还可以直接让其成为一个字符串<strong class=" ">CString</strong>类型：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_19-9-59.png" alt="images/download/attachments/17301744/image2021-7-1_19-9-59.png" width="600"  />
    </p>
<p   
>这样我们在代码中就可以直接去赋值修改编辑框内容，但需注意我们在代码之后要加上<strong class=" ">UpdateData</strong>函数才可以生效：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_19-11-12.png" alt="images/download/attachments/17301744/image2021-7-1_19-11-12.png" width="600"  />
    </p>
<p   
><strong class=" ">UpdateData</strong>函数的参数值为布尔类型，也就是非<strong class=" ">TRUE</strong>即<strong class=" ">FALSE</strong>，为什么这里是<strong class=" ">FALSE</strong>呢，这是因为这个值为<strong class=" ">FALSE</strong>则表示修改编辑框的内容，而值为<strong class=" ">TRUE</strong>则表示将编辑框的内容给到变量。</p>
<p   
>可以通过通过代码来证明这一点，这个值都是由我们之前创建的<strong class=" ">m_edit1</strong>变量来传递的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_20-37-16.png" alt="images/download/attachments/17301744/image2021-7-1_20-37-16.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLURvTW9kYWzlh73mlbA">
        <h3 class="heading "><span>DoModal&#20989;&#25968;</span></h3>
<p   
>回到实例化对象的相关CPP文件，来看一下<strong class=" ">DoModal</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_18-20-9.png" alt="images/download/attachments/17301744/image2021-7-1_18-20-9.png" width="600"  />
    </p>
<p   
>该函数就是一个模态对话框，该函数就实现了一个对话框的初始化、呼出对话框以及一个消息循环。</p>
<p   
><strong class=" ">模态对话框的意思</strong>：是指在用户想要对对话框以外的应用程序进行操作时，必须首先对该对话框进行响应，如单击【确定】或【取消】按钮之后，将该对话框关闭。</p>
<p   
>其会返回一个值，也就是这里的确定（IDOK）和取消（IDCANCEL），我们就可以用它来在我们程序出现的时候做一个验证来返回用户确定或取消的结果。</p>
<p   
>模态对话框有一个特点，当我们调用了一个新的对话框之后，我们是没法再去点击第一个对话框的，只能等新的对话框结束才可以。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_21-4-7.png" alt="images/download/attachments/17301744/image2021-7-1_21-4-7.png" width="600"  />
    </p>
<p   
>如果你想创建一个非模态对话框可以使用我们之前写的CFrameWnd的方式，先执行Create函数然后ShowWindow，但是这样是不行的，因为我们这样创建的是一个局部变量，虽然会创建这个窗口但是函数执行完，<strong class=" ">栈</strong>中就没有这个了：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CHelloDialogDlg::OnButton1() </code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    CDialog1 cDlg;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    cDlg.Create(IDD_DIALOG1, </code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    cDlg.ShowWindow(SW_SHOW);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>所以我们需要在堆中创建，使用new关键词就可以了：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CHelloDialogDlg::OnButton1() </code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    CDialog1* cDlg;</code></div>
<div class="line"><code class="plain">    cDlg = </code><code class="keyword">new</code><code class="plain"> CDialog1;</code></div>
<div class="line"><code class="plain">    cDlg-&gt;Create(IDD_DIALOG1, </code><code class="keyword">this</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    cDlg-&gt;ShowWindow(SW_SHOW);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>需要注意，我们是在堆中创建的，当程序执行完并不会自己删除，所以我们要在代码中去写，这里就写在取消按钮的处理函数内：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CDialog1::OnCancel() </code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// TODO: Add extra cleanup here</code></div>
<div class="line"><code class="plain">    delete </code><code class="keyword">this</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    CDialog::OnCancel();</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-aOp-S7tg">
        <h1 class="heading "><span>MFC&#25511;&#20214;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xMg">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>Button、Edit、Static控件的属性和方法</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLVdpbmRvd3PkvKDnu5_mjqfku7Y">
        <h2 class="heading "><span>Windows&#20256;&#32479;&#25511;&#20214;</span></h2>
<p   
>Windows传统控件如下表，其与窗口之间的关系是父子关系，当窗口（父亲）移动，控件（儿子）也会跟随。</p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>控件类型</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>WNDCLASS</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>MFC对应的类</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>按扭</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;BUTTON&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CButton</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>列表</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;ListBox&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CListBox</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>编辑框</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;EDIT&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CEdit</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>组合框</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;COMBOBOX&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CCbomboBox</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>滚动条</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;SCROLLBAR&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CScrollBar</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>静态文本</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>&quot;STATIC&quot;</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CStatic</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUJ1dHRvbuaOp-S7tg">
        <h3 class="heading "><span>Button&#25511;&#20214;</span></h3>
<p   
>手动新建一个按钮控件，基于Create函数即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_22-34-23.png" alt="images/download/attachments/17301744/image2021-7-1_22-34-23.png" width="600"  />
    </p>
<p   
>我们也可以手动给创建的这个按钮添加一个处理函数（还是那一套流程）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_22-43-22.png" alt="images/download/attachments/17301744/image2021-7-1_22-43-22.png" width="600"  />
    </p>
<p   
>我们再来看看修改按钮的名称，跟编辑框是一样的使用SetWindowText函数就可以，但是这里我们的<strong class=" ">m_btn1</strong>没法直接用因为它是创建在局部变量里的，我们可以把它放到类的声明里面。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_22-51-21.png" alt="images/download/attachments/17301744/image2021-7-1_22-51-21.png" width="600"  />
    </p>
<p   
>然后就可以直接使用它了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_22-52-5.png" alt="images/download/attachments/17301744/image2021-7-1_22-52-5.png" width="600"  />
    </p>
<p   
>如果你不想使用这种方式也可以通过<strong class=" ">GetDlgItem</strong>函数来调用。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">GetDlgItem(IDC_BUTTON2)-&gt;SetWindowText(</code><code class="string">"Changed"</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>按钮控件还有很多方法，比如说你可以通过<strong class=" ">EnableWindow</strong>方法让一个按钮变灰（<strong class=" ">TRUE</strong>就是启用按钮，<strong class=" ">FALSE</strong>就是不启用）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_22-54-8.png" alt="images/download/attachments/17301744/image2021-7-1_22-54-8.png" width="600"  />
    </p>
<p   
>除了一些方法还可以设置样式，例如你可以设置按钮控件为一个单选框、复选框，这都可以在<strong class=" ">Create</strong>函数中去设置。</p>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLVN0YXRpY-aOp-S7tg">
        <h3 class="heading "><span>Static&#25511;&#20214;</span></h3>
<p   
>CStatic控件是一个静态文本，其是MFC中最简单的控件，创建方式跟按钮控件是一样的，所以我们这里为了方便直接使用MFC控件栏区创建即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_23-17-22.png" alt="images/download/attachments/17301744/image2021-7-1_23-17-22.png" width="600"  />
    </p>
<p   
>我们可以通过<strong class=" ">Properties</strong>去修改文本内容、样式...</p>
<p   
>默认情况下静态文本控件是没有处理函数的，但是我们可以自己添加：1.取个新ID 2.在样式里选中Notify 3.双击静态文本创建函数</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-1_23-31-41.png" alt="images/download/attachments/17301744/image2021-7-1_23-31-41.png" width="400"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CHelloDialogDlg::OnStatic1() </code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// TODO: Add your control notification handler code here</code></div>
<div class="line"><code class="plain">    GetDlgItem(IDC_STATIC_1)-&gt;SetWindowText(</code><code class="string">"123123123123"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUVkaXTmjqfku7Y">
        <h3 class="heading "><span>Edit&#25511;&#20214;</span></h3>
<p   
>Edit控件就是一个编辑框，与其他控件一样你可以通过<strong class=" ">Properties</strong>去修改样式：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_0-6-6.png" alt="images/download/attachments/17301744/image2021-7-2_0-6-6.png" width="400"  />
    </p>
<p   
>我们可以选中Multiline然后选中Horizontal Scroll、Vertical Scroll，这样就可以让这个编辑框支持多行并且有自动的上下、左右的滚动条：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_0-10-18.png" alt="images/download/attachments/17301744/image2021-7-2_0-10-18.png" width="400"  />
    </p>
<p   
>其他的方法都很常见，但是对编辑框来说，还有当编辑框内容发生改变的处理函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_0-13-55.png" alt="images/download/attachments/17301744/image2021-7-2_0-13-55.png"  height="250" />
    </p>
<p   
>当内容发生变化就会触发：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_0-14-42.png" alt="images/download/attachments/17301744/image2021-7-2_0-14-42.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLee7hOWQiOahhuS4juWIl-ihqOahhuaOp-S7tg">
        <h1 class="heading "><span>&#32452;&#21512;&#26694;&#19982;&#21015;&#34920;&#26694;&#25511;&#20214;</span></h1>
<p   
><strong class=" ">在了解了那么多控件的使用方法之后，我发现其实很多都是如出一辙，所以接下来的笔记记录不会那么详细。</strong></p>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNvbWJvQm945o6n5Lu2">
        <h2 class="heading "><span>ComboBox&#25511;&#20214;</span></h2>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xMw">
        <h3 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h3>
<ol class=" "><li class=" "><p   
>ComboBox控件</p>
</li></ol>    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUNvbWJvQm945o6n5Lu2LjE">
        <h3 class="heading "><span>ComboBox&#25511;&#20214;</span></h3>
<p   
>ComboBox控件也就是组合框，跟其他控件没什么区别，唯一的区别在于它的设置中多了一个Data的标签栏，如下图是使用方法：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_0-47-51.png" alt="images/download/attachments/17301744/image2021-7-2_0-47-51.png" width="400"  />
    </p>
<p   
>其他的属性可以自行去研究，都非常简单。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_1-1-18.png" alt="images/download/attachments/17301744/image2021-7-2_1-1-18.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUxpc3RCb3jmjqfku7Y">
        <h2 class="heading "><span>ListBox&#25511;&#20214;</span></h2>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xNA">
        <h3 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h3>
<ol class=" "><li class=" "><p   
>ListBox 控件</p>
</li><li class=" "><p   
>Menu菜单的添加</p>
</li></ol>    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLUNMaXN0Qm945bi455So6aOO5qC8">
        <h3 class="heading "><span>CListBox&#24120;&#29992;&#39118;&#26684;</span></h3>
<p   
>ListBox控件就是列表框，如下表是其的常用风格：</p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">风格</strong></p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">介绍</strong></p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_EXTENDEDSEL</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>支持多重选择</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_MULTICOLUMN</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>指定一个水平滚动的多列列表框， 通过调用 CListBox::SetColumnWidth 来设置每列的宽度</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_MULTIPLESEL</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>支持多重选择，列表项的选择状态随着用户对该项单击或双击鼠标而翻转</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_NOTIFY</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>当用户单击或双击鼠标时通知父窗口</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_USETABSTOPS</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>使列表框在显示列表项时识别并扩展制表符('\t')，默认的制表宽度是32个对话框单位</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_DISABLENOSCROLL</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>使列表框在不需要滚动时显示一个禁止的垂直滚动条</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LBS_NOREDRAW</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>当选择发生变化时防止列表框被更新，可发送消息改变该风格</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeW4uOeUqOeahOaWueazlQ">
        <h2 class="heading "><span>&#24120;&#29992;&#30340;&#26041;&#27861;</span></h2>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">AddString() </code><code class="comments">// 添加一个字符串选项，放到最后面</code></div>
<div class="line"><code class="plain">DeleteString() </code><code class="comments">// 删除指定索引的字符串选项</code></div>
<div class="line"><code class="plain">GetCurSel() </code><code class="comments">// 获取当前选中选项的索引，返回值小于0则没有选中</code></div>
<div class="line"><code class="plain">SetCursel() </code><code class="comments">// 设置当前索引，如果填写0，那么就是设置第一个选中</code></div>
<div class="line"><code class="plain">GetCount() </code><code class="comments">// 获取组合框或者列表框当前的项的个数</code></div>
<div class="line"><code class="plain">SetItemData() </code><code class="comments">// 设置指定索引的位置的值</code></div>
<div class="line"><code class="plain">GetItemData() </code><code class="comments">// 获取指定索引位置的值</code></div>
<div class="line"><code class="plain">InsertString() </code><code class="comments">// 在指定索引处插入字符串</code></div>
<div class="line"><code class="plain">GetTopIndex() </code><code class="comments">// 返回组合框或者列表框第一个可见项的下标，相应的也有设置下标的</code></div>
<div class="line"><code class="plain">FindString() </code><code class="comments">// 寻找字符串，找到则返回值大于0，并且返回的是寻找到的字符串的下标</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLUxpc3RDdHJs5o6n5Lu2">
        <h1 class="heading "><span>ListCtrl&#25511;&#20214;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xNQ">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>ListCtrl控件</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNMaXN0Q3RybOW4uOeUqOmjjuagvA">
        <h2 class="heading "><span>CListCtrl&#24120;&#29992;&#39118;&#26684;</span></h2>
<p   
>ListCtrl控件是列表视图控件，其常用风格如下表：</p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">风格</strong></p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">介绍</strong></p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LVS_ICON</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>为每个选项显示大图标</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LVS_SMALLICON</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>为每个选项显示小图标</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LVS_LIST</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>显示一列带有小图标的选项</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>LVS_REPORT</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>显示选项详细资料，并且其会创建一个表头，这也是我们用的最多的一个风格</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_1-22-29.png" alt="images/download/attachments/17301744/image2021-7-2_1-22-29.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_1-27-12.png" alt="images/download/attachments/17301744/image2021-7-2_1-27-12.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqExpc3RDdHJs">
        <h2 class="heading "><span>&#20351;&#29992;ListCtrl</span></h2>
<p   
>首先我们创建一个关联：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_1-33-9.png" alt="images/download/attachments/17301744/image2021-7-2_1-33-9.png" width="600"  />
    </p>
<p   
>在我们正式使用之前，我们要知道一些扩展样式：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LONG lStyle;</code></div>
<div class="line"><code class="plain">lStyle = GetWindowLong(m_list.m_hWnd, GWL_STYLE); </code><code class="comments">// 获取当前窗口样式</code></div>
<div class="line"><code class="plain">lStyle &amp;= ~LVS_TYPEMASK; </code><code class="comments">// 清除显示方式位</code></div>
<div class="line"><code class="plain">lStyle |= LVS_REPORT; </code><code class="comments">// 设置样式</code></div>
<div class="line"><code class="plain">SetWindowLong(m_list.m_hWnd, GWL_STYLE, lStyle); </code><code class="comments">// 设置样式</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD dwStyle = m_list.GetExtendedStyle(); </code><code class="comments">// 获取原来的一个扩展风格</code></div>
<div class="line"><code class="plain">dwStyle |= LVS_EX_FULLROWSELECT; </code><code class="comments">// 选中某行使整行高亮（只适用与report风格的listctrl）</code></div>
<div class="line"><code class="plain">dwStyle |= LVS_EX_GRIDLINES; </code><code class="comments">// 网格线（只适用与report风格的listctrl）</code></div>
<div class="line"><code class="plain">dwStyle |= LVS_EX_CHECKBOXES; </code><code class="comments">// 在选项前面生成checkbox控件</code></div>
<div class="line"><code class="plain">m_list.SetExtendedStyle(dwStyle); </code><code class="comments">// 设置扩展样式</code></div>
</div>
    </div>
<p   
>我们可以使用这个风格，在<strong class=" ">OnInitDialog</strong>函数中去设置：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-17-14.png" alt="images/download/attachments/17301744/image2021-7-2_15-17-14.png" width="600"  />
    </p>
<p   
>因为这是一个<strong class=" ">Report</strong>风格的<strong class=" ">ListCtrl</strong>控件，该风格是有一个表头的，所以我们需要使用<strong class=" ">InsertColumn</strong>函数去添加一个表头（<strong class=" ">靠左对齐，宽度为60</strong>）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-21-19.png" alt="images/download/attachments/17301744/image2021-7-2_15-21-19.png" width="600"  />
    </p>
<p   
>我们可以通过<strong class=" ">InsertItem</strong>函数去添加表格的数据：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-23-26.png" alt="images/download/attachments/17301744/image2021-7-2_15-23-26.png" width="600"  />
    </p>
<p   
>在数据开头有这个复选框是因为我们的扩展样式设置了<strong class=" ">CheckBox</strong>。</p>
<p   
><strong class=" ">InsertItem</strong>函数最终返回的结果是一个int类型，其表示当前数据的序号，我们可以根据这个返回值使用<strong class=" ">SetItemText</strong>函数去修改对应的数据：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-26-37.png" alt="images/download/attachments/17301744/image2021-7-2_15-26-37.png" width="600"  />
    </p>
<p   
>如上图我们可以得知，<strong class=" ">InsertItem</strong>函数实际上插入的数据就是一行，而其第一个参数0则表示在第1行的第1列添加一个数据，所以我们使用<strong class=" ">SetItemText</strong>函数根据对应返回值去添加数据则可以选择添加其他列的数据。</p>
<p   
>所以，我们添加数据的时候先应该有<strong class=" ">InsertItem</strong>函数，而后再是<strong class=" ">SetItemText</strong>函数。</p>
<p   
>同样，我们也可以通过<strong class=" ">GetItemText</strong>函数去获取数据，如下图所示就是获取第2行的第2列的数据：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-32-2.png" alt="images/download/attachments/17301744/image2021-7-2_15-32-2.png" width="600"  />
    </p>
<p   
>那么在这里我们使用了CheckBox的扩展样式，我们要获取这复选框有没有被选中怎么办？这时候就可以通过函数<strong class=" ">GetCheck</strong>来获取：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-34-55.png" alt="images/download/attachments/17301744/image2021-7-2_15-34-55.png" width="600"  />
    </p>
<p   
>该函数返回值就是选中为1，没选中则为0，参数也就表示获取第几个复选框的选中状态。</p>
<p   
>我们可以在<strong class=" ">Resource</strong>里添加一个图标，然后在数据开头添加这个图标上去：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-40-59.png" alt="images/download/attachments/17301744/image2021-7-2_15-40-59.png" width="600"  />
    </p>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLea3u-WKoOWPs-mUruiPnOWNlQ">
        <h3 class="heading "><span>&#28155;&#21152;&#21491;&#38190;&#33756;&#21333;</span></h3>
<p   
>我们可以基于表格添加一个右键菜单，首先是创建控件、添加选项：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-48-26.png" alt="images/download/attachments/17301744/image2021-7-2_15-48-26.png" width="400"  />
    </p>
<p   
>其次可以添加右击事件显示菜单：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_15-54-9.png" alt="images/download/attachments/17301744/image2021-7-2_15-54-9.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLVRyZWVDdHJs5o6n5Lu2">
        <h1 class="heading "><span>TreeCtrl&#25511;&#20214;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xNg">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>树形视图控件TreeCtrl</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNUcmVlTGlzdOW4uOeUqOmjjuagvA">
        <h2 class="heading "><span>CTreeList&#24120;&#29992;&#39118;&#26684;</span></h2>
    <div  class="tablewrap">
        <table class="confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">风格</strong></p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
><strong class=" ">介绍</strong></p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_HASLINES</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>添加线段，将子项目和其父项目连接起来</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_LINESTROOT</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>添加线段，将分层结构的顶层或者称为根的项目连接起来，只有指定了TVS_HASLINES，此样式才有效果</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_HASBUTTONS</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>给具有子项目的项目添加带有加号或者减号的按钮，单击该按扭可以展开和折叠相关子树</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_EDITLABELS</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>使置换式标签编辑通知有效</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_DISABLEDRAGDROP</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>使拖放无效</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TVS_SHOWSELALWAY</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>指定当前选中的项目总是被加亮，默认下失去输入焦点时加亮显示会被取消</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_MFC-">
        <h1 class="heading "><span></span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqFRyZWVDdHJs">
        <h2 class="heading "><span>&#20351;&#29992;TreeCtrl</span></h2>
<p   
>老规矩，我们还是添加一个关联参数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-13-9.png" alt="images/download/attachments/17301744/image2021-7-2_16-13-9.png" width="600"  />
    </p>
<p   
>然后新建一个按钮来其来使用一些常见的函数；通过<strong class=" ">InsertItem</strong>函数我们可以添加节点（该方法重载的有很多种，查询MSDN Library即可）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-17-11.png" alt="images/download/attachments/17301744/image2021-7-2_16-17-11.png" width="600"  />
    </p>
<p   
>我们先用<strong class=" ">InsertItem</strong>函数添加一个父节点，然后根据这个函数返回的句柄去创建子节点：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-20-4.png" alt="images/download/attachments/17301744/image2021-7-2_16-20-4.png" width="600"  />
    </p>
<p   
>如果你想支持节点自动排序的话可以使用样式<strong class=" ">TVI_SORT</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-20-50.png" alt="images/download/attachments/17301744/image2021-7-2_16-20-50.png" width="600"  />
    </p>
<p   
>同理，如果你想在子节点下面再创建子节点，你就可将当前子节点作为父节点去创建子节点：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-23-0.png" alt="images/download/attachments/17301744/image2021-7-2_16-23-0.png" width="600"  />
    </p>
<p   
>既然可以创建节点，我们还可以去获取节点，例如我可以去获取一个父节点，也就是最顶层的那个节点。</p>
<p   
>我们需要使用的是<strong class=" ">GetRootItem</strong>函数，其返回值为一个句柄，我们可以通过该句柄去获取对应节点的信息，例如节点名字：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-27-14.png" alt="images/download/attachments/17301744/image2021-7-2_16-27-14.png" width="600"  />
    </p>
<p   
>在有多个父节点的情况下，默认是获取第一个，也就是最上面那个：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-28-24.png" alt="images/download/attachments/17301744/image2021-7-2_16-28-24.png" width="600"  />
    </p>
<p   
>如果你想获取其他的父节点，可以在此基础上使用函数<strong class=" ">GetNextSiblingItem</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-30-48.png" alt="images/download/attachments/17301744/image2021-7-2_16-30-48.png" width="600"  />
    </p>
<p   
>同理，你想获取父节点的子节点就可以使用<strong class=" ">GetChildItem</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-35-14.png" alt="images/download/attachments/17301744/image2021-7-2_16-35-14.png" width="600"  />
    </p>
<p   
>但是这样就会存在缺点，所以我们可以写个循环去遍历获取，这里完全可以根据<strong class=" ">GetNextSiblingItem</strong>函数、<strong class=" ">GetChildItem</strong>函数两者的返回值去循环判断遍历：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_16-41-48.png" alt="images/download/attachments/17301744/image2021-7-2_16-41-48.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-aWh-S7tuWSjOi1hOa6kOaTjeS9nA">
        <h1 class="heading "><span>MFC&#25991;&#20214;&#21644;&#36164;&#28304;&#25805;&#20316;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xNw">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>学习MFC的CFile类</p>
</li><li class=" "><p   
>学习MFC资源打包和输出的方法</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLUNGaWxl57G75omT5byA5paH5Lu2">
        <h2 class="heading "><span>CFile&#31867;&#25171;&#24320;&#25991;&#20214;</span></h2>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeaJk-W8gOaWh-S7tueahOaWueazlQ">
        <h3 class="heading "><span>&#25171;&#24320;&#25991;&#20214;&#30340;&#26041;&#27861;</span></h3>
<ol class=" "><li class=" "><p   
>构造一个没有初始化的CFile对象，对象调用CFile::Open函数；</p>
</li><li class=" "><p   
>用CFile的构造函数打开文件；</p>
</li><li class=" "><p   
>如果要创建一个新的文件，而不是打开一个现存文件，则需要在CFile::Open函数或者CFile的构造函数的第二个参数包含一个CFile::modeCreate标志。</p>
</li></ol>    </div>
    <div class="section section-3" id="src-17301744_safe-id-TUZDLeWunumZheS9v-eUqA">
        <h3 class="heading "><span>&#23454;&#38469;&#20351;&#29992;</span></h3>
<p   
>在当前工程目录下创建一个1.txt文件，然后在代码中写：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_17-6-34.png" alt="images/download/attachments/17301744/image2021-7-2_17-6-34.png" width="600"  />
    </p>
<p   
>如果你想去打开一个文件，其存在就正常打开，不存在就创建的时候可以按如下图去写：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_17-40-26.png" alt="images/download/attachments/17301744/image2021-7-2_17-40-26.png" width="600"  />
    </p>
<p   
>当然，你创建一个新的文件肯定不能就结束了，是要写东西进去的，可以使用<strong class=" ">Write</strong>函数去写入：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_17-41-28.png" alt="images/download/attachments/17301744/image2021-7-2_17-41-28.png" width="600"  />
    </p>
<p   
>如果你想在这个写入之后跟着去填写的话直接使用<strong class=" ">Write</strong>函数是会被覆盖的，我们需要使用<strong class=" ">SeekToEnd</strong>函数将写入位置指向文件末尾然后再使用<strong class=" ">Write</strong>函数，最后记得要关闭这个文件：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_17-44-26.png" alt="images/download/attachments/17301744/image2021-7-2_17-44-26.png" width="600"  />
    </p>
<p   
>当然了，在这里我们的是局部变量，你可以不使用<strong class=" ">Close</strong>函数去释放这个，这是因为在当前函数执行完之后析构函数会帮我们释放，而如果你是在堆中去创建的话就一定要手动的去写。</p>
<p   
>CFile还有很多属性，就不一一去举例了，可以参考如下表格去使用：</p>
    <div  class="tablewrap">
        <table class="confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>属性</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>含义</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeCreate</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>构造新文件，如果文件存在，则长度变为0</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeNoTruncate</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>该属性和modeCreate联合使用，可以达到如下效果：如果文件存在，则不会将文件的长度置为0，如果不存在，则会由modeCreate属性来创建一个新文件。</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeRead</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>以只读方式打开文件</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeWrite</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>以写方式打开文件</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeReadWrite</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>以读、写方式打开文件</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::modeNoInherit</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>阻止文件被子进程继承</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::shareDenyNone</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>不禁止其它进程读写访问文件，但如果文件已经被其它进程以兼容模式打开，则创建文件失败。</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::shareDenyRead</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>打开文件，禁止其它进程件</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::shareDenyWrite</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>打开文件，禁止其它进程写此文件</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::shareExclusive</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>以独占模式打开文件，禁止其它进程对文件的读写，如果文件已经被其它模式打开读写（即使是当前进程），则构造失败。</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::shareCompat</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>此模式在32位MFC中无效，此模式在使用CFile::Open时被映射为CFile::ShareExclusive。</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::typeText</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>对回车、换行设置特殊进程（仅用于派生类）</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>CFile::typeBinary</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>设置二进制模式（仅用于派生类）</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLei1hOa6kOaTjeS9nA">
        <h2 class="heading "><span>&#36164;&#28304;&#25805;&#20316;</span></h2>
<p   
>MFC的资源就是我们之前所说的存储一些图片、图标、信息的...我们可以去查找资源、获取资源的大小、加载资源。</p>
<p   
>首先我们可以基于VC6添加一个TXT文件到资源列表中，按如下图操作：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_17-54-17.png" alt="images/download/attachments/17301744/image2021-7-2_17-54-17.png" width="600"  />
    </p>
<p   
>接下来我们就可以查找资源、获取资源、加载资源、读取数据：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> CHelloComboBoxDlg::OnButton1() </code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 查找资源</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 第二个参数需要填写资源名称，这个是由MAKEINTRESOURCE(Id)去获取的，Id就是我们的资源ID</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 第三个参数是资源类型，就输入我们刚刚自定义的资源类型</code></div>
<div class="line"><code class="plain">    HRSRC hrSrc = FindResource(NULL, MAKEINTRESOURCE(IDR_TXT1), </code><code class="string">"TXT"</code><code class="plain">); </code><code class="comments">// 返回一个句柄</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 获取资源大小</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> rSize = SizeofResource(NULL, hrSrc);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 加载资源</code></div>
<div class="line"><code class="plain">    HGLOBAL hMap = LoadResource(NULL, hrSrc);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 读取数据</code></div>
<div class="line"><code class="plain">    CFile cf;</code></div>
<div class="line"><code class="plain">    cf.Open(</code><code class="string">"new.txt"</code><code class="plain">, CFile::modeCreate|CFile::modeWrite);</code></div>
<div class="line"><code class="plain">    cf.Write(hMap, rSize);</code></div>
<div class="line"><code class="plain">    cf.Close();</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_18-10-57.png" alt="images/download/attachments/17301744/image2021-7-2_18-10-57.png" width="600"  />
    </p>
<p   
>同理，我们也可以加载EXE文件，然后去读取释放。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301744_safe-id-TUZDLU1GQ-WkmumhtemdouiuvuiuoQ">
        <h1 class="heading "><span>MFC&#22810;&#39029;&#38754;&#35774;&#35745;</span></h1>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeacrOiKgumcgOimgeaOjOaPoeeahOefpeivhueCuS4xOA">
        <h2 class="heading "><span>&#26412;&#33410;&#38656;&#35201;&#25484;&#25569;&#30340;&#30693;&#35782;&#28857;</span></h2>
<ol class=" "><li class=" "><p   
>学习MFC的CTabCtrl类和多页面的设计方式</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301744_safe-id-TUZDLeS9v-eUqFRhYkN0cmw">
        <h2 class="heading "><span>&#20351;&#29992;TabCtrl</span></h2>
<p   
>还是老样子直接在VC6中拖拽创建控件：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_19-54-21.png" alt="images/download/attachments/17301744/image2021-7-2_19-54-21.png" width="400"  />
    </p>
<p   
>可以去选择设置自己想要的风格样式，这里也不多说了；我们继续创建一个关联变量：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_19-56-55.png" alt="images/download/attachments/17301744/image2021-7-2_19-56-55.png" width="400"  />
    </p>
<p   
>我们可以通过<strong class=" ">InsertItem</strong>函数去添加标签：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_19-57-37.png" alt="images/download/attachments/17301744/image2021-7-2_19-57-37.png" width="600"  />
    </p>
<p   
>这里我们可以在初始化函数里去创建：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_19-58-44.png" alt="images/download/attachments/17301744/image2021-7-2_19-58-44.png" width="600"  />
    </p>
<p   
>如下图所示是我们的运行结果，这也就说明了我们MFC多页面的设计也是基于这个标签页：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_19-59-29.png" alt="images/download/attachments/17301744/image2021-7-2_19-59-29.png" width="400"  />
    </p>
<p   
>但是现在我们这是创建好了标签页，实际上里面还没有任何东西，我们可以现在资源中区创建几个对话框，并且为其创建窗口类：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-1-45.png" alt="images/download/attachments/17301744/image2021-7-2_20-1-45.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-2-50.png" alt="images/download/attachments/17301744/image2021-7-2_20-2-50.png" width="400"  />
    </p>
<p   
>然后在类中去声明我们的三个Page成员：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-4-30.png" alt="images/download/attachments/17301744/image2021-7-2_20-4-30.png" width="600"  />
    </p>
<p   
>接下来我们就可以去使用<strong class=" ">Create、ShowWindow</strong>函数创建窗口了，但是仅仅这样是不够的，我们还需要设置一个当前页面的父类（我们要显示在标签页里所以这里就写标签页），使用<strong class=" ">SetParent</strong>函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-7-25.png" alt="images/download/attachments/17301744/image2021-7-2_20-7-25.png" width="600"  />
    </p>
<p   
>我们可以看下结果：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-21-0.png" alt="images/download/attachments/17301744/image2021-7-2_20-21-0.png" width="600"  />
    </p>
<p   
>这个子页面是可以随意移动并且没有填满我们的标签页，所以我们可以先根据<strong class=" ">GetClientRect</strong>函数获取当前客户区的坐标然后将该页面移动过去：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-24-43.png" alt="images/download/attachments/17301744/image2021-7-2_20-24-43.png" width="600"  />
    </p>
<p   
>但是这样显然还不行，因为我们的标签页被遮住了，所以我们需要手动的去调整一下坐标让看起来更好一些：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-28-2.png" alt="images/download/attachments/17301744/image2021-7-2_20-28-2.png" width="600"  />
    </p>
<p   
>但是我们点击其他的标签页的时候还是会看见这个子窗口，那么我们应该用其他事件去解决这个问题，先写好其他页面的填充，然后通过类向导去创建<strong class=" ">TCN_SELECTCHANGE</strong>消息相关的处理函数，这个消息表示当选择被修改时应如何去处理。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-45-27.png" alt="images/download/attachments/17301744/image2021-7-2_20-45-27.png" width="600"  />
    </p>
<p   
>这样我们解决了页面显示的问题，但是当前这个子窗口是可以拖拽的并且还有边框，一般来说应用程序不会这么去设计，所以我们需要修改对话框的样式：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301744/image2021-7-2_20-48-13.png" alt="images/download/attachments/17301744/image2021-7-2_20-48-13.png" width="400"  />
    </p>
<p   
></p>
    </div>
    </div>
        </div>

    </article>


            <nav id="ht-post-nav">
                <a href="Win32.html" class="ht-post-nav-prev">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-prev" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-45.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>Win32</span>
        </a>
                <a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html" class="ht-post-nav-next">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-next" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-225.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>&#32593;&#32476;&#32534;&#31243;</span>
        </a>
    </nav>    
            
    <footer id="ht-footer">
    <a href="#" id="ht-jump-top" class="sp-aui-icon-small sp-aui-iconfont-arrows-up"></a>
</footer></div>

<div>
    <div id="ht-mq-detect"></div>
</div>

    <script src="js/lunr.js"></script>
    <script src="js/lunr-extras.js"></script>
    <script src="assets/js/scroll-search.js"></script>

    <script src="assets/js/expand-macro.js"></script>
</body>
</html>
