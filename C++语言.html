<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>C++&#35821;&#35328; - &#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</title>

    
    <link rel="stylesheet" href="assets/css/expand-macro.css">

            <meta name="scroll-content-language-key" content="">
    
    <meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=2.0, user-scalable=yes">

<script type="text/javascript" src="assets/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/js/jquery.scrollTo.min.js"></script>


<script type="text/javascript" src="assets/js/translate.js"></script>


<script type="text/javascript" src="assets/js/scroll-tree.js"></script>

<script type="text/javascript" src="assets/js/theme.main.js"></script>

    <script type="text/javascript" src="assets/js/iframeResizer.min.js"></script>

<link rel="stylesheet" href="assets/css/content-style.css">
    <link rel="stylesheet" href="assets/css/search.css">

<link rel="stylesheet" href="assets/css/theme.main.css">
<link rel="stylesheet" href="assets/css/theme.colors.css">

            <!-- ES5 support for older browsers, needed by lunr -->
        <script src="js/augment.js"></script>
        <script id="worker" type="javascript/worker">

        startIndex = function() {
            idx = lunr.Index.load(lunrIndex);
            idx.pipeline.remove(lunr.stopWordFilter);
            postMessage({type: "setup-complete"});
        }

        onmessage = function (event) {
            var message = event.data;

            if ((message.type === 'setup') && message.baseUrl) {
                var url = message.baseUrl;
                importScripts(url + 'js/lunr.js');
                importScripts(url + 'js/lunr-extras.js');
                importScripts(url + 'js/lunr-index.js');
                importScripts(url + 'js/lunr-data.js');
                startIndex();
            }

            if (idx && (message.type === 'search-request') && message.query) {
                var searchWord = message.query;
                var results = idx.search(searchWord).map(function (result) {
                    return lunrData.filter(function (d) {
                        return d.id === parseInt(result.ref, 10)
                    })[0]
                });
                postMessage({type: 'search-results', results: results, query: searchWord, queryId: message.queryId});
            }
        }

    </script>
    </head>

<body pageid="8684305">

<div id="ht-loader">
    <noscript>
        <p style="width: 100%; text-align:center; position: absolute; margin-top: 200px;">This content cannot be displayed without JavaScript.<br>Please enable JavaScript and reload the page.</p>
    </noscript>
</div>

<div>
   	<header id="ht-headerbar">
    <div class="ht-headerbar-left">
        <a href="" id="ht-menu-toggle" class="sp-aui-icon-small sp-aui-iconfont-appswitcher"></a>
    </div>
    <div class="ht-headerbar-right">
            <div class="sp-aui-icon-small ht-search-index-loader ht-header-icon"></div>

        <div id="ht-search">
            <div class="ht-search-input" style="display: none;">
              	<a href="#" class="sp-aui-icon-small sp-aui-iconfont-remove ht-search-clear"></a>

                <form action="#" method="GET" id="search">
                    <input class="search-input" type="text" placeholder="Search" tabindex="-1" autocomplete="off" name="q" value="">
                    <input type="hidden" name="max" value="15" />
                    <input type="submit" style="display:none" tabindex="-4"/>
                </form>

                <a href="#" id="ht-search-button" class="ht-header-icon ht-header-icon-svg">
                                        <svg width="40px" height="40px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <g>
                            <path d="M29.572,28.802 L28.801,29.571 C28.515,29.857 28.187,30 27.816,30 C27.445,30 27.116,29.857 26.831,29.571 L21.392,24.134 C20.193,24.762 18.908,25.076 17.538,25.076 C15.396,25.076 13.605,24.348 12.163,22.892 C10.721,21.436 10,19.651 10,17.538 C10,15.397 10.721,13.605 12.163,12.163 C13.605,10.721 15.396,10 17.538,10 C19.651,10 21.434,10.721 22.89,12.163 C24.347,13.605 25.075,15.397 25.075,17.538 C25.075,18.937 24.761,20.222 24.132,21.393 L29.572,26.832 C29.857,27.118 30,27.446 30,27.817 C30,28.188 29.857,28.517 29.572,28.802 L29.572,28.802 Z M13.662,21.414 C14.732,22.485 16.024,23.02 17.538,23.02 C19.051,23.02 20.343,22.485 21.413,21.414 C22.484,20.344 23.019,19.052 23.019,17.538 C23.019,16.025 22.484,14.733 21.413,13.662 C20.343,12.592 19.051,12.056 17.538,12.056 C16.024,12.056 14.732,12.592 13.662,13.662 C12.591,14.733 12.056,16.025 12.056,17.538 C12.056,19.052 12.591,20.344 13.662,21.414 L13.662,21.414 Z"></path>
                        </g>
                    </svg>
              	</a>

                <div class="ht-search-dropdown ht-dropdown">
                    <ul></ul>
                </div>
            </div>
        </div>
    </div>
    </header>   	<aside id="ht-sidebar">
    <div class="ht-sidebar-content">
        <div class="ht-sidebar-content-scroll-container">
            <header class="ht-sidebar-header">
                <h1 class="ht-logo">
                    <span class="ht-logo-label">BinaryLearning</span>
                    <img class="space-logo" src="global.logo" />
                </h1>
                <a href="Binary-Learning.html" class="ht-space-link">
                    <h2>&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</h2>
                </a>
                <p><br>ᴀᴜᴛʜᴏʀ: ᴋᴇʏ<br><br>不积跬步，无以至千里；<br>不积小流，无以成江海。</p>
            </header>
                            <iframe id="ht-nav" src="toc.html?pageId=12714553"></iframe>
                <script>
                    $('iframe#ht-nav').iFrameResize(
                            { 'log': true, 'autoResize': true, 'heightCalculationMethod': 'lowestElement', 'checkOrigin': false });
                </script>
                    </div>
    </div>

</aside></div>

<div id="ht-wrap-container">

            
    <div id="ht-sidebar-dragbar">
    <div class="ht-sidebar-drag-handle">
        <span class="drag-handle-1"></span>
        <span class="drag-handle-2"></span>
        <span class="drag-handle-3"></span>
    </div>
</div>
    <article id="ht-content" class="ht-content">
        <header class="ht-content-header">
            <div id="ht-breadcrumb">
    <ul>
        <li><a href="Binary-Learning.html">&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</a></li>
                                                                                     <li><a href="%E5%88%9D%E7%BA%A7%E7%AF%87.html">&#21021;&#32423;&#31687;</a></li>
                                                            </ul>
</div>            <h1 id="src-12714553"> <span>C++&#35821;&#35328;</span></h1>
        </header>

        <div id="main-content" class="wiki-content sp-grid-section" data-index-for-search="true">

    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeamgui_sA">
        <h1 class="heading "><span>&#27010;&#36848;</span></h1>
<p   
>C++是对C的拓展，C原有的语法C++都支持，并在此基础上拓展了一些语法：封装、继承、多态、模板等等。C++拓展新的语法是为了让使用更加方便、高效，这样就需要编译器多做了很多事情，接下来我们就需要一一学习这些概念。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWwgeijhQ">
        <h1 class="heading "><span>&#23553;&#35013;</span></h1>
<p   
>之前我们学习过结构体这个概念，那么结构体可以做参数传递吗？我们来看一下如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> c;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> d;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> Plus(Student s) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> s.a + s.b + s.c + s.d;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s = {</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = Plus(s);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>上面这段代码是定义一个结构体，然后将该结构体传入Plus函数（将结构体成员相加返回），那么问题来了，结构体它是否跟数组一样，传递的是指针呢？来看一下反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_0-9-23.png" alt="images/download/attachments/12714553/image2021-3-28_0-9-23.png" width="400"  />
    </p>
<p   
>可以很清晰的看见，结构体作为参数传递时栈顶（ESP）提升了0x10（16个字节，也就是结构体的四个成员【int】的宽度），而后将ESP的值给了EAX，再通过EAX（ESP）将结构体的成员传入函数，结构体成员从左到右依次从栈顶向下复制进入堆栈。</p>
<p   
>也就是说当我们将结构体作为参数传递时与我们传整数什么的是没有本质区别的，唯一的区别就是传递结构体时不是使用的push来传递的，而是一次性的提升堆栈，然后mov赋值。</p>
<p   
>虽然我们可以使用结构体进行传参，但是这也存在一个问题，就是当我们使用结构体传参时，<strong class=" ">假设结构体有40个成员，那么就存在着大量的内存被复制，这样效率很低，是不推荐使用的</strong>。</p>
<p   
>那如果非要这样使用该怎么办呢？我们可以使用指针传递的方式来，修改一下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> c;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> d;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> Plus(Student* p) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> p-&gt;a + p-&gt;b + p-&gt;c + p-&gt;d;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s = {</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = Plus(&amp;s);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_0-24-53.png" alt="images/download/attachments/12714553/image2021-3-28_0-24-53.png" width="400"  />
    </p>
<p   
>这样我们就可以使用指针的方式来避免内存的重复使用，效率更高。</p>
<p   
>可能很多人看到这就很疑惑了，那这跟C++有什么关系呢？我们之前说过C++和C的本质区别，就是编译器替代我们做了很多事情；别着急，慢慢来看。</p>
<p   
>我们使用指针优化过的代码，实际上还是存在小缺陷的，当结构体成员很多的时候，我们在Plus函数体内就要用指针的调用方式，一堆成员相加...</p>
<p   
>那么是否可以让我们调用更加简单，更加方便呢？如下代码就可以：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> c;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> d;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Plus() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> a + b + c + d;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s = {</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = s.Plus();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>将函数放在结构体内，就不需要我们再去写传参、再去使用指针的调用方式了，因为这些工作编译器帮我们完成了，而本质上这与指针调用没有区别：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_0-37-54.png" alt="images/download/attachments/12714553/image2021-3-28_0-37-54.png" width="400"  />
    </p>
<p   
>而这种写法就是C++的概念：封装；也就是说将函数写在结构体内的形式就称之为封装，其带来的好处就是我们可以更加方便的使用结构体的成员。</p>
<p   
>讲到了封装，我们就要知道另外两个概念：</p>
<ol class=" "><li class=" "><p   
><u class=" "><strong class=" ">类</strong></u>：带有函数的结构体，称为类；</p>
</li><li class=" "><p   
><u class=" "><strong class=" ">成员函数</strong></u>：结构体里的函数，称为成员函数</p>
<ol class=" "><li class=" "><p   
>函数本身不占用结构体的空间（<strong class=" ">函数不属于结构体</strong>）</p>
</li><li class=" "><p   
>调用成员函数的方法与调用结构体成员的语法是一样的 &rarr; <strong class=" ">结构体名称.函数名()</strong></p>
</li></ol></li></ol>    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALXRoaXPmjIfpkog">
        <h1 class="heading "><span>this&#25351;&#38024;</span></h1>
<p   
>之前我们学过了封装，如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> c;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> d;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Plus() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> a + b + c + d;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s = {</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = s.Plus();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>其对应的反汇编代码如下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_0-37-54.png" alt="images/download/attachments/12714553/image2021-3-28_0-37-54.png" width="400"  />
    </p>
<p   
>可以看见我们使用s.Plus()的时候，传递的参数是一个指针，这个指针就是当前结构体的地址，<strong class=" ">这个指针就是this指针</strong>。（通常情况下编译器会使用<strong class=" ">ecx来传递</strong>当前结构体的指针）</p>
<p   
>那么当我们将Plus函数修改成无返回值，不调用结构体成员后，这个指针还会传递过来么？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> c;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> d;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Plus() {</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s = {</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    s.Plus();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们看下反汇编代码，发现指针依然会传递过来：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_0-51-7.png" alt="images/download/attachments/12714553/image2021-3-28_0-51-7.png" width="400"  />
    </p>
<p   
>那也就是说<strong class=" ">this指针是编译器默认传入的，通常会通过ecx进行参数的传递，不管你用还是不用，它都存在着</strong>。</p>
<p   
>既然this指针会作为参数传递，我们是否也可以直接使用这个指针呢？答案是可以的：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>我们在结构体的成员函数内使用this这个关键词就可以调用了，如上代码所示。</p>
<p   
>那么this指针有什么作用呢？我们可以看下如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        a = a;</code></div>
<div class="line"><code class="plain">        b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"><code class="plain">    s.Init(</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>这段代码我们要实现的就是，使用成员函数初始化成员的值，但是实际运行却不符合我们的预期：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_1-29-45.png" alt="images/download/attachments/12714553/image2021-3-28_1-29-45.png" width="400"  />
    </p>
<p   
>跟进反汇编代码发现，这里就是将传入的参数赋值给了参数本身，并没有改变成员的值，这是因为编译器根本不知道你这里的a到底是谁，所以我们就需要借助this指针来实现：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"%d %d"</code><code class="plain">, </code><code class="keyword">this</code><code class="plain">-&gt;a, </code><code class="keyword">this</code><code class="plain">-&gt;b);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"><code class="plain">    s.Init(</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    s.Print();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>为了方便，添加一个成员函数，用于打印输出成员的值：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-28_1-37-52.png" alt="images/download/attachments/12714553/image2021-3-28_1-37-52.png" width="600"  />
    </p>
<p   
>可以看见，这里成功进行初始化了。</p>
<p   
>总结：</p>
<ol class=" "><li class=" "><p   
>this指针是编译器默认传入的，通常会使用ecx进行参数的传递</p>
</li><li class=" "><p   
>成员函数都有this指针，无论是否使用</p>
</li><li class=" "><p   
>this指针不能做++ --等运算，也不可以被重新赋值</p>
</li><li class=" "><p   
>this指针不占用结构体的宽度</p>
</li></ol>    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeaehOmAoOWHveaVsOS4juaekOaehOWHveaVsA">
        <h1 class="heading "><span>&#26500;&#36896;&#20989;&#25968;&#19982;&#26512;&#26500;&#20989;&#25968;</span></h1>
    <div class="section section-2" id="src-12714553_safe-id-QyAg6K-t6KiALeaehOmAoOWHveaVsA">
        <h2 class="heading "><span>&#26500;&#36896;&#20989;&#25968;</span></h2>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>如上代码中，我们发现了存在一个函数，这个函数没有返回类型并且与结构体名称一样，那这段函数在什么时候执行呢？</p>
<p   
>我们先不使用之前学习的方法去调用，直接创建一个对象，这时候会发现该函数就直接执行了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-31_17-4-32.png" alt="images/download/attachments/12714553/image2021-3-31_17-4-32.png" width="600"  />
    </p>
<p   
>这个函数，我们就称之为构造函数。</p>
<p   
>它的汇编代码如下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-3-31_17-30-51.png" alt="images/download/attachments/12714553/image2021-3-31_17-30-51.png" width="400"  />
    </p>
<p   
>如果我们想要在创建对象的时候，自定义初始化成员的值，就可以在析构函数上加上参数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s(</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>创建对象的时候，在对象名后面加上括号传入即可；但是这样就会存在一个问题，我们不想初始化值的时候就没有办法创建这个类：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>编译直接出错：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-1_15-42-56.png" alt="images/download/attachments/12714553/image2021-4-1_15-42-56.png" width="600"  />
    </p>
<p   
>这是因为编译器发现你没有传入参数，就会去寻找没有参数的构造函数，但是在这段代码中没有声明，所以需要声明一下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>这样就没有任何问题了，你想传参就传，不想就不传。</p>
<p   
><strong class=" ">我们总结一下其（构造函数）特点</strong>：</p>
<ol class=" "><li class=" "><p   
>构造函数名称与类名一样</p>
</li><li class=" "><p   
>不能写返回类型（无返回值）</p>
</li><li class=" "><p   
>创建对象时，则会自动调用执行，一般用于初始化</p>
</li><li class=" "><p   
>可以有多个构造函数（建议只有一个无参的），这种声明方式我们称之为重载（其他函数也可以）</p>
</li><li class=" "><p   
>编译器不要求必须提供构造函数</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714553_safe-id-QyAg6K-t6KiALeaekOaehOWHveaVsA">
        <h2 class="heading "><span>&#26512;&#26500;&#20989;&#25968;</span></h2>
<p   
>析构函数函数的语法跟构造函数很像，其区别就是：<strong class=" ">析构函数需要在函数名前面加一个波浪号</strong>、<strong class=" ">析构函数只能有一个</strong>、<strong class=" ">析构函数函数不可以写参数</strong>、<strong class=" ">构造函数是创建对象的时候执行，但是析构函数函数是在对象销毁前执行</strong>：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    ~Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look A."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><strong class=" ">析构函数函数是在对象销毁前执行</strong>，那么对象会在什么时候销毁呢？可以看下反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-1_16-9-20.png" alt="images/download/attachments/12714553/image2021-4-1_16-9-20.png" width="400"  />
    </p>
<p   
>会发现在程序执行结束，<strong class=" ">也就是main函数的return之后会执行析构函数函数</strong>，但这句话实际上是不严谨的，因为我们的main函数是没有返回值的，也就是return不会有对应的汇编代码，当我们设置返回值再来看下反汇编代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    Student(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    ~Student() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Look A."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Init(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;a = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;b = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Student s;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-1_16-12-49.png" alt="images/download/attachments/12714553/image2021-4-1_16-12-49.png" width="400"  />
    </p>
<p   
>可以很清晰的看见，析构函数是在return返回之前执行的。</p>
<p   
>我们总结（析构函数）一下：</p>
<ol class=" "><li class=" "><p   
>只能有一个，不支持重载</p>
</li><li class=" "><p   
>无返回值</p>
</li><li class=" "><p   
>无任何参数</p>
</li><li class=" "><p   
>主要用于清理工作</p>
</li><li class=" "><p   
>编译器不要求必须提供</p>
</li><li class=" "><p   
>当对象在main函数（堆栈）中创建，在return之前调用执行；当对象在全局变量区，则会在应用程序退出之前调用</p>
</li></ol>    </div>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALee7p-aJvw">
        <h1 class="heading "><span>&#32487;&#25215;</span></h1>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Person {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> sex;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct Teacher {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> sex;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> level;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> classId;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>如上代码中可以看见，Teacher类与Person类都存在着相同的2个成员age和sex，那么这就相当于重复编写了，我们可以通过继承的方式避免这样重复的编写（<strong class=" ">当前类名称:要继承的类名称</strong>）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Teacher:Person {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> level;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> classId;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>创建对象的对应反汇编代码如下，可以清晰的看见与我们正常的内存布局是一样的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_1-44-16.png" alt="images/download/attachments/12714553/image2021-4-4_1-44-16.png" width="400"  />
    </p>
<p   
>那么继承是什么？<strong class=" ">这就很好理解了，继承的本质就是数据复制，子类（派生类）继承（复制）父类（基类）的数据，在这里Person父类（基类），Teacher为子类（派生类）；继承可以减少重复代码的编写。</strong></p>
<p   
>假设，子类中存在一个与父类中相同的成员会如何？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Person {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> sex;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct Teacher:Person { </code><code class="comments">// Inherit</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> classId;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>我们可以创建一个对象来看一下对应的宽度和反汇编代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Teacher t;</code></div>
<div class="line"><code class="plain">    t.age = </code><code class="value">30</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.sex = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.classId = </code><code class="value">20</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d"</code><code class="plain">, sizeof(t));</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d"</code><code class="plain">, sizeof(t));</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>首先看下数据宽度，我们会发现是16，那也就是说这里不管如何你只要继承了，在编译器中两个成员还是会直接添加过来，Teacher的成员依然是4个「4成员*4数据宽度（int类型） = 16」</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_1-40-55.png" alt="images/download/attachments/12714553/image2021-4-4_1-40-55.png" width="600"  />
    </p>
<p   
>再来看下反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_1-41-29.png" alt="images/download/attachments/12714553/image2021-4-4_1-41-29.png" width="400"  />
    </p>
<p   
>之前我们已经看过了正常的内存布局了，在这里，很明显，少了一个0x10位置的成员，那么按照内存布局应该是这样的：</p>
<p   
>0x10 &rarr; Person.age</p>
<p   
>0x0C &rarr; Person.sex</p>
<p   
>0x08 &rarr; Teacher.age</p>
<p   
>0x04 &rarr; Teacher.classId</p>
<p   
>而在这里创建对象编译器使用的age成员默认就是当前类Teacher的成员；想要使用父类中的成员可以使用这种方式（<strong class=" ">对象名.父类名称::成员名称</strong>）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Teacher t;</code></div>
<div class="line"><code class="plain">    t.Person::age = </code><code class="value">30</code><code class="plain">; </code><code class="comments">// Father</code></div>
<div class="line"><code class="plain">    t.age = </code><code class="value">30</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.sex = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.classId = </code><code class="value">20</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>子类与父类成员重名的问题我们可以通过这种方式解决，但是在实际应用中还是尽量避免这种问题比较好。</p>
<p   
>我们可以多次继承么，或者说继承仅仅局限于子、父关系么？如下代码，B继承了A，C继承了B，C是否只继承了B的v和n？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct A {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct B:A {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> v;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> n;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct C:B {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> p;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> o;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>我们可以来打印一下C的数据宽度：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_1-57-33.png" alt="images/download/attachments/12714553/image2021-4-4_1-57-33.png" width="600"  />
    </p>
<p   
>结果是24，那么就说明C不仅仅继承了B，还继承了A；再换个说法就是，继承的本质是数据的复制，那也就是说当复制完（继承）后才是其本身，B的本身就是4个成员x、y、v、n。</p>
<p   
><img  class="confluence-embedded-image confluence-thumbnail"  src="images/download/thumbnails/12714553/image2021-4-4_2-11-14.png" alt="images/download/thumbnails/12714553/image2021-4-4_2-11-14.png" width="250"  />
    </p>
<p   
>除了这种方式以外，我们想实现同样的效果可以使用多重继承（<strong class=" ">当前类:继承的类A, 继承的类B</strong>）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct A {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct B {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> v;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> n;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct C:A,B { </code><code class="comments">// Multiple</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> p;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> o;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>但这种方式在很多面向对象语言中是不允许时间的，在C++中是可以使用的，其内存分布也与第一种方式不一样：</p>
<p   
><img  class="confluence-embedded-image confluence-thumbnail"  src="images/download/thumbnails/12714553/image2021-4-4_2-10-10.png" alt="images/download/thumbnails/12714553/image2021-4-4_2-10-10.png" width="250"  />
    </p>
<p   
>最后：继承的类A和继承的类B的顺序，谁在前，谁就在内存分布中的前面；不推荐使用多重继承，这会增加程序的复杂度<strong class=" ">。</strong></p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeexu-aIkOWRmOeahOiuv-mXruaOp-WItg">
        <h1 class="heading "><span>&#31867;&#25104;&#21592;&#30340;&#35775;&#38382;&#25511;&#21046;</span></h1>
<p   
><strong class=" ">课外 &rarr; 好的编程习惯</strong>：定义与实现分开写，提升代码可读性。</p>
<p   
>如下代码，Student这个类的所有成员我们都可以调用，但是我们不想让被人调用Print1这个方法该怎么？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> sex;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print1() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Func Print1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Func Print"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>这里我们可以使用关键词：private、public来控制我们想被人访问的和不想被人访问的成员：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Student {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print1() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Func Print1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> sex;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Func Print"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>当我们调用Print1的时候就会发现无法编译：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_20-38-26.png" alt="images/download/attachments/12714553/image2021-4-4_20-38-26.png" width="600"  />
    </p>
<p   
>private（私有）、public（公有）的使用总结：</p>
<ol class=" "><li class=" "><p   
>对外提供的函数或者变量，定义成public，不能随意改动</p>
</li><li class=" "><p   
>可能会改动的函数或者变量，定义成private，使用时编译器会检测</p>
</li><li class=" "><p   
>只有当前结构体内部函数才可以访问private的成员</p>
</li><li class=" "><p   
>private、public可以修饰函数或者变量</p>
</li></ol><p   
>那么问题来了，private修饰的函数或者变量真的不能访问吗？并不是，只是我们没有办法通过正常的方式去使用，但是我们可以使用指针的方式去调用：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_21-10-51.png" alt="images/download/attachments/12714553/image2021-4-4_21-10-51.png" width="600"  />
    </p>
<p   
>那就说明private修饰的成员与普通成员没有区别，只有编译器会检测。</p>
<p   
>从这节课开始我们不再使用struct作为类的创建，而是直接使用class关键词，其使用没有什么区别，唯一的区别在于成员默认访问属性不一样，在struct中所有成员默认的属性是public，而在class中则相反：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_21-17-6.png" alt="images/download/attachments/12714553/image2021-4-4_21-17-6.png" width="600"  />
    </p>
<p   
>除此之外还有一个就是在继承时的区别，我们可以将一个正常的struct继承修改成class：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> A {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> B:A {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> v;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> n;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>当我们创建对象调用的时候却无法编译：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_21-24-56.png" alt="images/download/attachments/12714553/image2021-4-4_21-24-56.png" width="600"  />
    </p>
<p   
>这是因为在继承的时候默认将继承过来的A的所有成员设置为private，也就是如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> A {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> B:</code><code class="keyword">private</code><code class="plain"> A {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> v;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> n;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>而我们想要外部可以调用可以将private修改成public。</p>
<p   
>最后一个问题：私有成员是否会被继承？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> A {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> B:</code><code class="keyword">public</code><code class="plain"> A {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> v;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> n;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>以上代码B继承了A，这里A前面的public代表着，按照A的成员定义的属性继承过来，公有就是公有，私有就是私有。</p>
<p   
>而在这里我们想要确认B有没有继承A的私有成员，有2个方法：</p>
<p   
>1.查看数据宽度，显示为16</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_21-37-36.png" alt="images/download/attachments/12714553/image2021-4-4_21-37-36.png" width="400"  />
    </p>
<p   
>2.指针方式调用，可以成功调用获取到值</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_21-56-15.png" alt="images/download/attachments/12714553/image2021-4-4_21-56-15.png" width="400"  />
    </p>
<p   
>所以我们得出最终结论：父类的私有成员是可以被继承的，但是也不能直接访问。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWcqOWghuS4reWIm-W7uuWvueixoQ">
        <h1 class="heading "><span>&#22312;&#22534;&#20013;&#21019;&#24314;&#23545;&#35937;</span></h1>
<p   
>我们可以在什么地方创建对象？</p>
<ol class=" "><li class=" "><p   
>全局变量区，在函数外面</p>
</li><li class=" "><p   
>在栈中创建对象，也就是函数内</p>
</li><li class=" "><p   
>在堆中创建对象</p>
</li></ol><p   
><strong class=" ">注意：之前一直提到的堆栈实际上是两个概念-&gt;堆、栈，我们之前所讲的就是栈，从本章开始要严格区分。</strong></p>
<p   
>在C语言中，我们可以通过一个函数去申请一块内存，就是<strong class=" ">malloc(N)</strong>；申请的这一块内存就是在堆中的。</p>
<p   
>在堆中创建对象我们可以使用new、delete这两个关键词来创建和释放：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">Person* p = </code><code class="keyword">new</code><code class="plain"> Person();</code></div>
<div class="line"><code class="plain">delete p;</code></div>
</div>
    </div>
<p   
>我们可以来实际的看一下new、delete这两个关键词主要做了什么。</p>
<p   
>首先我们使用new关键词的时候会发现，其除了在堆中创建了对象还会调用构造函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_22-10-14.png" alt="images/download/attachments/12714553/image2021-4-4_22-10-14.png" width="600"  />
    </p>
<p   
>再跟进看看使用delete，它会释放空间并调用析构函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_22-11-41.png" alt="images/download/attachments/12714553/image2021-4-4_22-11-41.png" width="600"  />
    </p>
<p   
>我们想要了解其本质，还是要去跟一下汇编代码，这里跟一下new关键词的执行流程看看其分别调用的函数（<strong class=" ">跟进call operator new (004012e0)</strong>）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_22-17-13.png" alt="images/download/attachments/12714553/image2021-4-4_22-17-13.png" width="400"  />
    </p>
<p   
>而后调用了构造函数：call @ILT+0(Person::Person) (00401005)</p>
<p   
>我们再来跟下malloc函数的调用步骤：</p>
<p   
>call malloc (00401a20) &rarr; _nh_malloc_dbg &rarr; _heap_alloc_dbg &rarr; _heap_alloc_base &rarr; HeapAlloc</p>
<p   
>那么这时候一下就清楚了new的本质，实际上就是malloc+构造函数，同样的方法可以跟下delete看下它跟free函数。</p>
<p   
>跟进delete关键词，会发现其会先调用析构函数函数然后再去调用operator delete然后就是_free_dbg：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_22-30-48.png" alt="images/download/attachments/12714553/image2021-4-4_22-30-48.png" width="400"  />
    </p>
<p   
>所以delete的本质就是析构函数+free。</p>
<p   
>如果我们想要在堆中申请数组，需要使用new[]、delete[]这两个关键词来创建和释放。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// C、C++的方式在堆中申请、释放int数组</code></div>
<div class="line"><code class="keyword">int</code><code class="plain">* p = (</code><code class="keyword">int</code><code class="plain">*)malloc(sizeof(</code><code class="keyword">int</code><code class="plain">)*</code><code class="value">10</code><code class="plain">); free(p);</code></div>
<div class="line"><code class="keyword">int</code><code class="plain">* p = </code><code class="keyword">new</code><code class="plain"> </code><code class="keyword">int</code><code class="plain">[</code><code class="value">10</code><code class="plain">]; delete[] p;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// C、C++的方式在堆中申请、释放Class类型数组</code></div>
<div class="line"><code class="plain">Person* p = (Person*)malloc(sizeof(Person)*</code><code class="value">10</code><code class="plain">); free(p);</code></div>
<div class="line"><code class="plain">Person* p = </code><code class="keyword">new</code><code class="plain"> Person[</code><code class="value">10</code><code class="plain">]; delete[] p;</code></div>
</div>
    </div>
<p   
>malloc和new[]的区别：</p>
<ol class=" "><li class=" "><p   
>malloc不会调用构造函数</p>
</li><li class=" "><p   
>new[]会调用构造函数，创建一次则调用一次，例如new Person[10]则调用10次</p>
</li></ol><p   
>同理也可以知道free和delete[]的区别。</p>
<p   
><strong class=" ">delete和delete[]是有区别的，如果使用new[]在堆中创建对象，使用delete去释放则只会释放第一个对象，其他的不会释放。</strong></p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeW8leeUqOexu-Weiw">
        <h1 class="heading "><span>&#24341;&#29992;&#31867;&#22411;</span></h1>
<p   
>引用类型就是变量的别名，其在初始化时必须要赋值。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 基本类型</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> x = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="keyword">int</code><code class="plain">&amp; ref = x;</code></div>
<div class="line"><code class="plain">ref = </code><code class="value">2</code><code class="plain">;</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"%d \n"</code><code class="plain">,ref);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 类</code></div>
<div class="line"><code class="plain">Person p;</code></div>
<div class="line"><code class="plain">Person&amp; ref = p;</code></div>
<div class="line"><code class="plain">ref.x = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"%d \n"</code><code class="plain">,p.x);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 指针类型</code></div>
<div class="line"><code class="keyword">int</code><code class="plain">****** x = (</code><code class="keyword">int</code><code class="plain">******)</code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="keyword">int</code><code class="plain">******&amp; ref = x;</code></div>
<div class="line"><code class="plain">ref = (</code><code class="keyword">int</code><code class="plain">******)</code><code class="value">2</code><code class="plain">;</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"%d \n"</code><code class="plain">,x);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 数组类型</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> arr[] = {</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">,</code><code class="value">3</code><code class="plain">};</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> (&amp;p)[</code><code class="value">3</code><code class="plain">] = arr;</code></div>
<div class="line"><code class="plain">p[</code><code class="value">0</code><code class="plain">] = </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"%d \n"</code><code class="plain">,arr[</code><code class="value">0</code><code class="plain">]);</code></div>
</div>
    </div>
<p   
>如上是引用类型作用在各个类型下的例子，那么引用类型是如何实现的呢？其本质是什么？我们可以看下反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-6-8.png" alt="images/download/attachments/12714553/image2021-4-4_23-6-8.png" width="400"  />
    </p>
<p   
>会发现这段反汇编和指针的反汇编一模一样的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-7-49.png" alt="images/download/attachments/12714553/image2021-4-4_23-7-49.png" width="400"  />
    </p>
<p   
>这时候我们暂时的出结论：引用类型就是指针。</p>
<p   
>但如果引用类型就是指针，为什么C++需要新创建一个引用类型的概念呢？它们之间必然存在着一些区别，我们可以从初始化、运算、赋值来看反汇编代码的区别：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-17-23.png" alt="images/download/attachments/12714553/image2021-4-4_23-17-23.png" width="400"  />
    </p>
<p   
>我们可以很清晰的看见区别从运算到赋值都不一样，指针运算到赋值改变的是指针本身，而不是指针指向的那个地址，而引用则不一样其从运算到赋值改变的是所引用的变量，我们得出这几个结论：</p>
<ol class=" "><li class=" "><p   
>引用必须赋初始值，且只能指向一个变量，从一而终（专一）；</p>
</li><li class=" "><p   
>对引用赋值，是对其指向的变量赋值，而不是修改引用本身的值；</p>
</li><li class=" "><p   
>对引用做运算，就是对其指向的变量做运算，而不是对引用本身做运算；</p>
</li><li class=" "><p   
>引用类型就是一个<strong class=" ">弱化了的指针</strong>；个人理解：<strong class=" ">引用类型就是一个*p</strong>。</p>
</li></ol><p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-25-6.png" alt="images/download/attachments/12714553/image2021-4-4_23-25-6.png" width="400"  />
    </p>
<p   
>C++设计引用类型是因为指针类型很难驾驭，一旦用不好就回出问题，所以取长补短设计了引用类型。</p>
<p   
>那么引用类型在实际开发中的作用是什么呢？我们可以用在函数参数传递中：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Plus(</code><code class="keyword">int</code><code class="plain">&amp; i) {</code></div>
<div class="line"><code class="plain">    i++;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    Plus(i);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如上代码中Plus函数的参数是一个引用类型，当我们把变量i传递进去，i就会自增1，而实际上也就修改变量i本身的值；换一种说法就是，我们之前函数参数传递的是值，而这里传递的是变量的地址。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-34-17.png" alt="images/download/attachments/12714553/image2021-4-4_23-34-17.png" width="600"  />
    </p>
<p   
>那么在构造类型中又是怎么样的呢？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Base {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">    Base(</code><code class="keyword">int</code><code class="plain"> a, </code><code class="keyword">int</code><code class="plain"> b) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;x = a;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;y = b;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> PrintByRef(Base&amp; refb, Base* pb) {</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d %d \n"</code><code class="plain">, pb-&gt;x, pb-&gt;y);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d %d \n"</code><code class="plain">, refb.x, refb.y);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Base b(</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    PrintByRef(b, &amp;b);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-46-5.png" alt="images/download/attachments/12714553/image2021-4-4_23-46-5.png" width="600"  />
    </p>
<p   
>我们可以看见除了读取的表现形式不一样，实际上汇编代码是一模一样的；但是指针类型是可以重新赋值并运算的，而引用类型不可以。</p>
<p   
>当一个变量是int类型的，而我们引用类型却是一个其他类型的，会怎么样呢？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> x = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"><code class="plain">Person&amp; ref = (Person&amp;)x;</code></div>
</div>
    </div>
<p   
>这是可以编译的，但是没有实际意义，所以在使用引用的时候原来是什么类型就应该使用什么类型。</p>
<p   
>大家都知道，我们使用指针的时候是可以修改指针本身的，这会存在一定的风险，而C++中提供了引用类型，不可以修改引用本身，我们可以修改被引用的值，当我们不想其他人修改引用类型对应引用的值，可以使用const这个关键词，这种方式我们称之为常引用：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-4_23-56-58.png" alt="images/download/attachments/12714553/image2021-4-4_23-56-58.png" width="600"  />
    </p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALemdouWQkeWvueixoeeoi-W6j-iuvuiuoeS5i-e7p-aJv-S4juWwgeijhQ">
        <h1 class="heading "><span>&#38754;&#21521;&#23545;&#35937;&#31243;&#24207;&#35774;&#35745;&#20043;&#32487;&#25215;&#19982;&#23553;&#35013;</span></h1>
<p   
>之前已经学习过继承和封装了，但是要在实际开发中使用，光学语法和原理是不够的，在设计层面我们需要做一些优化。</p>
<p   
>如下代码是继承的例子：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Sex;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Work() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Person:Work()"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Teacher t;</code></div>
<div class="line"><code class="plain">    t.Age = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.Sex = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    t.Level = </code><code class="value">2</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    t.Work();</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>当t.Age=-1，这在代码层面（语法）是合法的，但是不合理，因为人的年龄不可能是负数；所以从设计层面以上代码就不正确、不合理。</p>
<p   
>所以，我们可以将不想被外界访问的成员隐藏起来，也就是使用private关键词：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Sex;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Work() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Person:Work()"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>但是这样，如上代码就会出现问题，因为我们没法直接访问到成员，因此从设计层面出发设计这个，我们可以提供按钮或者说一个函数用来控制这些值：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Sex;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Work() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Person:Work()"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> SetAge(</code><code class="keyword">int</code><code class="plain"> Age) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Age = Age;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> SetSex(</code><code class="keyword">int</code><code class="plain"> Sex) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Sex = Sex;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> SetLevel(</code><code class="keyword">int</code><code class="plain"> Level) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>而后我们可以通过函数去设置这些值，那有人就会问了，你这样不还是可以输入-1吗？是的，是可以输入，单同样，我们可以在成员函数内做条件判断来控制输入的内容：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> SetAge(</code><code class="keyword">int</code><code class="plain"> Age) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (Age &gt; </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Age = Age;</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Age = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><strong class=" ">用成员函数控制就不会存在别人想要调用这个类的时候存在合法不合理的情况了，其根本的目的就是可控</strong>。（数据隐藏）</p>
<p   
>除了成员数据（变量）以外，还有一些提供给自己用的成员函数也要隐藏。</p>
<p   
>但这样随之而来的问题也就产生了，一般情况下，我们是想要在创建对象的时候就赋值了，也就是说我们使用构造函数去赋值，那这时候如果父类存在构造函数，使用子类创建对象的时候，子类默认会调用父类无参的构造函数，也就是说父类如果存在有参的构造函数被继承，就必须要有无参的构造函数。</p>
<p   
>所以一个好的习惯：当你写一个类的时候，<strong class=" ">就应该写一个无参的构造函数</strong>。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Sex;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Person() {</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    Person(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Age = Age;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Sex = Sex;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Work() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Person:Work()"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Teacher() {</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    Teacher(</code><code class="keyword">int</code><code class="plain"> Level) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>如上代码，调用Teacher创建对象，我们想通过构造函数赋值Age和Sex该怎么办？第一时间想到的时候使用this调用，但是这里是继承父类的，肯定不行。</p>
<p   
>C++也提供了这种情况下的语法：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">Teacher(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex, </code><code class="keyword">int</code><code class="plain"> Level):Person(Age, Sex) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>在子类有参构造函数中加入参数列表，而后在括号后门加上冒号跟上父类有参构造函数，传入变量即可。</p>
<p   
>有些人就疑问了，为什么这种写法不可以呢？</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">Teacher(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex, </code><code class="keyword">int</code><code class="plain"> Level) {</code></div>
<div class="line"><code class="plain">    Person(Age, Sex);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>这只有利用反汇编代码来解释了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-10_0-20-53.png" alt="images/download/attachments/12714553/image2021-4-10_0-20-53.png" width="600"  />
    </p>
<p   
>如上反汇编代码，可以很清楚的看见当我们不使用那种方法还是会调用一遍父类无参的构造函数，接着手动添加的构造函数，编译器会把堆栈中临时分的对象赋值，但是当我们这段构造函数执行完成之后就没了，所以没有任何意义。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALemdouWQkeWvueixoeeoi-W6j-iuvuiuoeS5i-WkmuaAgQ">
        <h1 class="heading "><span>&#38754;&#21521;&#23545;&#35937;&#31243;&#24207;&#35774;&#35745;&#20043;&#22810;&#24577;</span></h1>
<p   
>C++是一门面向对象的编程语言，所有的面向对象语言都有一个特征：封装、继承、多态；之前已经了解过封装、继承了，这里来了解一下多态。</p>
<p   
>所有的面向对象的编程语言在设计的时候都是为了解决一个问题，那就是避免重复造轮子，也就是避免写2遍重复的代码，我们也可以称之为代码复用，其体现方式有2种：1.继承；2.共用相同的函数。</p>
<p   
>现在我们有一个需求，需要打印对象的成员变量，如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Age;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Sex;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Person() {</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    Person(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Age = Age;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Sex = Sex;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print() {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"%d \n"</code><code class="plain">, </code><code class="keyword">this</code><code class="plain">-&gt;Sex);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Teacher() {</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    Teacher(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex, </code><code class="keyword">int</code><code class="plain"> Level):Person(Age, Sex) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> PrintPerson(Person&amp; p) {</code></div>
<div class="line"><code class="plain">    p.Print();</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们创建了一个PrintPerson函数来调用Person的Print函数，但是在这里如果我们想要打印Teacher的成员呢？那就需要创建2个打印函数了，也就是违背了面向对象的初衷，重复造轮子了。</p>
<p   
>在C++中我们可以使用父类的指针来指向子类的对象：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Person p(</code><code class="value">1</code><code class="plain">,</code><code class="value">3</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    Teacher t(</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">,</code><code class="value">3</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    Person* px = &amp;t;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如下图我们可以很清晰的看见内存的结构，当我们形容子类B内存结构的时候，一定是有三个成员的，而不是一个成员z，当我们创建A*指针的时候指向的是子类对象的首地址，通过这个指针可以访问x、y，刚好子类对象B的开始位置是父类类型对象的第一个成员，所以我们可以使用父类类型的指针指向子类类型对象；但是反之（<strong class=" ">子类类型的指针指向父类类型的对象</strong>）我们却不可以，这是因为使用父类类型的指针指向子类类型对象有一个弊端，那就是没法访问子类类型的z，反过来的话，父类类型对象的成员只有x、y没有z，所以我们通过子类类型指针访问的时候是可以访问到三个成员的：x、y、z，但实际上父类对象是没有z的，那么在访问的过程中就会存在问题。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-11_23-53-55.png" alt="images/download/attachments/12714553/image2021-4-11_23-53-55.png" width="400"  />
    </p>
<p   
>所以我们可以只保留PrintPerson函数，而不再去重复造轮子：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-12_0-23-19.png" alt="images/download/attachments/12714553/image2021-4-12_0-23-19.png" width="600"  />
    </p>
<p   
>如上代码仅仅是为了解决这种问题而举例的，所以代码严谨性可以忽略。</p>
<p   
>但是这样的弊端，就很清楚了，就是我们通过父类类型的指针指向子类类型的对象，是无法访问到子类类型自己本身的成员，只能访问到继承父类类型的成员。</p>
<p   
>所以这个还是无法满足我们的实际需求，那我们想不改变原有PrintPerson函数的情况下，只有在子类中重写Print函数才能到达需求（函数重写）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> Teacher:</code><code class="keyword">public</code><code class="plain"> Person {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Level;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Teacher() {</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    Teacher(</code><code class="keyword">int</code><code class="plain"> Age, </code><code class="keyword">int</code><code class="plain"> Sex, </code><code class="keyword">int</code><code class="plain"> Level):Person(Age, Sex) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;Level = Level;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Print() {</code></div>
<div class="line"><code class="plain">        Person::Print();</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"%d \n"</code><code class="plain">, </code><code class="keyword">this</code><code class="plain">-&gt;Level);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>Person::Print();是先调用父类的函数，但是在这里就可以打印了吗？实则不然：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-12_0-22-38.png" alt="images/download/attachments/12714553/image2021-4-12_0-22-38.png" width="600"  />
    </p>
<p   
>我们可以看下反汇编代码，查看函数PrintPerson：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-12_0-14-35.png" alt="images/download/attachments/12714553/image2021-4-12_0-14-35.png" width="400"  />
    </p>
<p   
>首先这里传递的是父类的引用类型，而后去调用的Print函数也是Person父类的，所以这样还是没法满足我们的需求。</p>
<p   
>我们可以使用一个关键词去解决这个问题，那就是在父类的Print函数类型前面加上virtual，则表示这是一个虚函数（其作用：当你PrintPerson函数传入的对象是子类就调用子类的，是父类就调用父类的）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-12_0-24-8.png" alt="images/download/attachments/12714553/image2021-4-12_0-24-8.png" width="600"  />
    </p>
<p   
>这时候我们就可以引出多态的概念：<strong class=" ">多态就是可以让父类的指针有多种形态，C++中是通过虚函数实现的多态性</strong>。</p>
<p   
>多种形态的表现，我们就已经在如上例子中说么了。</p>
<p   
>没有方法体的函数我们称之为纯虚函数，也就是说如下例子：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">virtual </code><code class="keyword">int</code><code class="plain"> area() = </code><code class="value">0</code><code class="plain">;</code></div>
</div>
    </div>
<p   
><strong class=" ">纯虚函数</strong>：</p>
<ol class=" "><li class=" "><p   
>虚函数目的是提供一个统一的接口，被继承的子类重载，以多态的形式被调用；</p>
</li><li class=" "><p   
>如果父类中的虚函数可以任何意义，那么可以定义成纯虚函数；</p>
</li><li class=" "><p   
>含有纯虚函数的类被称之为<strong class=" ">抽象类</strong>，不能创建对象；</p>
</li><li class=" "><p   
>虚函数可以被直接调用，也可以被子类重写后以多态的形式调用，而纯虚函数<strong class=" ">必须</strong>在子类中实现该函数才可以使用。</p>
</li></ol>    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeiZmuihqA">
        <h1 class="heading "><span>&#34394;&#34920;</span></h1>
<p   
>上一章了解了多态，那么我们来了解一下多态在C++中是如何实现的。</p>
<p   
>了解本质，那就通过反汇编代码去看就行了，首先我们看下非多态的情况下的反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-15_23-14-19.png" alt="images/download/attachments/12714553/image2021-4-15_23-14-19.png" width="400"  />
    </p>
<p   
>然后再来看下多态情况下的反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-15_23-18-22.png" alt="images/download/attachments/12714553/image2021-4-15_23-18-22.png" width="400"  />
    </p>
<p   
>很明显这里多态的情况下会根据edx间接调用，而非多态则会直接调用。</p>
<p   
>那么我们来看下间接调用的流程是什么：</p>
<ol class=" "><li class=" "><p   
>ebp+8地址对应的值给到eax（ebp+8 也就是函数的参数 &rarr; 当前参数指针【父类指针】）</p>
</li><li class=" "><p   
>eax地址对应的值给到edx（eax相当于当前对象的第一个成员）</p>
</li><li class=" "><p   
>调用edx地址对应的值，也就是子类对象的Print函数</p>
</li></ol><p   
>但是这里很奇怪，第一个成员为什么就能是Print函数呢？跟我们之前理解的4个字节的参数完全不一样。</p>
<p   
>那么编译器到底是做了什么工作，才能根据我们传入的对象来进行间接调用的呢？这是因为<strong class=" ">虚表</strong>。</p>
<p   
>只要有虚函数，不论多少个，<strong class=" ">对象的数据宽度就会比其原来多出4个字节</strong>，这四个字节我们称之为虚表。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-15_23-54-33.png" alt="images/download/attachments/12714553/image2021-4-15_23-54-33.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-15_23-54-26.png" alt="images/download/attachments/12714553/image2021-4-15_23-54-26.png" width="600"  />
    </p>
<p   
>那么虚表在哪呢？可以通过VC6来寻找虚标，先创建对象然后下断点运行查看，如下图中，可以很清晰的看见对象t除了继承Person父类的Age、Sex以及本身的Level成员外，还有一个__vfptr，上面有一个地址就是0x00422024，那这个地址就是虚表，这个表里面存储的就是函数的地址：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-1-56.png" alt="images/download/attachments/12714553/image2021-4-16_0-1-56.png" width="600"  />
    </p>
<p   
>我们可以调出内存窗口查看一下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-6-6.png" alt="images/download/attachments/12714553/image2021-4-16_0-6-6.png" width="600"  />
    </p>
<p   
>这个存储的地址就是0x00401037，这时候切到反汇编代码就然后Ctrl+G输入跟进这个地址：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-8-14.png" alt="images/download/attachments/12714553/image2021-4-16_0-8-14.png" width="600"  />
    </p>
<p   
>那这个地址就是Teacher的成员函数Print的地址。</p>
<p   
><strong class=" ">虚表的结构</strong>：虚表中存储的都是函数地址，每个地址占用4个字节，有几个虚函数，则就有几个地址。</p>
<p   
>子类没有重写时，虚表中则只有父类自己的成员函数地址，反之，当子类重写虚函数时候，虚表中则存在父类自己的成员函数地址与子类重写的成员函数地址。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALei_kOeul-espumHjei9vQ">
        <h1 class="heading "><span>&#36816;&#31639;&#31526;&#37325;&#36733;</span></h1>
<p   
>现在有一个类，其中有一个函数用于比较2个类的成员大小：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Number {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Number(</code><code class="keyword">int</code><code class="plain"> x, </code><code class="keyword">int</code><code class="plain"> y) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;x = x;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;y = y;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Max(Number&amp; n) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="keyword">this</code><code class="plain">-&gt;x &gt; n.x &amp;&amp; </code><code class="keyword">this</code><code class="plain">-&gt;y &gt; n.y;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Number a(</code><code class="value">3</code><code class="plain">,</code><code class="value">4</code><code class="plain">),b(</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = a.Max(b);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d \n"</code><code class="plain">, res);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-29-19.png" alt="images/download/attachments/12714553/image2021-4-16_0-29-19.png" width="600"  />
    </p>
<p   
>但是在这里，我们只是比较一下大小，确实用int类型，这有点浪费了，在C++中有一个类型叫bool类型，其返回就是真（1）、假（0），所以我们可以使用这个数据类型。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-32-33.png" alt="images/download/attachments/12714553/image2021-4-16_0-32-33.png" width="600"  />
    </p>
<p   
>bool类型仅占用一个字节：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-33-28.png" alt="images/download/attachments/12714553/image2021-4-16_0-33-28.png" width="400"  />
    </p>
<p   
>这样比较大小，多少还是有点麻烦，如果我们想实现跟其他的数一样直接比较大小该怎么办？直接使用a &gt; b明显是不行的，因为编译器根本不知道你在比较什么。</p>
<p   
>这时候我们就需要使用<strong class=" ">运算符重栽</strong>，使用关键词：operator，例如我们想重载大于符号：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Number {</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> y;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    Number(</code><code class="keyword">int</code><code class="plain"> x, </code><code class="keyword">int</code><code class="plain"> y) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;x = x;</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;y = y;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    bool operator&gt;(Number&amp; n) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="keyword">this</code><code class="plain">-&gt;x &gt; n.x &amp;&amp; </code><code class="keyword">this</code><code class="plain">-&gt;y &gt; n.y;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> main() {</code></div>
<div class="line"><code class="plain">    Number a(</code><code class="value">3</code><code class="plain">,</code><code class="value">4</code><code class="plain">),b(</code><code class="value">1</code><code class="plain">,</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> res = a &gt; b;</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d \n"</code><code class="plain">, res);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>只需要在自定义类里面按照格式重载运算符即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-16_0-39-16.png" alt="images/download/attachments/12714553/image2021-4-16_0-39-16.png" width="600"  />
    </p>
<p   
>也就是说运算符重载，其本质意义就是给重新定义运算符，或者说取一个别名；其在底层上和我们之前的代码是没有任何区别的，其价值就是为了便于写代码。</p>
<p   
>重载其他的运算符：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">Number operator++();</code></div>
<div class="line"><code class="plain">Number operator--();</code></div>
<div class="line"><code class="plain">Number operator+(Number&amp; n);</code></div>
<div class="line"><code class="plain">Number operator-(Number&amp; n);</code></div>
<div class="line"><code class="plain">Number operator*(Number&amp; n);</code></div>
<div class="line"><code class="plain">Number operator/(Number&amp; n);</code></div>
<div class="line"><code class="plain">bool operator&lt;(Number&amp; n);</code></div>
<div class="line"><code class="plain">bool operator==(Number&amp; n);</code></div>
<div class="line"><code class="plain">bool operator&gt;(Number&amp; n) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="keyword">this</code><code class="plain">-&gt;x &gt; n.x &amp;&amp; </code><code class="keyword">this</code><code class="plain">-&gt;y &gt; n.y;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeaooeeJiA">
        <h1 class="heading "><span>&#27169;&#29256;</span></h1>
<p   
>假设有一个冒泡排序的函数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Sort(</code><code class="keyword">int</code><code class="plain">* arr, </code><code class="keyword">int</code><code class="plain"> nLength)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> i, k;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; nLength; i++)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">for</code><code class="plain"> (k = </code><code class="value">0</code><code class="plain">; k &lt; nLength-</code><code class="value">1</code><code class="plain">-i; k++)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain">(arr[k] &gt; arr[k+</code><code class="value">1</code><code class="plain">])   {</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">int</code><code class="plain"> temp = arr[k];</code></div>
<div class="line"><code class="plain">                arr[k] = arr[k+</code><code class="value">1</code><code class="plain">];</code></div>
<div class="line"><code class="plain">                arr[k+</code><code class="value">1</code><code class="plain">] = temp;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>但是这个冒泡排序的函数只能对int类型，如果我们想要使用char类型的时候就要重新写一个函数，这就违背了C++的初衷，重复造轮子了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_11-17-32.png" alt="images/download/attachments/12714553/image2021-4-17_11-17-32.png" width="600"  />
    </p>
<p   
>那么如何避免重复造轮子呢？C++中使用模板来解决这个问题。</p>
<p   
>函数模板的语法是这样的：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">template&lt;</code><code class="keyword">class</code><code class="plain"> 形参名, </code><code class="keyword">class</code><code class="plain"> 形参名,  ...&gt;</code></div>
<div class="line"><code class="plain">返回类型 函数名(参数列表) {</code></div>
<div class="line"><code class="plain">    函数体;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>用模板的方式来修改一下这个冒泡排序函数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">template&lt;</code><code class="keyword">class</code><code class="plain"> T&gt;</code></div>
<div class="line"><code class="keyword">void</code><code class="plain"> Sort(T* arr, </code><code class="keyword">int</code><code class="plain"> nLength)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> i, k;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; nLength; i++)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">for</code><code class="plain"> (k = </code><code class="value">0</code><code class="plain">; k &lt; nLength-</code><code class="value">1</code><code class="plain">-i; k++)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain">(arr[k] &gt; arr[k+</code><code class="value">1</code><code class="plain">])</code></div>
<div class="line"><code class="plain">            {</code></div>
<div class="line"><code class="plain">                T temp = arr[k];</code></div>
<div class="line"><code class="plain">                arr[k] = arr[k+</code><code class="value">1</code><code class="plain">];</code></div>
<div class="line"><code class="plain">                arr[k+</code><code class="value">1</code><code class="plain">] = temp;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>在当前这个函数中我们只有一个地方需要替换修改，所以在写模板关键词时候尖括号内的class形参只有一个，而我们只需要将需要替换的地方改成形参的名字即可。</p>
<p   
>那么模版其原理是什么，编译器做了什么工作呢？我们可以看一下如下代码的反汇编代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_11-34-34.png" alt="images/download/attachments/12714553/image2021-4-17_11-34-34.png" width="600"  />
    </p>
<p   
>使用不同类型的数组传入冒泡排序函数，观察一下执行地址：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_11-33-30.png" alt="images/download/attachments/12714553/image2021-4-17_11-33-30.png" width="600"  />
    </p>
<p   
>可以看见，两个函数的地址完全不一样，这就说明模板的本质就是<strong class=" ">编译器会在看见不同的传入类型时创建不同的函数</strong>。</p>
<p   
>模板除了可以在函数中使用也可以在结构体（类）中使用模板，其格式如下所示：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">template&lt;</code><code class="keyword">class</code><code class="plain"> 形参名, </code><code class="keyword">class</code><code class="plain"> 形参名,  ...&gt;</code></div>
<div class="line"><code class="keyword">class</code><code class="plain"> 类名 {</code></div>
<div class="line"><code class="plain">    ...;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如下代码，一个结构体，有两个成员函数，一个是比较返回最大的数，一个则是最小的数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct Base {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> x;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> y;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> Max() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (a&gt;b) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> Min() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (x&lt;y) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> x; </code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>但这个结构体已经指定了成员变量的数据宽度int、char，而我们想要比较任意类型的话，可以使用模板改造下这段代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">template&lt;</code><code class="keyword">class</code><code class="plain"> T, </code><code class="keyword">class</code><code class="plain"> M&gt;</code></div>
<div class="line"><code class="plain">struct Base {</code></div>
<div class="line"><code class="plain">    T a;</code></div>
<div class="line"><code class="plain">    T b;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    M x;</code></div>
<div class="line"><code class="plain">    M y;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    T Max() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (a&gt;b) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> a;</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> b;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    M Min() {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (x&lt;y) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> x; </code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> y;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>这个模板想使用的话，我们就需要告诉编译器模板中的T、M分别对应什么，所以如果直接使用Base b;则无法编译。</p>
<p   
>使用如下格式即可：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">Base&lt;</code><code class="keyword">int</code><code class="plain">, </code><code class="keyword">char</code><code class="plain">&gt; b;</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_15-11-54.png" alt="images/download/attachments/12714553/image2021-4-17_15-11-54.png" width="600"  />
    </p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALee6r-iZmuWHveaVsA">
        <h1 class="heading "><span>&#32431;&#34394;&#20989;&#25968;</span></h1>
<p   
></p>
<p   
>之前学习过虚函数，也提到了纯虚函数，虽然纯虚函数语法很简单的，但是其比较难理解，所以在有一定的面向对象的基础时候再来学习会比较容易理解一些。</p>
<p   
>纯虚函数语法：</p>
<ol class=" "><li class=" "><p   
>将成员函数声明为 virtual</p>
</li><li class=" "><p   
>该函数没有函数体，最后跟<strong class=" ">=0</strong></p>
</li></ol>    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> Base {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    virtual </code><code class="keyword">int</code><code class="plain"> Plus() = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>语法不过多的阐述，之前也有写过；接下来我们要了解一个新的概念：抽象类。</p>
<p   
>抽象类有这几种特征：</p>
<ol class=" "><li class=" "><p   
>含有纯虚函数的类，称之为<strong class=" ">抽象类</strong>；</p>
</li><li class=" "><p   
>抽象类也可以包含普通的函数；</p>
</li><li class=" "><p   
>抽象类不能实例化（创建对象）。</p>
</li></ol><p   
>那么问题来了，抽象类有什么意义呢？我们可以把抽象类看作是对子类的一种约束，或者认为其（抽象类）就是定义一种标准。</p>
<p   
><strong class=" ">比如</strong>：淘宝，有很多店铺，虽然每个店铺卖的东西都不一样，但是他们同样都可以下单、评论、购物车，也就是说他们都遵守了这种标准规则；也就是说你可以把淘宝当作一个抽象类，其有很多成员：购物车、评论、商品展示区...但是他都没有定义，而是交给开淘宝店的人（子类）去根据标准规则定义。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_16-20-55.png" alt="images/download/attachments/12714553/image2021-4-17_16-20-55.png" width="600"  />
    </p>
<p   
>而如果不按照这种标准呢来，那么假如要统计所有的数据就会非常麻烦，不便于管理。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWvueixoeaLt-i0nQ">
        <h1 class="heading "><span>&#23545;&#35937;&#25335;&#36125;</span></h1>
<p   
>我们通常存储对象，都用数组、列表之类的来存储，那如下所示我们使用数组来存储对象，但是在工作中发现这个数组不够用了，就需要一个更大的数据，但我们重新创建一个数组还需要把原来的数据复制过来；在C语言中可以使用函数来进行拷贝，直接拷贝内存，在C++中实际上跟C语言要做的事情是一样的，在C++中就称之为<strong class=" ">对象拷贝</strong>。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_18-50-20.png" alt="images/download/attachments/12714553/image2021-4-17_18-50-20.png" width="400"  />
    </p>
    <div class="section section-2" id="src-12714553_safe-id-QyAg6K-t6KiALeaLt-i0neaehOmAoOWHveaVsA">
        <h2 class="heading "><span>&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;</span></h2>
<p   
>如何在C++中拷贝构造函数，来看一下如下代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_19-1-10.png" alt="images/download/attachments/12714553/image2021-4-17_19-1-10.png" width="600"  />
    </p>
<p   
>可以看见我们定义了一个类，然后创建了两个对象obj、objNew，但是第二个对象的语法很奇怪，传入的参数是第一对象，其实这就是默认拷贝析构函数。</p>
<p   
>其本质就是很简单的内存复制：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_20-4-58.png" alt="images/download/attachments/12714553/image2021-4-17_20-4-58.png" width="400"  />
    </p>
<p   
>上面的内存复制是在栈中，而我们想在堆中去拷贝可以这样写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CObject* p = </code><code class="keyword">new</code><code class="plain"> CObject(obj);</code></div>
</div>
    </div>
<p   
>如上所示，我们是通过拷贝析构函数在内存中创建了一个新的对象，而如果该类本身有一个父类，父类会被拷贝吗？我们写一段代码来论证一下：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_22-28-37.png" alt="images/download/attachments/12714553/image2021-4-17_22-28-37.png" width="600"  />
    </p>
<p   
>那么这段代码，拷贝构造函数不仅可以将当前对象的内容复制，还可以将父类的内容复制过来。</p>
<p   
>拷贝构造函数是编译器已经提供的，其已经非常成熟了，通常情况下是不建议自己写拷贝构造函数的，除非出现类中包含指针类型的成员，这种情况是需要自己重些拷贝构造函数的，因为拷贝构造函数只是会拷贝当前指针成员的值，并不会拷贝指针成员指向的内容。</p>
<p   
>所以这种拷贝方式，我们可以称之为<strong class=" ">浅拷贝</strong>；而如果可以做到能够复制成员的情况下，还可以将指针指向的内存地址复制过来，并自动申请一块新的内存提供，这种方式我们称之为<strong class=" ">深拷贝</strong>。</p>
<p   
>如果要实现深拷贝，我们就需要自己重写拷贝构造函数。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">MyObject(</code><code class="keyword">const</code><code class="plain"> MyObject&amp; obj) {</code></div>
<div class="line"><code class="plain">    m_nLength = obj.m_nLength;</code></div>
<div class="line"><code class="plain">    m_strBuffer = </code><code class="keyword">new</code><code class="plain"> </code><code class="keyword">char</code><code class="plain">[m_nLength];</code></div>
<div class="line"><code class="plain">    memset(m_strBuffer, </code><code class="value">0</code><code class="plain">, m_nLength);</code></div>
<div class="line"><code class="plain">    strcpy(m_strBuffer, obj.m_strBuffer);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-17_23-48-7.png" alt="images/download/attachments/12714553/image2021-4-17_23-48-7.png" width="600"  />
    </p>
<p   
>需要注意的是这个格式是固定的，不要自己「自由发挥」。</p>
<p   
>总结：</p>
<ol class=" "><li class=" "><p   
>如果不需要深拷贝，就不要自己添加拷贝构造函数；</p>
</li><li class=" "><p   
>如果你天假了拷贝构造函数，那么编译器将不再提供，所有的事情都需要由新添加的函数自己来处理。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714553_safe-id-QyAg6K-t6KiALemHjei9vei1i-WAvOi_kOeul-espg">
        <h2 class="heading "><span>&#37325;&#36733;&#36171;&#20540;&#36816;&#31639;&#31526;</span></h2>
<p   
>上一章学习了如何通过拷贝对象函数的方式来实现对象拷贝，这里就来学习使用重载赋值运算符实现对象拷贝。</p>
<p   
>在C++中是允许我们在两个对象之间直接使用赋值运算符的：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CObject a(</code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">), b(</code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">b = a;</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_16-26-21.png" alt="images/download/attachments/12714553/image2021-4-18_16-26-21.png" width="600"  />
    </p>
<p   
>那么赋值运算符实现的对象复制是否会当前复制对象继承的父类进行复制呢？</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_16-36-55.png" alt="images/download/attachments/12714553/image2021-4-18_16-36-55.png" width="600"  />
    </p>
<p   
>如上图所示，赋值运算符是可以复制父类的。</p>
<p   
>但是在这里赋值运算符是否就非常完美了呢？不是的，赋值运算符和拷贝构造函数是有相同缺点的，那就是其默认都是<strong class=" ">浅拷贝</strong>。</p>
<p   
>我们想要解决这个问题就需要重写一个赋值运算符，自己来实现<strong class=" ">深拷贝</strong>。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_21-45-51.png" alt="images/download/attachments/12714553/image2021-4-18_21-45-51.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWPi-WFgw">
        <h1 class="heading "><span>&#21451;&#20803;</span></h1>
<p   
>友元可以理解为：朋友、元素；<strong class=" ">老师认为这个友元是C++中的一个垃圾，因为友元的存在破坏了面向对象的封装性，不推荐使用，之所以有这个章节是因为有人不了解这个概念</strong>。</p>
<p   
>注意：在一些新版本的C++编译器里面已经不再提供类似于友元这样的特性了。</p>
<p   
>大家都知道在C++中对象的私有成员，外部是无法访问的，这在面向对象中是很正常的，如果你想访问按照正常的逻辑你应该在类中声明成员函数去增删改查这个私有成员。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_21-54-57.png" alt="images/download/attachments/12714553/image2021-4-18_21-54-57.png" width="600"  />
    </p>
<p   
>友元的诞生就是破坏了这个封装性，让你可以在外部去使用这个私有成员。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_21-56-54.png" alt="images/download/attachments/12714553/image2021-4-18_21-56-54.png" width="600"  />
    </p>
<p   
>友元的语法就是：friend 返回类型 函数名(参数列表)</p>
<p   
><strong class=" ">老师个人认为C++之所以有友元是因为这是C++作者面向过程的一种妥协，这是因为C++是先有的C才有的C++，而很多人已经很熟悉C语言的语法了，你这时候推出一个新的概念，是对开发者的不友好（代码重构、学习代码），所以要妥协。</strong></p>
<p   
>刚刚举例说明的是友元函数，就是告诉编译器这个函数是我的朋友，可以访问我的任何成员。</p>
<p   
>除了友元函数，还有加强版的垃圾：友元类，如下是语法格式：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">class</code><code class="plain"> CObject {</code></div>
<div class="line"><code class="plain">    friend </code><code class="keyword">class</code><code class="plain"> Test;</code></div>
<div class="line"><code class="keyword">private</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x;</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    CObject() {}</code></div>
<div class="line"><code class="plain">    CObject(</code><code class="keyword">int</code><code class="plain"> x) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">this</code><code class="plain">-&gt;x = x;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">class</code><code class="plain"> Test {</code></div>
<div class="line"><code class="keyword">public</code><code class="plain">:</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">void</code><code class="plain"> Fun(CObject* c) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"%d \n"</code><code class="plain">, c-&gt;x);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>以上代码就是告诉编译器，Test是CObject的朋友，所以Test可以直接访问CObject的私有成员；但是要注意的是，这种访问是单向的，Test可以访问CObject，但反之则不行。</p>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWGhemDqOexuw">
        <h1 class="heading "><span>&#20869;&#37096;&#31867;</span></h1>
<p   
>内部类，简单的说就是在别的类里面定义的类就是内部类。</p>
<ul class=" "><li class=" "><p   
>大小：当前类和其内部类不存在包含关系，不会影响当前类的大小；</p>
</li></ul><p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_22-12-59.png" alt="images/download/attachments/12714553/image2021-4-18_22-12-59.png" width="600"  />
    </p>
<ul class=" "><li class=" "><p   
>关系：两者之间不存在什么特殊关系，也无法访问对方的私有成员；</p>
</li></ul><p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_22-14-8.png" alt="images/download/attachments/12714553/image2021-4-18_22-14-8.png" width="600"  />
    </p>
<ul class=" "><li class=" "><p   
>声明：声明创建内部类需要使用格式 &rarr; <strong class=" ">类::内部类 名称;</strong>；</p>
</li><li class=" "><p   
>权限：如果你的内部类不想外部创建对象，那就定义到private内即可；而如果你用到这个内部类的情况非常的少，例如你只有一个成员函数需要使用到，那么完全可以定义到这个函数内；</p>
</li><li class=" "><p   
>作用：如果我们需要实现一些功能而用到一个类，但是其他的模块、类用不到，我们可以就把这个类写到当前所需要使用类中。（<strong class=" ">隐藏</strong>）</p>
</li></ul>    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALeWRveWQjeepuumXtA">
        <h1 class="heading "><span>&#21629;&#21517;&#31354;&#38388;</span></h1>
<p   
>命名空间主要是用来解决命名冲突的问题；比如你定义了一个函数叫Fun，而如果你还想定一个函数也叫Fn，这种情况下就可以使用命名空间来解决这个问题。</p>
<p   
>命名空间的关键词：namespace，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">namespace 名称x {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 全局变量</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 函数</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 类</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">namespace 名称y {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 全局变量</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 函数</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 类</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_22-29-34.png" alt="images/download/attachments/12714553/image2021-4-18_22-29-34.png" width="600"  />
    </p>
<p   
>调用也很简单，使用格式：<strong class=" ">命名空间名称::函数\变量\类</strong></p>
<p   
>如果我们命名空间内的东西非常多，但是你要调用就必须要加上前缀，这时候你可以在代码的首行写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">using namespace x;</code></div>
</div>
    </div>
<p   
>但这也会引起命名冲突，如果命名空间x里面有一个Test函数，但是在正常代码中也存在Test函数，你想调用的是本身的该怎么办呢？实际上在C++中，你定义的所有东西都存在一个全局命名空间，而想调用可以使用如下语法：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">::Test();</code></div>
</div>
    </div>
    </div>
    <div class="section section-1" id="src-12714553_safe-id-QyAg6K-t6KiALXN0YXRpY-WFs-mUruWtlw">
        <h1 class="heading "><span>static&#20851;&#38190;&#23383;</span></h1>
<p   
>用static就是一个全局变量，只不过它是一个私有的全局变量。</p>
<p   
>在面向过程(没有对象的概念，用函数)中的static：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Func() {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> </code><code class="keyword">char</code><code class="plain"> strBuffer[</code><code class="value">0x10</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    strcpy(strBuffer, </code><code class="string">"test"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>用static声明的全局变量，只有当前函数能访问；我们可以看下反汇编代码来论证这是一个全局变量：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_23-7-0.png" alt="images/download/attachments/12714553/image2021-4-18_23-7-0.png" width="400"  />
    </p>
<p   
>如上图所示的这个内存地址，很明显就是一个全局区的地址（<strong class=" ">这也就表示相同变量只能申请一次，不再接受第二次申请，也就表示全局变量应用场景，你可以用这个关键词来实现</strong>）。</p>
<p   
>面向对象设计中的static之静态数据成员：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_23-12-45.png" alt="images/download/attachments/12714553/image2021-4-18_23-12-45.png" width="600"  />
    </p>
<p   
>面向对象设计中的static之静态成员函数：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_23-23-52.png" alt="images/download/attachments/12714553/image2021-4-18_23-23-52.png" width="600"  />
    </p>
<p   
>static的经典应用：单子模式；有些时候我们希望定义的类只能有一个对象存在，这时候你该如何限制呢？实现思路有两个：</p>
<ol class=" "><li class=" "><p   
>禁止对象被随便创建</p>
</li><li class=" "><p   
>保证对象只有一个存在</p>
</li></ol><p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714553/image2021-4-18_23-30-12.png" alt="images/download/attachments/12714553/image2021-4-18_23-30-12.png" width="600"  />
    </p>
<p   
></p>
<p   
></p>
<p   
></p>
<p   
></p>
<p   
></p>
<p   
></p>
<p   
></p>
<p   
></p>
    </div>
        </div>

    </article>


            <nav id="ht-post-nav">
                <a href="C%E8%AF%AD%E8%A8%80.html" class="ht-post-nav-prev">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-prev" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-45.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>C&#35821;&#35328;</span>
        </a>
                <a href="Win32.html" class="ht-post-nav-next">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-next" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-225.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>Win32</span>
        </a>
    </nav>    
            
    <footer id="ht-footer">
    <a href="#" id="ht-jump-top" class="sp-aui-icon-small sp-aui-iconfont-arrows-up"></a>
</footer></div>

<div>
    <div id="ht-mq-detect"></div>
</div>

    <script src="js/lunr.js"></script>
    <script src="js/lunr-extras.js"></script>
    <script src="assets/js/scroll-search.js"></script>

    <script src="assets/js/expand-macro.js"></script>
</body>
</html>
