<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Win32 - &#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</title>

    
    <link rel="stylesheet" href="assets/css/expand-macro.css">

            <meta name="scroll-content-language-key" content="">
    
    <meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=2.0, user-scalable=yes">

<script type="text/javascript" src="assets/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/js/jquery.scrollTo.min.js"></script>


<script type="text/javascript" src="assets/js/translate.js"></script>


<script type="text/javascript" src="assets/js/scroll-tree.js"></script>

<script type="text/javascript" src="assets/js/theme.main.js"></script>

    <script type="text/javascript" src="assets/js/iframeResizer.min.js"></script>

<link rel="stylesheet" href="assets/css/content-style.css">
    <link rel="stylesheet" href="assets/css/search.css">

<link rel="stylesheet" href="assets/css/theme.main.css">
<link rel="stylesheet" href="assets/css/theme.colors.css">

            <!-- ES5 support for older browsers, needed by lunr -->
        <script src="js/augment.js"></script>
        <script id="worker" type="javascript/worker">

        startIndex = function() {
            idx = lunr.Index.load(lunrIndex);
            idx.pipeline.remove(lunr.stopWordFilter);
            postMessage({type: "setup-complete"});
        }

        onmessage = function (event) {
            var message = event.data;

            if ((message.type === 'setup') && message.baseUrl) {
                var url = message.baseUrl;
                importScripts(url + 'js/lunr.js');
                importScripts(url + 'js/lunr-extras.js');
                importScripts(url + 'js/lunr-index.js');
                importScripts(url + 'js/lunr-data.js');
                startIndex();
            }

            if (idx && (message.type === 'search-request') && message.query) {
                var searchWord = message.query;
                var results = idx.search(searchWord).map(function (result) {
                    return lunrData.filter(function (d) {
                        return d.id === parseInt(result.ref, 10)
                    })[0]
                });
                postMessage({type: 'search-results', results: results, query: searchWord, queryId: message.queryId});
            }
        }

    </script>
    </head>

<body pageid="8684305">

<div id="ht-loader">
    <noscript>
        <p style="width: 100%; text-align:center; position: absolute; margin-top: 200px;">This content cannot be displayed without JavaScript.<br>Please enable JavaScript and reload the page.</p>
    </noscript>
</div>

<div>
   	<header id="ht-headerbar">
    <div class="ht-headerbar-left">
        <a href="" id="ht-menu-toggle" class="sp-aui-icon-small sp-aui-iconfont-appswitcher"></a>
    </div>
    <div class="ht-headerbar-right">
            <div class="sp-aui-icon-small ht-search-index-loader ht-header-icon"></div>

        <div id="ht-search">
            <div class="ht-search-input" style="display: none;">
              	<a href="#" class="sp-aui-icon-small sp-aui-iconfont-remove ht-search-clear"></a>

                <form action="#" method="GET" id="search">
                    <input class="search-input" type="text" placeholder="Search" tabindex="-1" autocomplete="off" name="q" value="">
                    <input type="hidden" name="max" value="15" />
                    <input type="submit" style="display:none" tabindex="-4"/>
                </form>

                <a href="#" id="ht-search-button" class="ht-header-icon ht-header-icon-svg">
                                        <svg width="40px" height="40px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <g>
                            <path d="M29.572,28.802 L28.801,29.571 C28.515,29.857 28.187,30 27.816,30 C27.445,30 27.116,29.857 26.831,29.571 L21.392,24.134 C20.193,24.762 18.908,25.076 17.538,25.076 C15.396,25.076 13.605,24.348 12.163,22.892 C10.721,21.436 10,19.651 10,17.538 C10,15.397 10.721,13.605 12.163,12.163 C13.605,10.721 15.396,10 17.538,10 C19.651,10 21.434,10.721 22.89,12.163 C24.347,13.605 25.075,15.397 25.075,17.538 C25.075,18.937 24.761,20.222 24.132,21.393 L29.572,26.832 C29.857,27.118 30,27.446 30,27.817 C30,28.188 29.857,28.517 29.572,28.802 L29.572,28.802 Z M13.662,21.414 C14.732,22.485 16.024,23.02 17.538,23.02 C19.051,23.02 20.343,22.485 21.413,21.414 C22.484,20.344 23.019,19.052 23.019,17.538 C23.019,16.025 22.484,14.733 21.413,13.662 C20.343,12.592 19.051,12.056 17.538,12.056 C16.024,12.056 14.732,12.592 13.662,13.662 C12.591,14.733 12.056,16.025 12.056,17.538 C12.056,19.052 12.591,20.344 13.662,21.414 L13.662,21.414 Z"></path>
                        </g>
                    </svg>
              	</a>

                <div class="ht-search-dropdown ht-dropdown">
                    <ul></ul>
                </div>
            </div>
        </div>
    </div>
    </header>   	<aside id="ht-sidebar">
    <div class="ht-sidebar-content">
        <div class="ht-sidebar-content-scroll-container">
            <header class="ht-sidebar-header">
                <h1 class="ht-logo">
                    <span class="ht-logo-label">BinaryLearning</span>
                    <img class="space-logo" src="global.logo" />
                </h1>
                <a href="Binary-Learning.html" class="ht-space-link">
                    <h2>&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</h2>
                </a>
                <p><br>ᴀᴜᴛʜᴏʀ: ᴋᴇʏ<br><br>不积跬步，无以至千里；<br>不积小流，无以成江海。</p>
            </header>
                            <iframe id="ht-nav" src="toc.html?pageId=12714992"></iframe>
                <script>
                    $('iframe#ht-nav').iFrameResize(
                            { 'log': true, 'autoResize': true, 'heightCalculationMethod': 'lowestElement', 'checkOrigin': false });
                </script>
                    </div>
    </div>

</aside></div>

<div id="ht-wrap-container">

            
    <div id="ht-sidebar-dragbar">
    <div class="ht-sidebar-drag-handle">
        <span class="drag-handle-1"></span>
        <span class="drag-handle-2"></span>
        <span class="drag-handle-3"></span>
    </div>
</div>
    <article id="ht-content" class="ht-content">
        <header class="ht-content-header">
            <div id="ht-breadcrumb">
    <ul>
        <li><a href="Binary-Learning.html">&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</a></li>
                                                                                     <li><a href="%E5%88%9D%E7%BA%A7%E7%AF%87.html">&#21021;&#32423;&#31687;</a></li>
                                                            </ul>
</div>            <h1 id="src-12714992"> <span>Win32</span></h1>
        </header>

        <div id="main-content" class="wiki-content sp-grid-section" data-index-for-search="true">

    <div class="section section-1" id="src-12714992_safe-id-V2luMzItV2luMzLor77nqIvku4vnu40">
        <h1 class="heading "><span>Win32&#35838;&#31243;&#20171;&#32461;</span></h1>
<p   
>很多人对Win32的认识是错误的，他们认为Win32就是画界面，都已经学MFC了还学什么Win32？</p>
<p   
>Win32不是用来画界面的，如果你以后要在Windows写好程序，是必须要学Win32的；摆正学习态度。</p>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5a2X56ym57yW56CB">
        <h1 class="heading "><span>&#23383;&#31526;&#32534;&#30721;</span></h1>
<p   
>我们会经常接触到各种各样的字符编码，本章节就来讲解一下常见的编码。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Y6f5aeL55qEQVNDSUnnvJbnoIE">
        <h2 class="heading "><span>&#21407;&#22987;&#30340;ASCII&#32534;&#30721;</span></h2>
<p   
>计算机是由美国人发明的，所以一开始设计编码的时候只会考虑到自身的元素，采用ASCII编码完全可以满足其需求，但是计算机普及之后，很多国家的文字是象形文字，所以我们使用ASCII编码是无法满足需求的。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_0-3-42.png" alt="images/download/attachments/12714992/image2021-5-17_0-3-42.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItQVNDSUnnvJbnoIHnmoTmi5PlsZXvvJpHQjIzMTLmiJZHQjIzMTItODA">
        <h2 class="heading "><span>ASCII&#32534;&#30721;&#30340;&#25299;&#23637;&#65306;GB2312&#25110;GB2312-80</span></h2>
<p   
>由于ASCII编码无法满足需求，所以在其基础上进行扩展，大家都知道ASCII编码只有0-127，用十六进制表示是0x00-0x7F，而之后的0x80-0xFF在标准的ASCII编码中是不存在的，所以就出现了我们所说的ASCII编码的扩展。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_0-7-45.png" alt="images/download/attachments/12714992/image2021-5-17_0-7-45.png" width="600"  />
    </p>
<p   
>但是这样能满足中文、韩文这种象形文字吗？其实并不可以，如上这张表实际上使用频率很低，而这时候GB2312编码（<strong class=" ">该编码与GBK没有什么本质区别，无非就是收录的汉字和图形符号的区别：GB2312标准共收录6763个汉字，GBK共收入21886个汉字和图形符号</strong>）考虑到这个因素就占用了这张表，那么是怎么占用的呢？其本质就是创建两张如上图所示的表，然后进行拼接，两个字节加起来就组成一个新的中文文字。</p>
<p   
>例如：中国的&ldquo;中&rdquo;这个字，就是0xD0和0xD6拼接起来的。这种编码是否存在问题？这是必然的，我们已经知道了该编码的设计原理，假设我们将&ldquo;中国&rdquo;这两个字发给国外的朋友，他的电脑上并没有该编码表，所以解析出来的则不会是汉字，而会出现大家所熟知的&ldquo;乱码&rdquo;。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItVW5pY29kZee8lueggQ">
        <h2 class="heading "><span>Unicode&#32534;&#30721;</span></h2>
<p   
>为了解决ASCII的缺陷，Unicode编码就诞生了，那么Unicode是如何解决这一问题的呢？</p>
<p   
>其实很简单，Unicode编码创建了一张包含世界上所有文字的编码表，只要世界上存在的文字符号，都会赋予一个唯一的编码。</p>
<p   
>Unicode编码的范围是：0x0-0x10FFFF，其可以容纳100多万个符号，但是Unicode本身也存在问题，因为Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何去存储。</p>
<p   
>假设中这个字以Unicode方式表示占2个字节，而国这个字却占4个，这个时候你该如何去存储？</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItVW5pY29kZeWtmOWCqOeahOWunueOsOaWueW8jw">
        <h2 class="heading "><span>Unicode&#23384;&#20648;&#30340;&#23454;&#29616;&#26041;&#24335;</span></h2>
    <div class="section section-3" id="src-12714992_Win32-UTF-16">
        <h3 class="heading "><span>UTF-16</span></h3>
<p   
>UTF-16/UTF-8是Unicode存储的实现方式；UTF-16编码是以16个无符号整数位单位，注意是16位为一个单位，但不表示一个字符就只有16位，具体的要看字符的Unicode编码所在范围，有可能是2字节，有可能是4字节，<strong class=" ">现在机器上的Unicode编码一般指的就是UTF-16</strong>。</p>
<p   
>我们举个例子（虚构）：</p>
<p   
>中（Unicode编码）：0x1234</p>
<p   
>国（Unicode编码）：0x12345</p>
<p   
>UTF-16存储的时候，&ldquo;中&rdquo;这个字肯定是存储的0x1234，但是&ldquo;国&rdquo;这个字就不一样， 我们知道UTF-16是16位（2字节）为一个单位，所以国这个字拆下来存储应该是0x00 0x01 0x23 0x45。</p>
<p   
>UTF-16的优点一看便知：计算、拆分、解析非常方便，2个字节为一个单位，一个一个来。</p>
<p   
>UTF-16是否是最优解呢？其实不然，我们通过如上的例子中可以看到一个很明显的缺点，<strong class=" ">那就是UTF-16会存在浪费空间的情况，因为其16位（2字节）为一个单位，它需要字节对齐，例如字母A只需要一个字节就可以表示，而使用UTF-16时就会变成2个字节，所以很浪费，而这时候UTF-8横空出世</strong>。（UTF-16在本地存储是没有啥问题的，顶多就是浪费一点硬盘空间，但是如果在网络中传输，那就太过于浪费了）</p>
    </div>
    <div class="section section-3" id="src-12714992_Win32-UTF-8">
        <h3 class="heading "><span>UTF-8</span></h3>
<p   
>UTF-8称之为可变长存储方案，其存储根据字符大小来分配，例如字母A就分配一个字节，汉字&ldquo;中&rdquo;就分配两个字节。</p>
<p   
>优点：节省空间；缺点：解析很麻烦。</p>
<p   
>UTF-8存储的方式是有对应表的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_0-46-57.png" alt="images/download/attachments/12714992/image2021-5-17_0-46-57.png" width="400"  />
    </p>
<p   
>例如字母A，在0x000000 - 0x00007F范围之间，则采用0XXXXXX的方式进行存储，也就是按照一个字节的方式来不会改变什么，而汉字&rdquo;中&ldquo;则不一样了。</p>
<p   
>中（Unicode编码）：0x4E 0x2D，它属于0x000800 - 0x00FFFF范围之间。</p>
<p   
>0x4E 0x2D = 0100 1110 0010 1101，其以UTF-8的方式存储就是1110 (0100) 10(11 1000) 10(10 1101)，括号包裹起来的就是汉字&ldquo;中&rdquo;的Unicode编码。</p>
<p   
>最后一个问题，假设我们把UTF-8的文本格式发给对方，那对方如果按照UTF-16的方式去解析该怎么办？如何让对方只采用UTF-8的方式去解析呢？</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItQk9N77yIQnl0ZU9yZGVyTWFya--8iQ">
        <h2 class="heading "><span>BOM&#65288;Byte Order Mark&#65289;</span></h2>
<p   
>BOM中文为字节顺序标记，其就是用来插入到文本文件起始位置开头的，用于识别Unicode文件的编码类型。</p>
<p   
>对应关系如下：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-1-28.png" alt="images/download/attachments/12714992/image2021-5-17_1-1-28.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzItQ-ivreiogOS4reeahOWuveWtl-espg">
        <h1 class="heading "><span>C&#35821;&#35328;&#20013;&#30340;&#23485;&#23383;&#31526;</span></h1>
<p   
>本章主要是讲解在C语言中如何使用上一章所述的编码格式表示字符串。</p>
<p   
>ASCII码：char strBuff[] = &quot;中国&quot;;</p>
<p   
>Unicode编码（UTF-16）：wchar_t strBuff[] = L&quot;中国&quot;; // 这里需要在双引号之前加上L是因为如果你不加的话，编译器会默认使用当前文件的编码格式去存储，所以我们需要加上。（注意使用这个的时候需要包含stdio.h这个头文件）</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-27-44.png" alt="images/download/attachments/12714992/image2021-5-17_1-27-44.png" width="600"  />
    </p>
<p   
><strong class=" ">Unicode编码这种表现形式实际上就是宽字符，所以在提起宽字符的时候我们就应该想到这种方式。</strong></p>
<p   
>ASCII编码和Unicode编码在内存中的存储方式不一样，所以我们使用相关函数的时候也要注意，如下图所示，ASCII编码使用左边的，而Unicode则是右边的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-12-0.png" alt="images/download/attachments/12714992/image2021-5-17_1-12-0.png" width="500"  />
    </p>
<p   
>例如我们想要在控制台中打印一个宽字符的字符串：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-18-46.png" alt="images/download/attachments/12714992/image2021-5-17_1-18-46.png" width="600"  />
    </p>
<p   
>再一个例子就是字符串的长度：</p>
    <div  class="confbox admonition admonition-info">
                            <span class="admonition-icon confluence-information-macro-icon"></span>
                <div class="admonition-body">
<p   
>char strBuff[] = &quot;China&quot;;</p>
<p   
>wchar_t strBuff1[] = L&quot;China&quot;;</p>
<p   
>strlen(strBuff); //取得多字节字符串中字符长度，不包含 00</p>
<p   
>wcslen(strBuff1); //取得多字节字符串中字符长度，不包含 00 00</p>
        </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzItV2luMzJBUEnkuK3nmoTlrr3lrZfnrKY">
        <h1 class="heading "><span>Win32 API&#20013;&#30340;&#23485;&#23383;&#31526;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LqG6Kej5LuA5LmI5pivV2luMzJBUEk">
        <h2 class="heading "><span>&#20102;&#35299;&#20160;&#20040;&#26159;Win32 API</span></h2>
<p   
>Win32 API就是Windows操作系统提供给我们的函数（应用程序接口），其主要存放在C:\Windows\System32（存储的DLL是64位）、C:\Windows\SysWOW64（存储的DLL是32位）下面的所有DLL文件（几千个）。</p>
<p   
>重要的DLL文件：</p>
<ol class=" "><li class=" "><p   
>Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等；</p>
</li><li class=" "><p   
>User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等；</p>
</li><li class=" "><p   
>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</p>
</li></ol><p   
>在C语言中我们想要使用Win32 API的话直接在代码中包含windows.h这个头文件即可。</p>
<p   
>比如我们想要弹出一个提示窗口，Win32 API文档中弹窗API的格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> MessageBox(</code></div>
<div class="line"><code class="plain">    HWND hWnd,          </code><code class="comments">// handle to owner window</code></div>
<div class="line"><code class="plain">    LPCTSTR lpText,     </code><code class="comments">// text in message box</code></div>
<div class="line"><code class="plain">    LPCTSTR lpCaption,  </code><code class="comments">// message box title</code></div>
<div class="line"><code class="plain">    UINT uType          </code><code class="comments">// message box style</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>这个代码可能看起来非常可怕，好像我们都没有接触过，<strong class=" ">但实际上其不是什么新的类型，所谓的新的类型无非就是给原有的类型重新起了一个名字，这样做是为了将所有类型统一化，便于读写，如果涉及到跨平台的话将原来的类型修改一下就好了，无需对代码进行重写</strong>。</p>
<p   
>例如以上代码中的类型LPCTSTR，实际上我们跟进一下代码（选中F12）会发现其本质就是const char *这个类型，只不过是换了一个名字罢了。</p>
<p   
>常用的数据类型在Win32中都重新起了名字：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-43-48.png" alt="images/download/attachments/12714992/image2021-5-17_1-43-48.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5ZyoV2luMzLkuK3kvb_nlKjlrZfnrKbkuLI">
        <h2 class="heading "><span>&#22312;Win32&#20013;&#20351;&#29992;&#23383;&#31526;&#20018;</span></h2>
<p   
>字符类型：</p>
    <div  class="confbox admonition admonition-info">
                            <span class="admonition-icon confluence-information-macro-icon"></span>
                <div class="admonition-body">
<p   
>CHAR strBuff[] = &quot;中国&quot;; // char</p>
<p   
>WCHAR strBuff[] = L&quot;中国&quot;; // wchar_t</p>
<p   
>TCHAR strBuff[] = TEXT(&quot;中国&quot;); // TCHAR 根据当前项目的编码自动选择char还是wchar_t，在Win32中推荐使用这种方式</p>
        </div>
    </div>
<p   
>字符串指针:</p>
    <div  class="confbox admonition admonition-info">
                            <span class="admonition-icon confluence-information-macro-icon"></span>
                <div class="admonition-body">
<p   
>PSTR strPoint = &quot;中国&quot;; // char*</p>
<p   
>PWSTR strPoint = L&quot;中国&quot;; // wchar_t*</p>
<p   
>PTSTR strPoint = TEXT(&quot;中国&quot;); // PTSTR 根据当前项目的编码自动选择如char*还是wchar_t*，在Win32中推荐使用这种方式</p>
        </div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5L2_55SoV2luMzJBUEnlvLnmoYY">
        <h2 class="heading "><span>&#20351;&#29992;Win32 API&#24377;&#26694;</span></h2>
<p   
>之前我们了解到Win32 API中的弹框，其名称为MessageBox，其实际上本质就是MessageBoxW和MessageBoxA：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_1-51-13.png" alt="images/download/attachments/12714992/image2021-5-17_1-51-13.png" width="400"  />
    </p>
<p   
>MessageBoxA只接受ASCII编码的参数，而MessageBoxW则只接受Unicode编码的参数。</p>
<p   
>从本质上来讲，Windows字符串都是宽字符的，所以<strong class=" ">使用MessageBoxW这种方式性能会更好一些</strong>，因为当你使用MessageBoxA的时候，在到内核的时候（系统底层）其会转化Unicode，所以性能相对差一些。</p>
<p   
>弹框调用如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">CHAR strTitle[] = </code><code class="string">"Title"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">CHAR strContent[] = </code><code class="string">"Hello World!"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">MessageBoxA(</code><code class="value">0</code><code class="plain">, strContent, strTitle, MB_OK);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">WCHAR strTitle[] = L</code><code class="string">"Title"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">WCHAR strContent[] = L</code><code class="string">"Hello World!"</code><code class="plain">;</code></div>
<div class="line"><code class="plain">MessageBoxW(</code><code class="value">0</code><code class="plain">, strContent, strTitle, MB_OK);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">TCHAR strTitle[] = TEXT(</code><code class="string">"Title"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">TCHAR strContent[] = TEXT(</code><code class="string">"Hello World!"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">MessageBox(</code><code class="value">0</code><code class="plain">, strContent, strTitle, MB_OK);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_2-3-22.png" alt="images/download/attachments/12714992/image2021-5-17_2-3-22.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6L-b56iL55qE5Yib5bu66L-H56iL">
        <h1 class="heading "><span>&#36827;&#31243;&#30340;&#21019;&#24314;&#36807;&#31243;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv6L-b56iL">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#36827;&#31243;</span></h2>
<p   
>程序所需要的资源（数据、代码...）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</p>
<p   
>每一个进程都有自己的一个4GB大小的虚拟空间，也就是从0x0-0xFFFFFFFF这个范围。</p>
<p   
>进程内存空间的地址划分如下，每个进程的内核是同一份（高2G），只有其他三个分区是进程独有的（低2G），而只有用户模式区是我们使用的范围：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-17_23-53-53.png" alt="images/download/attachments/12714992/image2021-5-17_23-53-53.png" width="400"  />
    </p>
<p   
>进程也可以理解为是一对模块组成的，我们可以使用OD打开一个进程看一下：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-18_0-14-56.png" alt="images/download/attachments/12714992/image2021-5-18_0-14-56.png" width="600"  />
    </p>
<p   
>这里面有很多的模块，每个模块都是一个可执行文件，它们遵守相同的格式，即PE结构，所以我们也可以理解进程就是一堆PE组合。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6L-b56iL55qE5Yib5bu6">
        <h2 class="heading "><span>&#36827;&#31243;&#30340;&#21019;&#24314;</span></h2>
<p   
>我们需要知道任何进程都是别的进程创建的，当我们在Windows下双击打开一个文件，实际上就是explore.exe这个进程创建的我们打开文件的进程，其使用的方法就是：CreateProcess()</p>
<p   
>进程创建的过程也就是<strong class=" ">CreateProcess函数</strong>：</p>
<ol class=" "><li class=" "><p   
>映射EXE文件（低2G）</p>
</li><li class=" "><p   
>创建内核对象EPROCESS（高2G）</p>
</li><li class=" "><p   
>映射系统DLL（ntdll.dll）</p>
</li><li class=" "><p   
>创建线程内核对象RTHREAD（高2G）</p>
</li><li class=" "><p   
>系统启动线程：</p>
<ol class=" "><li class=" "><p   
>映射DLL（ntdll.LdrInitializeThunk）</p>
</li><li class=" "><p   
>线程开始执行</p>
</li></ol></li></ol><p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-18_0-17-35.png" alt="images/download/attachments/12714992/image2021-5-18_0-17-35.png" width="600"  />
    </p>
<p   
>如上图就是打开A.exe的创建过程图，进程是空间上的概念，只用于提供代码和数据资源等等...而想要使用这些资源的是线程，每个进程至少需要一个线程。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5Yib5bu66L-b56iL">
        <h1 class="heading "><span>&#21019;&#24314;&#36827;&#31243;</span></h1>
<p   
>创建进程的函数是CreateProcess()，这个函数的使用方法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL CreateProcess(</code></div>
<div class="line"><code class="plain">    LPCTSTR lpApplicationName,                 </code><code class="comments">// name of executable module 进程名（完整文件路径）</code></div>
<div class="line"><code class="plain">    LPTSTR lpCommandLine,                      </code><code class="comments">// command line string 命令行传参</code></div>
<div class="line"><code class="plain">    LPSECURITY_ATTRIBUTES lpProcessAttributes, </code><code class="comments">// SD 进程句柄</code></div>
<div class="line"><code class="plain">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  </code><code class="comments">// SD 线程句柄</code></div>
<div class="line"><code class="plain">    BOOL bInheritHandles,                      </code><code class="comments">// handle inheritance option 句柄</code></div>
<div class="line"><code class="plain">    DWORD dwCreationFlags,                     </code><code class="comments">// creation flags 标志</code></div>
<div class="line"><code class="plain">    LPVOID lpEnvironment,                      </code><code class="comments">// new environment block 父进程环境变量</code></div>
<div class="line"><code class="plain">    LPCTSTR lpCurrentDirectory,                </code><code class="comments">// current directory name 父进程目录作为当前目录，设置目录</code></div>
<div class="line"><code class="plain">    LPSTARTUPINFO lpStartupInfo,               </code><code class="comments">// startup information 结构体详细信息（启动进程相关信息）</code></div>
<div class="line"><code class="plain">    LPPROCESS_INFORMATION lpProcessInformation </code><code class="comments">// process information 结构体详细信息（进程ID、线程ID、进程句柄、线程句柄）</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>本章节对<strong class=" ">CreateProcess函数</strong>的了解就是前2个参数和后2个参数，前两个参数：<strong class=" ">lpApplicationName、lpCommandLine</strong>，第一个是需要启动的进程文件路径，第二个是命令行参数，如果你启动的进程有参数的可以可以传入。</p>
<p   
>命令行参数是指在CMD命令行下运行程序所需要提供的参数，例如我们的main入口函数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%s - %s"</code><code class="plain">, argv[</code><code class="value">0</code><code class="plain">], argv[</code><code class="value">1</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>其函数传参char* argv[]就是命令行参数，要使用的话就是argv[0]则表示程序本身，其余往后则是参数，argv[1]、argv[2]...等等：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-19_17-30-15.png" alt="images/download/attachments/12714992/image2021-5-19_17-30-15.png" width="600"  />
    </p>
<p   
>所以我们要使用<strong class=" ">CreateProcess函数</strong>创建进程的话，如果需要提供命令行参数则需要填写第二个参数lpCommandLine：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-19_19-7-34.png" alt="images/download/attachments/12714992/image2021-5-19_19-7-34.png" width="600"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;stdlib.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    TCHAR childProcessName[] = TEXT(</code><code class="string">"C:/WINDOWS/system32/cmd.exe"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    TCHAR childProcessCommandLine[] = TEXT(</code><code class="string">" /c ping 127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    STARTUPINFO si;</code></div>
<div class="line"><code class="plain">    PROCESS_INFORMATION pi;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    ZeroMemory(&amp;si, sizeof(si));</code></div>
<div class="line"><code class="plain">    ZeroMemory(&amp;pi, sizeof(pi));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    si.cb = sizeof(si);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(CreateProcess(childProcessName, childProcessCommandLine, NULL, NULL, FALSE, </code><code class="value">0</code><code class="plain">, NULL, NULL, &amp;si, &amp;pi)) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateProcess Successfully! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateProcess Error: %d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    CloseHandle(pi.hProcess);</code></div>
<div class="line"><code class="plain">    CloseHandle(pi.hThread);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    system(</code><code class="string">"pause"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如上图所示代码，首先我定义了进程路径、进程命令行参数，其次<strong class=" ">创建了si、pi两个结构体</strong>，然后使用<strong class=" ">ZeroMemory函数用0填充结构体数据</strong>，再给<strong class=" ">si.cb成员赋值</strong>当前结构体大小（为什么需要？这是因为Windows会有很多个版本，便于未来更新换代）；最后<strong class=" ">CreateProcess函数创建进程</strong>，由于CreateProcess函数本身返回值是布尔类型的，所以使用if来判断，如果出问题则使用<strong class=" ">GetLastError函数来获取问题编号</strong>，具体编号对应什么内容可以参考百度百科：<a  class="external-link" href="https://baike.baidu.com/item/GetLastError/4278820?fr=aladdin">https://baike.baidu.com/item/GetLastError/4278820?fr=aladdin</a></p>
<p   
>在创建完进程之后需要关闭进程，但是我们所知道，每个进程至少有一个线程，所以我们也要关闭线程，使用<strong class=" ">CloseHandle函数</strong>来关闭。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-19_19-52-23.png" alt="images/download/attachments/12714992/image2021-5-19_19-52-23.png" width="600"  />
    </p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6K--5aSW5omp5bGVLeWPjeiwg-ivlShTVEFSVFVQSU5GT-e7k-aehOS9kyk">
        <h2 class="heading "><span>&#35838;&#22806;&#25193;&#23637;-&#21453;&#35843;&#35797;(STARTUPINFO&#32467;&#26500;&#20307;)</span></h2>
<p   
><strong class=" ">CreateProcess()函数</strong>创建进程，其有一个参数是<strong class=" ">STARTUPINFO结构体</strong>，这个参数是进程启动的一些信息，我们一开始会将其ZeroMemory()函数处理，填充0，那么在运行的时候是否还都是0呢？或者说在载入调试工具的时候所有成员是否都是0呢？</p>
<p   
>首先我们来看一下<strong class=" ">STARTUPINFO结构体</strong>的成员：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">typedef struct _STARTUPINFOA {</code></div>
<div class="line"><code class="plain">    DWORD   cb;</code></div>
<div class="line"><code class="plain">    LPSTR   lpReserved;</code></div>
<div class="line"><code class="plain">    LPSTR   lpDesktop;</code></div>
<div class="line"><code class="plain">    LPSTR   lpTitle;</code></div>
<div class="line"><code class="plain">    DWORD   dwX;</code></div>
<div class="line"><code class="plain">    DWORD   dwY;</code></div>
<div class="line"><code class="plain">    DWORD   dwXSize;</code></div>
<div class="line"><code class="plain">    DWORD   dwYSize;</code></div>
<div class="line"><code class="plain">    DWORD   dwXCountChars;</code></div>
<div class="line"><code class="plain">    DWORD   dwYCountChars;</code></div>
<div class="line"><code class="plain">    DWORD   dwFillAttribute;</code></div>
<div class="line"><code class="plain">    DWORD   dwFlags;</code></div>
<div class="line"><code class="plain">    WORD    wShowWindow;</code></div>
<div class="line"><code class="plain">    WORD    cbReserved2;</code></div>
<div class="line"><code class="plain">    LPBYTE  lpReserved2;</code></div>
<div class="line"><code class="plain">    HANDLE  hStdInput;</code></div>
<div class="line"><code class="plain">    HANDLE  hStdOutput;</code></div>
<div class="line"><code class="plain">    HANDLE  hStdError;</code></div>
<div class="line"><code class="plain">} STARTUPINFOA, *LPSTARTUPINFOA;</code></div>
</div>
    </div>
<p   
>将这几个<strong class=" ">DWORD类型</strong>的成员打印一下看看，通过<strong class=" ">GetStartupInfo函数</strong>来获取信息：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;stdlib.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    STARTUPINFO si;</code></div>
<div class="line"><code class="plain">    ZeroMemory(&amp;si, sizeof(si));</code></div>
<div class="line"><code class="plain">    si.cb = sizeof(si);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    GetStartupInfo(&amp;si);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"%d %d %d %d %d %d %d %d\n"</code><code class="plain">, si.dwX, si.dwY, si.dwXSize, si.dwYSize, si.dwXCountChars, si.dwYCountChars, si.dwFillAttribute, si.dwFlags); </code></div>
<div class="line"><code class="plain">    system(</code><code class="string">"pause"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>正常打开（P1）和在DTDebug调试工具（P2）中打开：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-19_21-13-54.png" alt="images/download/attachments/12714992/image2021-5-19_21-13-54.png" width="600"  />
    </p>
<p   
>我们可以很清楚的看见了几个值在调试工具中打开发生变化：<strong class=" ">si.dwXSize, si.dwYSize, si.dwXCountChars, si.dwFillAttribute, si.dwFlags</strong></p>
<p   
>所以我们可以根据这几个值来判断从而进行反调试：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-19_22-7-56.png" alt="images/download/attachments/12714992/image2021-5-19_22-7-56.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5Y-l5p-E6KGo">
        <h1 class="heading "><span>&#21477;&#26564;&#34920;</span></h1>
<p   
>在上一章节中，我们了解到了CreateProcess()函数创建进程会有一个结构体<strong class=" ">LPPROCESS_INFORMATION lpProcessInformation</strong>，这个结构体会有进程和线程的ID、句柄信息，那么什么是ID？什么是句柄？</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5qC45a-56LGh">
        <h2 class="heading "><span>&#20869;&#26680;&#23545;&#35937;</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv5YaF5qC45a-56LGh">
        <h3 class="heading "><span>&#20160;&#20040;&#26159;&#20869;&#26680;&#23545;&#35937;</span></h3>
<p   
>首先我们来了解一下内核对象，以后会经常与内核对象打交道，例如进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象（<strong class=" ">当我们创建一个进程，在内核层（高2G）就会创建一个结构体EPROCESS...</strong>）。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-20_0-41-40.png" alt="images/download/attachments/12714992/image2021-5-20_0-41-40.png"  height="250" />
    </p>
<p   
>记不住没关系，我们可以在<strong class=" ">MSDN Library中搜索CloseHandle这个函数</strong>，它是用来关闭句柄的，暂时先不用管其原理，我们只要知道它所支持关闭就都是内核对象：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-20_0-46-21.png" alt="images/download/attachments/12714992/image2021-5-20_0-46-21.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt566h55CG5YaF5qC45a-56LGh">
        <h3 class="heading "><span>&#31649;&#29702;&#20869;&#26680;&#23545;&#35937;</span></h3>
<p   
>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？其实很好解决，我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong class=" ">应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-20_0-53-28.png" alt="images/download/attachments/12714992/image2021-5-20_0-53-28.png" width="400"  />
    </p>
<p   
>微软为了避免这种情况的发生，所以其不会讲内核结构体的地址暴露给应用层，也就是说没法通过这种方式来直接管理。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6L-b56iL5Y-l5p-E6KGo">
        <h2 class="heading "><span>&#36827;&#31243;&#21477;&#26564;&#34920;</span></h2>
<p   
>没法直接管理内核对象，这时候句柄表就诞生了，但是需要注意的是，只有进程才会有句柄表，并且每一个进程都会有一个句柄表。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-20_1-1-58.png" alt="images/download/attachments/12714992/image2021-5-20_1-1-58.png" width="400"  />
    </p>
<p   
>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5aSa6L-b56iL5YWx5Lqr5LiA5Liq5YaF5qC45a-56LGh">
        <h2 class="heading "><span>&#22810;&#36827;&#31243;&#20849;&#20139;&#19968;&#20010;&#20869;&#26680;&#23545;&#35937;</span></h2>
<p   
>如下图所示，A进程通过<strong class=" ">CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong class=" ">OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_0-19-38.png" alt="images/download/attachments/12714992/image2021-5-21_0-19-38.png" width="400"  />
    </p>
<p   
>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong class=" ">彻底消失</strong>；如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong class=" ">CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong class=" ">CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了。</p>
<p   
><strong class=" ">最后</strong>：注意，以上所述特性适合于除了线程以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong class=" ">CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong class=" ">CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong class=" ">只有线程关闭了，进程才会关闭</strong>）。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Y-l5p-E5piv5ZCmIuWPr-S7pSLooqvnu6fmib8">
        <h2 class="heading "><span>&#21477;&#26564;&#26159;&#21542;&quot;&#21487;&#20197;&quot;&#34987;&#32487;&#25215;</span></h2>
<p   
>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否&quot;可以&quot;被继承。</p>
<p   
>如下图所示（<strong class=" ">句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_0-51-37.png" alt="images/download/attachments/12714992/image2021-5-21_0-51-37.png" width="400"  />
    </p>
<p   
>这四个函数都有一个参数<strong class=" ">LPSECURITY_ATTRIBUTES lpThreadAttributes</strong>，通过这个参数我们可以判断函数是否创建的是内核对象。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_0-57-16.png" alt="images/download/attachments/12714992/image2021-5-21_0-57-16.png" width="600"  />
    </p>
<p   
>我们可以跟进看一下这个参数，它就是一个结构体：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_1-2-23.png" alt="images/download/attachments/12714992/image2021-5-21_1-2-23.png" width="400"  />
    </p>
<p   
>结构体成员分别是：<strong class=" ">1.结构体长度；2.安全描述符；3.句柄是否被继承</strong>。</p>
<p   
>第一个成员我们见怪不怪了，在Windows设计下都会有这样一个成员；第二个安全描述符，这个对我们来说实际上没有任何意义，一般留空就行，默认它会遵循父进程的来，其主要作用就是<strong class=" ">描述谁创建了该对象，谁有访问、使用该对象的权限</strong>。</p>
<p   
>第三个成员是我们重点需要关注的，因为其决定了句柄是否可以被继承，如下图所示，我们让CreateProcess函数创建的进程、线程句柄可以被继承：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_1-29-4.png" alt="images/download/attachments/12714992/image2021-5-21_1-29-4.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Y-l5p-E5piv5ZCmIuWFgeiuuCLooqvnu6fmib8">
        <h2 class="heading "><span>&#21477;&#26564;&#26159;&#21542;&quot;&#20801;&#35768;&quot;&#34987;&#32487;&#25215;</span></h2>
<p   
>我们可以让句柄被继承，但也仅仅是可以，要真正完成继承，或者说我们允许子进程继承父进程的句柄，这时候就需要另外一个参数了。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_1-38-10.png" alt="images/download/attachments/12714992/image2021-5-21_1-38-10.png" width="400"  />
    </p>
<p   
>我们还是以CreateProcess函数举例，其有一个参数<strong class=" ">BOOL bInheritHandles</strong>，这个参数决定了是否允许创建的子进程继承句柄：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_1-42-32.png" alt="images/download/attachments/12714992/image2021-5-21_1-42-32.png" width="400"  />
    </p>
<p   
>只有这个参数设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6L-b56iL55u45YWzQVBJ">
        <h1 class="heading "><span>&#36827;&#31243;&#30456;&#20851;API</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItSUTkuI7lj6Xmn4Q">
        <h2 class="heading "><span>ID&#19982;&#21477;&#26564;</span></h2>
<p   
>如果我们成功创建了一个进程，CreateProcess函数会给我们返回一个结构体，包含四个数据：进程编号（ID）、进程句柄、线程编号（ID）、线程句柄。</p>
<p   
>进程ID其实我们早就见过了，通常我们称之为PID，在任务管理器的进程栏下就可以很清楚的看见：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_16-36-52.png" alt="images/download/attachments/12714992/image2021-5-21_16-36-52.png" width="400"  />
    </p>
<p   
>每个进程都有一份私有的句柄表，而操作系统也有一份句柄表，我们称之为全局句柄表，这张表里包含了所有正在运行的进程、线程：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-21_16-38-51.png" alt="images/download/attachments/12714992/image2021-5-21_16-38-51.png" width="400"  />
    </p>
<p   
>PID我们就可以理解为是全局句柄表中的一个索引，那么PID和句柄的区别就很容易看出来来了，<strong class=" ">PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的</strong>；PID是<strong class=" ">唯一的，绝对不可能出现重复的存在</strong>，但是当进程消失，那么这个PID就有可能会分给另外一个进程。（<strong class=" ">PID不是句柄，但是可以通过PID获得到全局句柄表中其对应的句柄</strong>）</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItVGVybWluYXRlUHJvY2Vzc-WHveaVsA">
        <h2 class="heading "><span>TerminateProcess&#20989;&#25968;</span></h2>
<p   
>我们可以来论证一下如上所述的概念，首先A进程打开IE浏览器，然后获取进程ID和句柄：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_0-19-16.png" alt="images/download/attachments/12714992/image2021-5-22_0-19-16.png" width="600"  />
    </p>
<p   
>其次B进程使用TerminateProcess函数来终止A进程，首先使用句柄信息终止：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// TerminateProcess函数</code></div>
<div class="line"><code class="plain">BOOL TerminateProcess(</code></div>
<div class="line"><code class="plain">  HANDLE hProcess, </code><code class="comments">// handle to the process 句柄</code></div>
<div class="line"><code class="plain">  UINT uExitCode   </code><code class="comments">// exit code for the process 退出代码</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_0-22-40.png" alt="images/download/attachments/12714992/image2021-5-22_0-22-40.png" width="600"  />
    </p>
<p   
>TerminateProcess函数是用来终止进程的，具体的可以参考MSDN Library，在这里我们很清楚的可以看见终止进程失败了，这个错误编号的意思就是句柄无效，那么就论证了句柄是私有的，其他进程无法根据这个句柄来终止进程，但是<strong class=" ">我们想要真正的关闭这个进程，那就需要借助PID来获取句柄了，具体细节如下</strong>。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItT3BlblByb2Nlc3Plh73mlbA">
        <h2 class="heading "><span>OpenProcess&#20989;&#25968;</span></h2>
<p   
>了解了TerminateProcess函数后，我们想要真正的去关闭一个进程，需要借助OpenProcess函数，<strong class=" ">这个函数是用来打开进程对象的</strong>：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE OpenProcess(</code></div>
<div class="line"><code class="plain">  DWORD dwDesiredAccess,  </code><code class="comments">// access flag 你希望的访问权限</code></div>
<div class="line"><code class="plain">  BOOL bInheritHandle,    </code><code class="comments">// handle inheritance option 是否可以被继承</code></div>
<div class="line"><code class="plain">  DWORD dwProcessId       </code><code class="comments">// process identifier 进程ID</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_0-39-55.png" alt="images/download/attachments/12714992/image2021-5-22_0-39-55.png" width="400"  />
    </p>
<p   
>如下代码所示，我通过PID打开进程（OpenProcess函数），拥有所有权，不继承句柄表，当OpenProcess函数执行完成之后，我就获得一个句柄，通过这个句柄我就可以终止进程：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hProcess;</code></div>
<div class="line"><code class="plain">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, </code><code class="value">0x524</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">if</code><code class="plain">(!TerminateProcess(hProcess, </code><code class="value">0</code><code class="plain">)) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"终止进程失败：%d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Lul5oyC6LW355qE5b2i5byP5Yib5bu66L-b56iL">
        <h2 class="heading "><span>&#20197;&#25346;&#36215;&#30340;&#24418;&#24335;&#21019;&#24314;&#36827;&#31243;</span></h2>
<p   
>CreateProcess函数的所有参数都需要了解一下，现在我们来看一下第六个参数<strong class=" ">DWORD dwCreationFlags</strong>：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL CreateProcess(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpApplicationName,                 </code><code class="comments">// name of executable module</code></div>
<div class="line"><code class="plain">  LPTSTR lpCommandLine,                      </code><code class="comments">// command line string</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpProcessAttributes, </code><code class="comments">// SD</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpThreadAttributes,  </code><code class="comments">// SD</code></div>
<div class="line"><code class="plain">  BOOL bInheritHandles,                      </code><code class="comments">// handle inheritance option</code></div>
<div class="line"><code class="plain">  DWORD dwCreationFlags,                     </code><code class="comments">// creation flags &lt;--这个参数</code></div>
<div class="line"><code class="plain">  LPVOID lpEnvironment,                      </code><code class="comments">// new environment block</code></div>
<div class="line"><code class="plain">  LPCTSTR lpCurrentDirectory,                </code><code class="comments">// current directory name</code></div>
<div class="line"><code class="plain">  LPSTARTUPINFO lpStartupInfo,               </code><code class="comments">// startup information</code></div>
<div class="line"><code class="plain">  LPPROCESS_INFORMATION lpProcessInformation </code><code class="comments">// process information</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>当我们创建一个控制台进程时，会发现子进程和父进程都在同一个命令行控制台中：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-4-57.png" alt="images/download/attachments/12714992/image2021-5-22_1-4-57.png" width="600"  />
    </p>
<p   
>而如果我们想要区分的话就需要借助<strong class=" ">dwCreationFlags</strong>这个参数，将其修改为<strong class=" ">CREATE_NEW_CONSOLE</strong>即可：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-6-34.png" alt="images/download/attachments/12714992/image2021-5-22_1-6-34.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-7-24.png" alt="images/download/attachments/12714992/image2021-5-22_1-7-24.png" width="600"  />
    </p>
<p   
>但是这个并不是我们最重要的，或者说不是其真正有意义的参数，有意义的是参数值为<strong class=" ">CREATE_SUSPENDED</strong>，也就是以挂起的形式创建进程。</p>
<p   
>而如果是以挂起的方式创建进程，那么进程的创建过程就会发生变化：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-12-9.png" alt="images/download/attachments/12714992/image2021-5-22_1-12-9.png" width="400"  />
    </p>
<p   
>那也就说明了一点，挂起本质上<strong class=" ">挂起的是线程</strong>，进程还是会创建的，所以，最终如果想恢复的话也是恢复线程：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-17-20.png" alt="images/download/attachments/12714992/image2021-5-22_1-17-20.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5qih5Z2X55uu5b2V5LiO5bel5L2c55uu5b2V">
        <h2 class="heading "><span>&#27169;&#22359;&#30446;&#24405;&#19982;&#24037;&#20316;&#30446;&#24405;</span></h2>
<p   
>通过<strong class=" ">GetModuleFileName</strong>和<strong class=" ">GetCurrentDirectory</strong>函数可以分别获得当前模块目录和当前工作目录：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">char</code><code class="plain"> strModule[</code><code class="value">256</code><code class="plain">];</code></div>
<div class="line"><code class="plain">GetModuleFileName(NULL,strModule, </code><code class="value">256</code><code class="plain">); </code><code class="comments">// 得到当前模块目录，当前exe所在的路径，包含exe文件名</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">char</code><code class="plain"> strWork[</code><code class="value">1000</code><code class="plain">];</code></div>
<div class="line"><code class="plain">GetCurrentDirectory(</code><code class="value">1000</code><code class="plain">, strWork); </code><code class="comments">// 获取当前工作目录</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">printf(</code><code class="string">"模块目录：%s \n工作目录：%s \n"</code><code class="plain">, strModule, strWork);</code></div>
</div>
    </div>
<p   
>需要注意的是工作目录是可以修改的，我们可以通过<strong class=" ">CreateProcess函数来创建一个进程，并且修改其工作目录</strong>，这是CreateProcess函数的第八个参数<strong class=" ">LPCTSTR lpCurrentDirectory</strong>。</p>
<p   
>假设我们有这样一个需求：打开当前工作目录下的1.txt文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-36-22.png" alt="images/download/attachments/12714992/image2021-5-22_1-36-22.png" width="600"  />
    </p>
<p   
>而这时候我们可以通过CreateProcess函数修改工作路径，让其读取我们指定工作目录的文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-40-3.png" alt="images/download/attachments/12714992/image2021-5-22_1-40-3.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YW25LuW6L-b56iL55u45YWzQVBJ">
        <h2 class="heading "><span>&#20854;&#20182;&#36827;&#31243;&#30456;&#20851;API</span></h2>
<p   
>获取当前进程ID（PID）：GetCurrentProcessId</p>
<p   
>获取当前进程句柄：GetCurrentProcess</p>
<p   
>获取命令行：GetCommandLine</p>
<p   
>获取启动信息：GetStartupInfo</p>
<p   
>遍历进程ID：EnumProcesses</p>
<p   
>快照：CreateToolhelp32Snapshot</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5Yib5bu657q_56iL">
        <h1 class="heading "><span>&#21019;&#24314;&#32447;&#31243;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv57q_56iL">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#32447;&#31243;</span></h2>
<ol class=" "><li class=" "><p   
>线程是附属在进程上的执行实体，是代码的执行流程；</p>
</li><li class=" "><p   
>一个进程可以包含多个线程（<strong class=" ">一个进程至少要包含一个线程，进程是空间上的概念，线程是时间上的概念</strong>）。</p>
</li></ol><p   
>通过Windows任务管理器我们也可以很清晰的看见每个进程当前的线程数量：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_1-46-16.png" alt="images/download/attachments/12714992/image2021-5-22_1-46-16.png" width="400"  />
    </p>
<p   
>有几个线程就表示着有几个代码在执行，但是它们并不一定是同时执行，例如单核的CPU情况下是不存在多线程的，线程的执行是有时间顺序的，但是CPU切换的非常快，所以给我们的感觉和多核CPU没什么区别。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Yib5bu657q_56iLLjE">
        <h2 class="heading "><span>&#21019;&#24314;&#32447;&#31243;</span></h2>
<p   
>创建线程使用CreateThread函数，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateThread( </code><code class="comments">// 返回值是线程句柄</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpThreadAttributes, </code><code class="comments">// SD 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  SIZE_T dwStackSize,                       </code><code class="comments">// initial stack size 初始堆栈</code></div>
<div class="line"><code class="plain">  LPTHREAD_START_ROUTINE lpStartAddress,    </code><code class="comments">// thread function 线程执行的函数代码</code></div>
<div class="line"><code class="plain">  LPVOID lpParameter,                       </code><code class="comments">// thread argument 线程需要的参数</code></div>
<div class="line"><code class="plain">  DWORD dwCreationFlags,                    </code><code class="comments">// creation option 标识，也可以以挂起形式创建线程</code></div>
<div class="line"><code class="plain">  LPDWORD lpThreadId                        </code><code class="comments">// thread identifier 返回当前线程ID</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>线程执行函数的语法要求如下：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_2-6-49.png" alt="images/download/attachments/12714992/image2021-5-22_2-6-49.png" width="400"  />
    </p>
<p   
>我们尝试创建一个线程执行for循环，如下图：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_2-3-22.png" alt="images/download/attachments/12714992/image2021-5-22_2-3-22.png" width="600"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 线程执行的函数有语法要求，参考MSDN Library</code></div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 要执行的代码</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">100</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">500</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"++++++ %d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建线程</code></div>
<div class="line"><code class="plain">    CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 要执行的代码</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">100</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">500</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"------ %d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>线程间不会相互配合，而是各自执行自己的，如果想要配合就需要了解线程通信，这个后面会学习到。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5ZCR57q_56iL5Ye95pWw5Lyg6YCS5Y-C5pWw">
        <h2 class="heading "><span>&#21521;&#32447;&#31243;&#20989;&#25968;&#20256;&#36882;&#21442;&#25968;</span></h2>
<p   
>向线程传递参数，如下图所示，我们想要自定义线程执行for循环的次数，将n传递进去，这时候需要注意参数传递到线程参数时在堆栈中存在，并且传递的时候需要强制转换一下：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_2-12-19.png" alt="images/download/attachments/12714992/image2021-5-22_2-12-19.png" width="600"  />
    </p>
<p   
>为了保证参数的生命周期，我们也可以将参数放在全局变量区：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-22_2-16-23.png" alt="images/download/attachments/12714992/image2021-5-22_2-16-23.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt57q_56iL5o6n5Yi2">
        <h1 class="heading "><span>&#32447;&#31243;&#25511;&#21046;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6K6p57q_56iL5YGc5LiL5p2l">
        <h2 class="heading "><span>&#35753;&#32447;&#31243;&#20572;&#19979;&#26469;</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItU2xlZXDlh73mlbA">
        <h3 class="heading "><span>Sleep&#20989;&#25968;</span></h3>
<p   
>Sleep函数是让当前执行到本函数时延迟指定的毫秒之后再向下走，例如：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">100</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">    Sleep(</code><code class="value">500</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"------ %d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItU3VzcGVuZFRocmVhZOWHveaVsA">
        <h3 class="heading "><span>SuspendThread&#20989;&#25968;</span></h3>
<p   
>SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，其语法格式很简单，只需要传入一个线程句柄即可：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD SuspendThread(</code></div>
<div class="line"><code class="plain">  HANDLE hThread   </code><code class="comments">// handle to thread</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItUmVzdW1lVGhyZWFk5Ye95pWw">
        <h3 class="heading "><span>ResumeThread&#20989;&#25968;</span></h3>
<p   
>ResumeThread函数用于恢复被暂停（挂起）的线程，其语法格式也很简单，只需要传入一个线程句柄即可：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD ResumeThread(</code></div>
<div class="line"><code class="plain">  HANDLE hThread   </code><code class="comments">// handle to thread</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>需要注意的是，挂起几次就要恢复几次。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">SuspendThread(hThread);</code></div>
<div class="line"><code class="plain">SuspendThread(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">ResumeThread(hThread);</code></div>
<div class="line"><code class="plain">ResumeThread(hThread);</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt562J5b6F57q_56iL57uT5p2f">
        <h2 class="heading "><span>&#31561;&#24453;&#32447;&#31243;&#32467;&#26463;</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItV2FpdEZvclNpbmdsZU9iamVjdOWHveaVsA">
        <h3 class="heading "><span>WaitForSingleObject&#20989;&#25968;</span></h3>
<p   
>WaitForSingleObject函数用于等待<strong class=" ">一个内核对象</strong>状态发生变更，那也就是执行结束之后，才会继续向下执行，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD WaitForSingleObject(</code></div>
<div class="line"><code class="plain">  HANDLE hHandle,        </code><code class="comments">// handle to object 句柄</code></div>
<div class="line"><code class="plain">  DWORD dwMilliseconds   </code><code class="comments">// time-out interval 等待超时时间（毫秒）</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_12-34-19.png" alt="images/download/attachments/12714992/image2021-5-23_12-34-19.png" width="600"  />
    </p>
<p   
>如果你想一直等待的话，可以将第二参数的值设置为<strong class=" ">INFINITE</strong>。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hThread;</code></div>
<div class="line"><code class="plain">hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">WaitForSingleObject(hThread, INFINITE);</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"OK..."</code><code class="plain">);</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItV2FpdEZvck11bHRpcGxlT2JqZWN0c-WHveaVsA">
        <h3 class="heading "><span>WaitForMultipleObjects&#20989;&#25968;</span></h3>
<p   
>WaitForMultipleObjects函数与WaitForSingleObject函数<strong class=" ">作用是一样</strong>的，只不过它可以等待<strong class=" ">多个内核对象的状态</strong>发生变更，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD WaitForMultipleObjects(</code></div>
<div class="line"><code class="plain">  DWORD nCount,             </code><code class="comments">// number of handles in array 内核对象的数量</code></div>
<div class="line"><code class="plain">  CONST HANDLE *lpHandles,  </code><code class="comments">// object-handle array 内核对象的句柄数组</code></div>
<div class="line"><code class="plain">  BOOL bWaitAll,            </code><code class="comments">// wait option 等待模式</code></div>
<div class="line"><code class="plain">  DWORD dwMilliseconds      </code><code class="comments">// time-out interval 等待超时时间（毫秒）</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_15-30-41.png" alt="images/download/attachments/12714992/image2021-5-23_15-30-41.png" width="600"  />
    </p>
<p   
>等待模式的值是布尔类型，一个是TRUE，一个是FALSE，TRUE就是等待所有对象的所有状态发生变更，FALSE则是等待任意一个对象的状态发生变更。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hThread[</code><code class="value">2</code><code class="plain">];</code></div>
<div class="line"><code class="plain">hThread[</code><code class="value">0</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">hThread[</code><code class="value">1</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">WaitForMultipleObjects(</code><code class="value">2</code><code class="plain">, hThread, TRUE, INFINITE);</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItR2V0RXhpdENvZGVUaHJlYWTlh73mlbA">
        <h3 class="heading "><span>GetExitCodeThread&#20989;&#25968;</span></h3>
<p   
>线程函数会有一个返回值（DWORD），这个返回值可以根据你的需求进行返回，而我们需要如何获取这个返回结果呢？这时候就可以使用<strong class=" ">GetExitCodeThread</strong>函数，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL GetExitCodeThread(</code></div>
<div class="line"><code class="plain">  HANDLE hThread,      </code><code class="comments">// handle to the thread</code></div>
<div class="line"><code class="plain">  LPDWORD lpExitCode   </code><code class="comments">// termination status</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_15-37-48.png" alt="images/download/attachments/12714992/image2021-5-23_15-37-48.png" width="600"  />
    </p>
<p   
>根据MSDN Library我们可以知道该函数的参数分别是线程句柄，而另一个则是out类型参数，这种类型则可以理解为GetExitCodeThread函数的返回结果。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hThread;</code></div>
<div class="line"><code class="plain">hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">WaitForSingleObject(hThread, INFINITE);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD exitCode;</code></div>
<div class="line"><code class="plain">GetExitCodeThread(hThread, &amp;exitCode);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">printf(</code><code class="string">"Exit Code: %d \n"</code><code class="plain">, exitCode);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_15-44-6.png" alt="images/download/attachments/12714992/image2021-5-23_15-44-6.png" width="600"  />
    </p>
<p   
>需要注意的是这个函数应该搭配着如上所学的2个等待函数一起使用，不然获取到的值就不会是线程函数返回的值。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6K6-572u44CB6I635Y-W57q_56iL5LiK5LiL5paH">
        <h2 class="heading "><span>&#35774;&#32622;&#12289;&#33719;&#21462;&#32447;&#31243;&#19978;&#19979;&#25991;</span></h2>
<p   
><strong class=" ">线程上下文</strong>是指某一时间点CPU寄存器和程序计数器的内容，如果想要设置、获取线程上下文就需要先将线程<strong class=" ">挂起</strong>。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItR2V0VGhyZWFkQ29udGV4dOWHveaVsA">
        <h3 class="heading "><span>GetThreadContext&#20989;&#25968;</span></h3>
<p   
>GetThreadContext函数用于获取线程上下文，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL GetThreadContext(</code></div>
<div class="line"><code class="plain">  HANDLE hThread,       </code><code class="comments">// handle to thread with context 句柄</code></div>
<div class="line"><code class="plain">  LPCONTEXT lpContext   </code><code class="comments">// context structure</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_15-52-19.png" alt="images/download/attachments/12714992/image2021-5-23_15-52-19.png" width="600"  />
    </p>
<p   
>第一个参数就是线程句柄，这个很好理解，重点是第二个参数，其是一个CONTEXT结构体，该结构体包含指定线程的上下文，其ContextFlags成员的值指定了要设置线程上下文的哪些部分。</p>
<p   
>当我们将CONTEXT结构体的ContextFlags成员的值设置为CONTEXT_INTEGER时则可以获取edi、esi、ebx、edx、ecx、eax这些寄存器的值：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_16-1-25.png" alt="images/download/attachments/12714992/image2021-5-23_16-1-25.png" width="600"  />
    </p>
<p   
>如下代码尝试获取：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hThread;</code></div>
<div class="line"><code class="plain">hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">SuspendThread(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CONTEXT c;</code></div>
<div class="line"><code class="plain">c.ContextFlags = CONTEXT_INTEGER;</code></div>
<div class="line"><code class="plain">GetThreadContext(hThread, &amp;c);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">printf(</code><code class="string">"%x %x \n"</code><code class="plain">, c.Eax, c.Ecx);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_16-1-50.png" alt="images/download/attachments/12714992/image2021-5-23_16-1-50.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItU2V0VGhyZWFkQ29udGV4dOWHveaVsA">
        <h3 class="heading "><span>SetThreadContext&#20989;&#25968;</span></h3>
<p   
>GetThreadContext函数是个设置修改线程上下文，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL SetThreadContext(</code></div>
<div class="line"><code class="plain">  HANDLE hThread,            </code><code class="comments">// handle to thread</code></div>
<div class="line"><code class="plain">  CONST CONTEXT *lpContext   </code><code class="comments">// context structure</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>我们可以尝试修改Eax，然后再获取：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE hThread;</code></div>
<div class="line"><code class="plain">hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">SuspendThread(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CONTEXT c;</code></div>
<div class="line"><code class="plain">c.ContextFlags = CONTEXT_INTEGER;</code></div>
<div class="line"><code class="plain">c.Eax = </code><code class="value">0x123</code><code class="plain">;</code></div>
<div class="line"><code class="plain">SetThreadContext(hThread, &amp;c);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CONTEXT c1;</code></div>
<div class="line"><code class="plain">c1.ContextFlags = CONTEXT_INTEGER;</code></div>
<div class="line"><code class="plain">GetThreadContext(hThread, &amp;c1);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">printf(</code><code class="string">"%x \n"</code><code class="plain">, c1.Eax);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-23_16-9-51.png" alt="images/download/attachments/12714992/image2021-5-23_16-9-51.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5Li055WM5Yy6">
        <h1 class="heading "><span>&#20020;&#30028;&#21306;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt57q_56iL5a6J5YWo6Zeu6aKY">
        <h2 class="heading "><span>&#32447;&#31243;&#23433;&#20840;&#38382;&#39064;</span></h2>
<p   
>每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的&ldquo;句柄变量&rdquo;（栈），如果线程仅仅使用自己的&ldquo;局部变量&rdquo;那就不存在线程安全问题，反之，<strong class=" ">如果多个线程共用一个全局变量呢</strong>？那么在什么情况下会有问题呢？<strong class=" ">那就是当多线程共用一个全局变量并对其进行修改时则存在安全问题</strong>，如果仅仅是读的话没有问题。</p>
<p   
>如下所示代码，我们写了一个线程函数，该函数的作用就是使用全局变量，模拟的功能就是售卖物品，全局变量countNumber表示该物品的总是，其值是10，而如果有多个地方（线程）去卖（使用）这个物品（全局变量），则会出现差错：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> countNumber = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (countNumber &gt; </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Sell num: %d\n"</code><code class="plain">, countNumber);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 售出-1</code></div>
<div class="line"><code class="plain">        countNumber--;</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Count: %d\n"</code><code class="plain">, countNumber);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    HANDLE hThread1;</code></div>
<div class="line"><code class="plain">    hThread1 = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如图，我们运行了代码，发现会出现重复售卖，并且到最后总数竟变成了-1：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_15-4-41.png" alt="images/download/attachments/12714992/image2021-5-27_15-4-41.png" width="600"  />
    </p>
<p   
>出现这样的问题其本质原因是什么呢？<strong class=" ">因为多线程在执行的时候是同步进行的，并不是按照顺序来，所以就都会窒息，自然就会出现这种情况</strong>。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6Kej5Yaz6Zeu6aKY">
        <h3 class="heading "><span>&#35299;&#20915;&#38382;&#39064;</span></h3>
<p   
>想要解决线程安全问题，就需要引伸出一个概念：临界资源，<strong class=" ">临界资源表示对该资源的访问一次只能有一个线程；访问临界资源的那一段程序，我们称之为临界区</strong>。</p>
<p   
>那么我们如何实现临界区呢？第一，<strong class=" ">我们可以自己来写</strong>，但是这需要一定门槛，先不过多的去了解；第二，<strong class=" ">可以使用WIndows提供的API来实现</strong>。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5a6e546w5Li055WM5Yy6">
        <h2 class="heading "><span>&#23454;&#29616;&#20020;&#30028;&#21306;</span></h2>
<p   
>首先会有一个令牌，假设线程1获取了这个令牌，那么这时候令牌则只为线程1所有，然后线程1会执行代码去访问全局变量，最后归还令牌；<strong class=" ">如果其他线程想要去访问这个全局变量就需要获取这个令牌，但当令牌已经被取走时则无法访问</strong>。</p>
<p   
>假设你自己来实现临界区，可能在判断令牌有没有被拿走的时候就又会出现问题，所以自己实现临界区还是有一定的门槛的。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_15-24-36.png" alt="images/download/attachments/12714992/image2021-5-27_15-24-36.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt57q_56iL6ZSB">
        <h2 class="heading "><span>&#32447;&#31243;&#38145;</span></h2>
<p   
>线程锁就是临界区的实现方式，通过线程锁我们可以完美解决如上所述的问题，其步骤如下所示：</p>
<ol class=" "><li class=" "><p   
>创建全局变量：CRITICAL_SECTION cs;</p>
</li><li class=" "><p   
>初始化全局变量：InitializeCriticalSection(&amp;cs);</p>
</li><li class=" "><p   
>实现临界区：进入 &rarr; EnterCriticalSection(&amp;cs); 离开 &rarr; LeaveCriticalSection(&amp;cs);</p>
</li></ol><p   
>我们就可以这样改写之前的售卖物品的代码：</p>
<p   
>在使用全局变量开始前构建并进入临界区，使用完之后离开临界区：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">CRITICAL_SECTION cs; </code><code class="comments">// 创建全局变量</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> countNumber = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="value">1</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        EnterCriticalSection(&amp;cs); </code><code class="comments">// 构建临界区，获取令牌</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (countNumber &gt; </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Thread: %d\n"</code><code class="plain">, *((</code><code class="keyword">int</code><code class="plain">*)lpParameter));</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Sell num: %d\n"</code><code class="plain">, countNumber);</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 售出-1</code></div>
<div class="line"><code class="plain">            countNumber--;</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Count: %d\n"</code><code class="plain">, countNumber);</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            LeaveCriticalSection(&amp;cs); </code><code class="comments">// 离开临临界区，归还令牌</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;  </code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        LeaveCriticalSection(&amp;cs); </code><code class="comments">// 离开临临界区，归还令牌</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    InitializeCriticalSection(&amp;cs); </code><code class="comments">// 使用之前进行初始化</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> a = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    hThread = CreateThread(NULL, NULL, ThreadProc, (LPVOID)&amp;a, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> b = </code><code class="value">2</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    HANDLE hThread1;</code></div>
<div class="line"><code class="plain">    hThread1 = CreateThread(NULL, NULL, ThreadProc, (LPVOID)&amp;b, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_15-54-0.png" alt="images/download/attachments/12714992/image2021-5-27_15-54-0.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5LqS5pal5L2T">
        <h1 class="heading "><span>&#20114;&#26021;&#20307;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5qC457qn5Li055WM6LWE5rqQ5oCO5LmI5Yqe77yf">
        <h2 class="heading "><span>&#20869;&#26680;&#32423;&#20020;&#30028;&#36164;&#28304;&#24590;&#20040;&#21150;&#65311;</span></h2>
<p   
>上一章中我们了解了使用线程锁来解决多个线程共用一个全局变量的线程安全问题；<strong class=" ">那么假设A进程的B线程和C进程的D线程</strong>，同时使用的是内核级的临界资源（<strong class=" ">内核对象：线程、文件、进程...</strong>）该怎么让这个访问是安全的？<strong class=" ">使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程</strong>。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_16-8-12.png" alt="images/download/attachments/12714992/image2021-5-27_16-8-12.png" width="400"  />
    </p>
<p   
>那么这时候我们就需要一个<strong class=" ">能够放在内核中的令牌</strong>来控制，而实现这个作用的，我们称之为<strong class=" ">互斥体</strong>。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_16-10-43.png" alt="images/download/attachments/12714992/image2021-5-27_16-10-43.png" width="400"  />
    </p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5LqS5pal5L2T55qE5L2_55So">
        <h3 class="heading "><span>&#20114;&#26021;&#20307;&#30340;&#20351;&#29992;</span></h3>
<p   
>创建互斥体的函数为<strong class=" ">CreateMutex</strong>，该函数的语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateMutex(</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpMutexAttributes,  </code><code class="comments">// SD 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  BOOL bInitialOwner,                       </code><code class="comments">// initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权</code></div>
<div class="line"><code class="plain">  LPCTSTR lpName                            </code><code class="comments">// object name 互斥体的名字</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p  class="auto-cursor-target" 
>我们可以模拟一下操作资源然后创建：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建互斥体</code></div>
<div class="line"><code class="plain">    HANDLE cm = CreateMutex(NULL, FALSE, </code><code class="string">"XYZ"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</code></div>
<div class="line"><code class="plain">    WaitForSingleObject(cm, INFINITE);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 操作资源</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">5</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Process: A Thread: B -- %d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">1000</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 释放令牌</code></div>
<div class="line"><code class="plain">    ReleaseMutex(cm);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们可以运行两个进程来看一下互斥体的作用：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_16-57-41.png" alt="images/download/attachments/12714992/image2021-5-27_16-57-41.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LqS5pal5L2T5ZKM57q_56iL6ZSB55qE5Yy65Yir">
        <h2 class="heading "><span>&#20114;&#26021;&#20307;&#21644;&#32447;&#31243;&#38145;&#30340;&#21306;&#21035;</span></h2>
<ol class=" "><li class=" "><p   
>线程锁只能用于单个进程间的线程控制</p>
</li><li class=" "><p   
>互斥体可以设定等待超时，但线程锁不能</p>
</li><li class=" "><p   
>线程意外结束时，互斥体可以避免无限等待</p>
</li><li class=" "><p   
>互斥体效率没有线程锁高</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6K--5aSW5omp5bGVLeS6kuaWpeS9k-mYsuatoueoi-W6j-WkmuW8gA">
        <h2 class="heading "><span>&#35838;&#22806;&#25193;&#23637;-&#20114;&#26021;&#20307;&#38450;&#27490;&#31243;&#24207;&#22810;&#24320;</span></h2>
<p   
>CreateMutex函数的返回值MSDN Library的介绍是这样的：<strong class=" ">如果函数成功，返回值是一个指向mutex对象的句柄；如果命名的mutex对象在函数调用前已经存在，函数返回现有对象的句柄，GetLastError返回ERROR_ALREADY_EXISTS（表示互斥体以及存在）；否则，调用者创建该mutex对象；如果函数失败，返回值为NULL，要获得扩展的错误信息，请调用GetLastError获取</strong>。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_16-53-41.png" alt="images/download/attachments/12714992/image2021-5-27_16-53-41.png" width="400"  />
    </p>
<p   
>所以我们可以利用互斥体来防止程序进行多开：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建互斥体</code></div>
<div class="line"><code class="plain">    HANDLE cm = CreateMutex(NULL, TRUE, </code><code class="string">"XYZ"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断互斥体是否创建失败</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (cm != NULL) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 判断互斥体是否已经存在，如果存在则表示程序被多次打开</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (GetLastError() == ERROR_ALREADY_EXISTS) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"该程序已经开启了，请勿再次开启！"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            getchar();</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</code></div>
<div class="line"><code class="plain">            WaitForSingleObject(cm, INFINITE);</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 操作资源</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">5</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Process: A Thread: B -- %d \n"</code><code class="plain">, i);</code></div>
<div class="line"><code class="plain">                Sleep(</code><code class="value">1000</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 释放令牌</code></div>
<div class="line"><code class="plain">            ReleaseMutex(cm);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateMutex 创建失败! 错误代码: %d\n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-27_17-7-1.png" alt="images/download/attachments/12714992/image2021-5-27_17-7-1.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5LqL5Lu2">
        <h1 class="heading "><span>&#20107;&#20214;</span></h1>
<p   
>事件本身也是一种内核对象，其也是是用来控制线程的。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6YCa55-l57G75Z6L">
        <h2 class="heading "><span>&#36890;&#30693;&#31867;&#22411;</span></h2>
<p   
>事件本身可以做为通知类型来使用，创建事件使用函数<strong class=" ">CreateEvent</strong>，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateEvent(</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpEventAttributes, </code><code class="comments">// SD 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  BOOL bManualReset,                       </code><code class="comments">// reset type 如果你希望当前事件类型是通知类型则写TRUE，反之FALSE</code></div>
<div class="line"><code class="plain">  BOOL bInitialState,                      </code><code class="comments">// initial state 初始状态，决定创建出来时候是否有信号，有为TRUE，没有为FALSE</code></div>
<div class="line"><code class="plain">  LPCTSTR lpName                           </code><code class="comments">// object name 事件名字</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>那么通知类型到底是什么？我们可以写一段代码来看一下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">HANDLE e_event;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 等待事件</code></div>
<div class="line"><code class="plain">    WaitForSingleObject(e_event, INFINITE);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"ThreadProc - running ...\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProcB(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 等待事件</code></div>
<div class="line"><code class="plain">    WaitForSingleObject(e_event, INFINITE);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"ThreadProcB - running ...\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建事件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 第三个参数表示初始状态没有信号</code></div>
<div class="line"><code class="plain">    e_event = CreateEvent(NULL, TRUE, FALSE, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建2个线程</code></div>
<div class="line"><code class="plain">    HANDLE hThread[</code><code class="value">2</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">0</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">1</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProcB, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置事件为已通知，也就是设置为有信号</code></div>
<div class="line"><code class="plain">    SetEvent(e_event);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 等待线程执行结束，销毁内核对象</code></div>
<div class="line"><code class="plain">    WaitForMultipleObjects(</code><code class="value">2</code><code class="plain">, hThread, TRUE, INFINITE);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">0</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">1</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 事件类型也是内核对象，所以也需要关闭句柄</code></div>
<div class="line"><code class="plain">    CloseHandle(e_event);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如下图所示，我们运行了代码，会发现两个线程都执行了，而如果是之前我<strong class=" ">们使用互斥体的话则线程A先执行然后线程B等待线程A归还令牌（执行结束）才会执行</strong>，这里我们在线程函数的最后使用了getchar()阻止了线程执行结束，但是两个线程还是都执行了：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_17-55-17.png" alt="images/download/attachments/12714992/image2021-5-28_17-55-17.png" width="600"  />
    </p>
<p   
>我们修改下创建事件函数的参数为互斥，来看一下，那么互斥和通知类型的区别一下就很明显的展示出来了：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_17-53-36.png" alt="images/download/attachments/12714992/image2021-5-28_17-53-36.png" width="600"  />
    </p>
<p   
>那么通知类型实现的原理是什么呢？实际上这个跟WaitForSingleObject函数有关，我们可以看下MSDN Library对该函数的介绍：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_17-2-34.png" alt="images/download/attachments/12714992/image2021-5-28_17-2-34.png" width="400"  />
    </p>
<p   
>可以很清晰的看见最后说到，该函数会修改内核对象的状态，所以通知类型的原理就很简单了，<strong class=" ">就是当事件对象为通知类型时该函数就不会去修改对象的状态</strong>，这个状态我们可以理解成是占用，<strong class=" ">当WaitForSingleObject函数判断为非占用时就修改内核对象的状态为占用然后向下执行，而其他线程想使用就需要等待</strong>，这就是<strong class=" ">互斥</strong>的概念。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt57q_56iL5ZCM5q2l">
        <h2 class="heading "><span>&#32447;&#31243;&#21516;&#27493;</span></h2>
<p   
><strong class=" ">线程互斥</strong>：线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>
<p   
><strong class=" ">线程同步</strong>： 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，<strong class=" ">互斥并不代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态</strong>，所以同步就是<strong class=" ">互斥加上有序</strong>。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt55Sf5Lqn6ICF5LiO5raI6LS56ICF">
        <h3 class="heading "><span>&#29983;&#20135;&#32773;&#19982;&#28040;&#36153;&#32773;</span></h3>
<p   
>想要证明事件和互斥体最本质的区别，我们可以使用生产者与消费者模型来举例子，那么这个模型是什么意思呢？</p>
    <div  class="confbox admonition admonition-info">
                            <span class="admonition-icon confluence-information-macro-icon"></span>
                <div class="admonition-body">
<p   
>生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合（依赖性）问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
        </div>
    </div>
<p   
>我们就可以理解为生产者生产一个物品，将其放进容器里，然后消费者从容器中取物品进行消费，就这样&ldquo;按部就班&rdquo;下去...</p>
    <div class="section section-4" id="src-12714992_safe-id-V2luMzIt5LqS5pal5L2TLjE">
        <h4 class="heading "><span>&#20114;&#26021;&#20307;</span></h4>
<p   
>首先我们来写一段互斥体下的生产者与消费者的代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 容器</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> container;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 次数</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> count = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 互斥体</code></div>
<div class="line"><code class="plain">HANDLE hMutex;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 生产者</code></div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; count; i++) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 等待互斥体，获取令牌</code></div>
<div class="line"><code class="plain">        WaitForSingleObject(hMutex, INFINITE);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 获取当前进程ID</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> threadId = GetCurrentThreadId();</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 生产存放进容器</code></div>
<div class="line"><code class="plain">        container = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Thread: %d, Build: %d \n"</code><code class="plain">, threadId, container);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 释放令牌</code></div>
<div class="line"><code class="plain">        ReleaseMutex(hMutex);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 消费者</code></div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProcB(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; count; i++) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 等待互斥体，获取令牌</code></div>
<div class="line"><code class="plain">        WaitForSingleObject(hMutex, INFINITE);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 获取当前进程ID</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> threadId = GetCurrentThreadId();</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Thread: %d, Consume: %d \n"</code><code class="plain">, threadId, container);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 消费</code></div>
<div class="line"><code class="plain">        container = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 释放令牌</code></div>
<div class="line"><code class="plain">        ReleaseMutex(hMutex);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建互斥体</code></div>
<div class="line"><code class="plain">    hMutex = CreateMutex(NULL, FALSE, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建2个线程</code></div>
<div class="line"><code class="plain">    HANDLE hThread[</code><code class="value">2</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">0</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">1</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProcB, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    WaitForMultipleObjects(</code><code class="value">2</code><code class="plain">, hThread, TRUE, INFINITE);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">0</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">1</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    CloseHandle(hMutex);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>运行结果如下图所示：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_17-57-34.png" alt="images/download/attachments/12714992/image2021-5-28_17-57-34.png" width="600"  />
    </p>
<p   
>我们可以清晰的看见结果并不是我们想要的，生产一次消费一次的有序进行，甚至还出现了先消费后生产的情况，这个问题我们可以去修改代码解决：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_18-3-24.png" alt="images/download/attachments/12714992/image2021-5-28_18-3-24.png" width="600"  />
    </p>
<p   
>这样虽然看似解决了问题，但是实际上也同样会出现一种问题，那就是for循环执行了不止10次，这样会倒是过分的<strong class=" ">占用计算资源</strong>。</p>
    </div>
    <div class="section section-4" id="src-12714992_safe-id-V2luMzIt5LqL5Lu2LjE">
        <h4 class="heading "><span>&#20107;&#20214;</span></h4>
<p   
>我们使用事件的方式就可以更加完美的解决这一需求：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 容器</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> container = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 次数</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> count = </code><code class="value">10</code><code class="plain">;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 事件</code></div>
<div class="line"><code class="plain">HANDLE eventA;</code></div>
<div class="line"><code class="plain">HANDLE eventB;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 生产者</code></div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; count; i++) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 等待事件，修改事件A状态</code></div>
<div class="line"><code class="plain">        WaitForSingleObject(eventA, INFINITE);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 获取当前进程ID</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> threadId = GetCurrentThreadId();</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 生产存放进容器</code></div>
<div class="line"><code class="plain">        container = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Thread: %d, Build: %d \n"</code><code class="plain">, threadId, container);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 给eventB设置信号</code></div>
<div class="line"><code class="plain">        SetEvent(eventB);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 消费者</code></div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProcB(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; count; i++) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 等待事件，修改事件B状态</code></div>
<div class="line"><code class="plain">        WaitForSingleObject(eventB, INFINITE);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 获取当前进程ID</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> threadId = GetCurrentThreadId();</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Thread: %d, Consume: %d \n"</code><code class="plain">, threadId, container);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 消费</code></div>
<div class="line"><code class="plain">        container = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 给eventA设置信号</code></div>
<div class="line"><code class="plain">        SetEvent(eventA);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建事件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 线程同步的前提是互斥</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 顺序按照先生产后消费，所以事件A设置信号，事件B需要通过生产者线程来设置信号</code></div>
<div class="line"><code class="plain">    eventA = CreateEvent(NULL, FALSE, TRUE, NULL);</code></div>
<div class="line"><code class="plain">    eventB = CreateEvent(NULL, FALSE, FALSE, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建2个线程</code></div>
<div class="line"><code class="plain">    HANDLE hThread[</code><code class="value">2</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">0</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    hThread[</code><code class="value">1</code><code class="plain">] = CreateThread(NULL, NULL, ThreadProcB, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    WaitForMultipleObjects(</code><code class="value">2</code><code class="plain">, hThread, TRUE, INFINITE);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">0</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread[</code><code class="value">1</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 事件类型也是内核对象，所以也需要关闭句柄</code></div>
<div class="line"><code class="plain">    CloseHandle(eventA);</code></div>
<div class="line"><code class="plain">    CloseHandle(eventB);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>运行结果如下图：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_18-13-7.png" alt="images/download/attachments/12714992/image2021-5-28_18-13-7.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt56qX5Y-j55qE5pys6LSo">
        <h1 class="heading "><span>&#31383;&#21475;&#30340;&#26412;&#36136;</span></h1>
<p   
>之前我们学习写的程序都是基于控制台的，而从本章开始学习图形化界面相关的知识。</p>
<p   
>之前我们所学习的进程、线程之类的函数，其接口来源于kernel32.dll &rarr; ntoskrnl.exe；而我们要学习的图形化界面的接口，它就来源于user32.dll、gdi32.dll &rarr; win32k.sys。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_18-21-33.png" alt="images/download/attachments/12714992/image2021-5-28_18-21-33.png" width="400"  />
    </p>
<p   
>user32.dll和gdi32.dll的区别在哪呢？<strong class=" ">前者是你想使用Windows已经画好的界面就用它，我们称之为GUI编程；后者是你想自己画一个界面，例如你要画一朵花，那么就使用后者，因为这涉及到绘图相关的内容，我们称之为GDI编程</strong>。</p>
<p   
>之前我们了解过HANDLE句柄，其都是私有的，而在图形界面中有一个<strong class=" ">新的句柄</strong>，其叫HWND，win32k.sys提供在内核层创建图形化界面，我们想要在应用层调用就需要对应的句柄HWND，<strong class=" ">而这个句柄表是全局的，并且只有一个</strong>。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_19-37-31.png" alt="images/download/attachments/12714992/image2021-5-28_19-37-31.png" width="400"  />
    </p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItR0RJLeWbvuW9ouiuvuWkh-aOpeWPow">
        <h2 class="heading "><span>GDI - &#22270;&#24418;&#35774;&#22791;&#25509;&#21475;</span></h2>
<p   
>GDI是Graphics Device Interface的缩写，其中文为图形设备接口。</p>
<p   
>本章主要是学习如何进行GDI编程，但是我们在日常的工作中是不需要用到的，并且没有什么实际意义（需要的都有现成的），我们学习它就是为了来了解窗口的本质、<strong class=" ">消息机制</strong>的本质。</p>
<p   
>关于GDI有这么几个概念：</p>
<ol class=" "><li class=" "><p   
>设备对象：画的位置</p>
</li><li class=" "><p   
>DC（Device Contexts）：设备上下文对象（内存）</p>
</li><li class=" "><p   
>图像（图形）对象：决定你要画的东西的属性</p>
</li></ol><p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_19-39-33.png" alt="images/download/attachments/12714992/image2021-5-28_19-39-33.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6L-b6KGM566A5Y2V55qE57uY55S7">
        <h2 class="heading "><span>&#36827;&#34892;&#31616;&#21333;&#30340;&#32472;&#30011;</span></h2>
<p   
>如下代码就是在桌面中进行绘画，具体代码意思都在注释中了，不了解的可以在MSDN Library中查询：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    HWND hWnd; </code><code class="comments">// 窗口句柄</code></div>
<div class="line"><code class="plain">    HDC hDc; </code><code class="comments">// 设备上下文对象</code></div>
<div class="line"><code class="plain">    HPEN hPen; </code><code class="comments">// 画笔</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 设备对象，要绘画的位置</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置为NULL则表示在桌面中绘画</code></div>
<div class="line"><code class="plain">    hWnd = (HWND)NULL;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 获取设备的上下文对象（DC）</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        语法格式：</code></div>
<div class="line"><code class="comments">        HDC GetDC(</code></div>
<div class="line"><code class="comments">            HWND hWnd   // handle to window</code></div>
<div class="line"><code class="comments">        );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    hDc = GetDC(hWnd);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 创建画笔，设置线条的属性</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        语法格式：</code></div>
<div class="line"><code class="comments">        HPEN CreatePen(</code></div>
<div class="line"><code class="comments">            int fnPenStyle,    // pen style</code></div>
<div class="line"><code class="comments">            int nWidth,        // pen width</code></div>
<div class="line"><code class="comments">            COLORREF crColor   // pen color</code></div>
<div class="line"><code class="comments">        );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    hPen = CreatePen(PS_SOLID, </code><code class="value">5</code><code class="plain">, RGB(</code><code class="value">0xFF</code><code class="plain">,</code><code class="value">00</code><code class="plain">,</code><code class="value">00</code><code class="plain">)); </code><code class="comments">// RGB表示红绿蓝，红绿蓝的组合就可以组成新的一种颜色。</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 关联</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        语法格式：</code></div>
<div class="line"><code class="comments">        HGDIOBJ SelectObject(</code></div>
<div class="line"><code class="comments">            HDC hdc,          // handle to DC</code></div>
<div class="line"><code class="comments">            HGDIOBJ hgdiobj   // handle to object</code></div>
<div class="line"><code class="comments">        );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    SelectObject(hDc, hPen);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 开始画线</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">        语法格式：</code></div>
<div class="line"><code class="comments">        BOOL LineTo(</code></div>
<div class="line"><code class="comments">            HDC hdc,    // device context handle</code></div>
<div class="line"><code class="comments">            int nXEnd,  // x-coordinate of ending point</code></div>
<div class="line"><code class="comments">            int nYEnd   // y-coordinate of ending point</code></div>
<div class="line"><code class="comments">        );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    LineTo(hDc, </code><code class="value">400</code><code class="plain">, </code><code class="value">400</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 释放资源</code></div>
<div class="line"><code class="plain">    DeleteObject(hPen);</code></div>
<div class="line"><code class="plain">    ReleaseDC(hWnd, hDc);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_21-32-45.png" alt="images/download/attachments/12714992/image2021-5-28_21-32-45.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5raI5oGv6Zif5YiX">
        <h1 class="heading "><span>&#28040;&#24687;&#38431;&#21015;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv5raI5oGv">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#28040;&#24687;</span></h2>
<p   
>当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，存储到一个结构体中，这个<strong class=" ">结构体</strong>就是消息。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5raI5oGv6Zif5YiXLjE">
        <h2 class="heading "><span>&#28040;&#24687;&#38431;&#21015;</span></h2>
<p   
>每个线程只有一个消息队列。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_21-47-51.png" alt="images/download/attachments/12714992/image2021-5-28_21-47-51.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt56qX5Y-j5LiO57q_56iL">
        <h2 class="heading "><span>&#31383;&#21475;&#19982;&#32447;&#31243;</span></h2>
<p   
>当我们把鼠标点击左边窗口关闭按钮，为什么它会关闭，这个关闭（坐标、左右键...）操作系统会封装到结构体里（消息），那么这个消息如何精确的传递给对应进程的线程呢？</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_21-52-48.png" alt="images/download/attachments/12714992/image2021-5-28_21-52-48.png"  height="250" />
    </p>
<p   
>那是因为操作系统可以将坐标之类的作为索引，去找到对应的窗口，窗口在内核中是有窗口对象的，而这个窗口对象就会包含一个成员，这个成员就是线程对象的指针，线程又包含了消息，所以这样一个顺序就很容易理解了。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-28_21-57-18.png" alt="images/download/attachments/12714992/image2021-5-28_21-57-18.png"  height="250" />
    </p>
<p   
>注意：一个线程可以有多个窗口，但是一个窗口只属于一个线程。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt56ys5LiA5LiqV2luZHdvc-eoi-W6jw">
        <h1 class="heading "><span>&#31532;&#19968;&#20010;Windwos&#31243;&#24207;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5paw5bu6V2luZG93c-eql-WPo-eoi-W6j-mhueebrg">
        <h2 class="heading "><span>&#26032;&#24314;Windows&#31383;&#21475;&#31243;&#24207;&#39033;&#30446;</span></h2>
<p   
>VC6新建工程，选择Win32 Application，下一步选择一个简单的Win32的程序。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-30_22-6-47.png" alt="images/download/attachments/12714992/image2021-5-30_22-6-47.png" width="600"  />
    </p>
<p   
>控制台程序是从Main函数为入口开始执行的，而Win32窗口程序是从WinMain函数开始执行的。</p>
<p   
>新建的项目里的头文件已经把需要用到的Windows.h头文件包含了：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-5-30_22-7-34.png" alt="images/download/attachments/12714992/image2021-5-30_22-7-34.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItV2luTWFpbuWHveaVsA">
        <h2 class="heading "><span>WinMain&#20989;&#25968;</span></h2>
<p   
>WinMain函数作为Win32窗口程序的入口函数，我们需要了解一下其函数的参数，语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> WINAPI WinMain(</code></div>
<div class="line"><code class="plain">  HINSTANCE hInstance,      </code><code class="comments">// handle to current instance</code></div>
<div class="line"><code class="plain">  HINSTANCE hPrevInstance,  </code><code class="comments">// handle to previous instance </code></div>
<div class="line"><code class="plain">  LPSTR lpCmdLine,          </code><code class="comments">// command line</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> nCmdShow              </code><code class="comments">// show state</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>参数解释：</p>
<ol class=" "><li class=" "><p   
>HINSTANCE hInstance，这是一个句柄，在Win32中H开头的通常都是句柄，这里的HINSTANCE是指向模块的句柄，实际上这个值就是模块在进程空间内的内存地址；</p>
</li><li class=" "><p   
>HINSTANCE hPrevInstance，该参数永远为空NULL，无需理解；</p>
</li><li class=" "><p   
>第三、第四个参数（LPSTR lpCmdLine、int nCmdShow）是由CreateProcess的LPTSTR lpCommandLine、LPSTARTUPINFO lpStartupInfo参数传递的。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6LCD6K-V5L-h5oGv6L6T5Ye6">
        <h2 class="heading "><span>&#35843;&#35797;&#20449;&#24687;&#36755;&#20986;</span></h2>
<p   
>我们在窗口程序中想要输出信息就不可以使用printf了，我们可以使用另外一个函数OutputDebugString，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> OutputDebugString(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpOutputString</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>传参就是一个LPCTSTR类型（字符串），但是需要注意的是这个函数只能打印固定字符串，不能打印格式化的字符串，所以如果需要格式化输出，需要在这之前使用sprintf函数进行格式化（自行查阅），这里我们可以尝试输出当前模块的句柄：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> APIENTRY WinMain(HINSTANCE hInstance,</code></div>
<div class="line"><code class="plain">                     HINSTANCE hPrevInstance,</code></div>
<div class="line"><code class="plain">                     LPSTR     lpCmdLine,</code></div>
<div class="line"><code class="plain">                     </code><code class="keyword">int</code><code class="plain">       nCmdShow)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// TODO: Place code here.</code></div>
<div class="line"><code class="plain">    DWORD dwAddr = (DWORD)hInstance;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    sprintf(szOutBuff, </code><code class="string">"hInstance address: %x \n"</code><code class="plain">, dwAddr); </code><code class="comments">// 该函数需要包含stdio.h头文件</code></div>
<div class="line"><code class="plain">    OutputDebugString(szOutBuff);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>运行该代码就会在Debug输出框中发现打印的字符串，这就是一个内存地址：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_13-46-20.png" alt="images/download/attachments/12714992/image2021-6-1_13-46-20.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Yib5bu656qX5Y-j56iL5bqP">
        <h2 class="heading "><span>&#21019;&#24314;&#31383;&#21475;&#31243;&#24207;</span></h2>
<p   
>如下代码创建了一个简单的窗口程序：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// Windows.cpp : Defines the entry point for the application.</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 窗口函数定义</code></div>
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> DefWindowProc(hwnd, uMsg, wParam, lParam);</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> APIENTRY WinMain(HINSTANCE hInstance,</code></div>
<div class="line"><code class="plain">                     HINSTANCE hPrevInstance,</code></div>
<div class="line"><code class="plain">                     LPSTR     lpCmdLine,</code></div>
<div class="line"><code class="plain">                     </code><code class="keyword">int</code><code class="plain">       nCmdShow)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 定义创建的窗口(创建注册窗口类)</code></div>
<div class="line"><code class="plain">    TCHAR className[] = TEXT(</code><code class="string">"My First Window"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WNDCLASS wndClass = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置窗口背景色</code></div>
<div class="line"><code class="plain">    wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置类名字</code></div>
<div class="line"><code class="plain">    wndClass.lpszClassName = className;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置模块地址</code></div>
<div class="line"><code class="plain">    wndClass.hInstance = hInstance;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 处理消息的窗口函数</code></div>
<div class="line"><code class="plain">    wndClass.lpfnWndProc = WindowProc; </code><code class="comments">// 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 注册窗口类</code></div>
<div class="line"><code class="plain">    RegisterClass(&amp;wndClass);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 创建并显示窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    CreateWindow 语法格式：</code></div>
<div class="line"><code class="comments">    HWND CreateWindow(</code></div>
<div class="line"><code class="comments">        LPCTSTR lpClassName,  // registered class name 类名字</code></div>
<div class="line"><code class="comments">        LPCTSTR lpWindowName, // window name 窗口名字</code></div>
<div class="line"><code class="comments">        DWORD dwStyle,        // window style 窗口外观的样式</code></div>
<div class="line"><code class="comments">        int x,                // horizontal position of window 相对于父窗口x坐标</code></div>
<div class="line"><code class="comments">        int y,                // vertical position of window 相对于父窗口y坐标</code></div>
<div class="line"><code class="comments">        int nWidth,           // window width 窗口宽度：像素</code></div>
<div class="line"><code class="comments">        int nHeight,          // window height 窗口长度：像素</code></div>
<div class="line"><code class="comments">        HWND hWndParent,      // handle to parent or owner window 父窗口句柄</code></div>
<div class="line"><code class="comments">        HMENU hMenu,          // menu handle or child identifier 菜单句柄</code></div>
<div class="line"><code class="comments">        HINSTANCE hInstance,  // handle to application instance 模块</code></div>
<div class="line"><code class="comments">        LPVOID lpParam        // window-creation data  附加数据</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    HWND hWnd = CreateWindow(className, TEXT(</code><code class="string">"窗口"</code><code class="plain">), WS_OVERLAPPEDWINDOW, </code><code class="value">10</code><code class="plain">, </code><code class="value">10</code><code class="plain">, </code><code class="value">600</code><code class="plain">, </code><code class="value">300</code><code class="plain">, NULL, NULL, hInstance, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hWnd == NULL) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 如果为NULL则窗口创建失败，输出错误信息</code></div>
<div class="line"><code class="plain">        sprintf(szOutBuff, </code><code class="string">"Error: %d"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 显示窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    ShowWindow 语法格式：</code></div>
<div class="line"><code class="comments">    BOOL ShowWindow(</code></div>
<div class="line"><code class="comments">        HWND hWnd,     // handle to window 窗口句柄</code></div>
<div class="line"><code class="comments">        int nCmdShow   // show state 显示的形式</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    ShowWindow(hWnd, SW_SHOW);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 接收消息并处理</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    GetMessage 语法格式：</code></div>
<div class="line"><code class="comments">    BOOL GetMessage(</code></div>
<div class="line"><code class="comments">        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针</code></div>
<div class="line"><code class="comments">        // 后三个参数都是过滤条件</code></div>
<div class="line"><code class="comments">        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要</code></div>
<div class="line"><code class="comments">        UINT wMsgFilterMin,  // first message 第一条信息</code></div>
<div class="line"><code class="comments">        UINT wMsgFilterMax   // last message 最后一条信息</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    MSG msg;</code></div>
<div class="line"><code class="plain">    BOOL bRet;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain">( (bRet = GetMessage( &amp;msg, NULL, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain"> )) != </code><code class="value">0</code><code class="plain">)</code></div>
<div class="line"><code class="plain">    { </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (bRet == -</code><code class="value">1</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// handle the error and possibly exit</code></div>
<div class="line"><code class="plain">            sprintf(szOutBuff, </code><code class="string">"Error: %d"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">            OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">else</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 转换消息</code></div>
<div class="line"><code class="plain">            TranslateMessage(&amp;msg);</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 分发消息：就是给系统调用窗口处理函数</code></div>
<div class="line"><code class="plain">            DispatchMessage(&amp;msg);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>如下图是窗口程序创建执行流程：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_14-34-8.png" alt="images/download/attachments/12714992/image2021-6-1_14-34-8.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5raI5oGv57G75Z6L">
        <h1 class="heading "><span>&#28040;&#24687;&#31867;&#22411;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5raI5oGv55qE5Lqn55Sf5LiO5aSE55CG5rWB56iL">
        <h2 class="heading "><span>&#28040;&#24687;&#30340;&#20135;&#29983;&#19982;&#22788;&#29702;&#27969;&#31243;</span></h2>
<p   
>消息的产生与处理流程，从消息发起这个点开始说，假设我们点击了某个窗口时就会产生一个消息，操作系统得到这个消息后先判断当前点击的是哪个窗口，找到对应的窗口对象，再根据窗口对象的里的某一个成员找到对应线程，一旦找到了对应线程，操作系统就会把封装好的消息（这是一个结构体，包含了你鼠标点击的坐标等等消息）存到对应的消息队列里，应用程序就会通过GetMessage不停的从消息队列中取消息。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_14-46-15.png" alt="images/download/attachments/12714992/image2021-6-1_14-46-15.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5raI5oGv57uT5p6E5L2T">
        <h2 class="heading "><span>&#28040;&#24687;&#32467;&#26500;&#20307;</span></h2>
<p   
>我们是通过GetMessage函数接收消息的，其第一个参数就是接收的消息（结构体），所以可以在之前的<strong class=" ">代码中选中MSG然后F12</strong>跟进看一下消息结构体的定义：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_14-48-40.png" alt="images/download/attachments/12714992/image2021-6-1_14-48-40.png" width="600"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">typedef struct tagMSG {</code></div>
<div class="line"><code class="plain">  HWND   hwnd;      </code><code class="comments">// 所属窗口句柄</code></div>
<div class="line"><code class="plain">  UINT   message;   </code><code class="comments">// 消息类型：编号</code></div>
<div class="line"><code class="plain">  WPARAM wParam;    </code><code class="comments">// 附加数据，进一步描述消息的</code></div>
<div class="line"><code class="plain">  LPARAM lParam;    </code><code class="comments">// 附加数据，进一步描述消息的</code></div>
<div class="line"><code class="plain">  DWORD  time;      </code><code class="comments">// 消息产生的时间</code></div>
<div class="line"><code class="plain">  POINT  pt;        </code><code class="comments">// 在哪里产生的</code></div>
<div class="line"><code class="plain">} MSG, *PMSG; </code></div>
</div>
    </div>
<p   
>能产生消息的情况有四种情况：<strong class=" ">1. 键盘 2. 鼠标 3. 其他应用程序 4. 操作系统内核程序</strong>，有这么多消息要处理，所以操作系统会将所有消息区分类别，每个消息都有独一无二的编号。</p>
<p   
>消息这个结构体存储的信息也不多，只能知道消息属于哪个窗口，根本不知道对应窗口函数是什么，所以我们不得不在之后对消息进行分发（DispatchMessage函数），而后由内核发起调用来执行窗口函数。</p>
<p   
>换而言之，我们这个消息的结构体实际上就是<strong class=" ">传递给了窗口函数</strong>，<strong class=" ">其四个参数对应着消息结构体的前四个成员</strong>。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5raI5oGv57G75Z6LLjE">
        <h2 class="heading "><span>&#28040;&#24687;&#31867;&#22411;</span></h2>
<p   
>我们想要关注自己想要关注的消息类型，首先可以在窗口函数中打印消息类型来看看都有什么消息类型：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 窗口函数定义</code></div>
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    sprintf(szOutBuff, </code><code class="string">"Message: %x - %x \n"</code><code class="plain">, hwnd, uMsg);</code></div>
<div class="line"><code class="plain">    OutputDebugString(szOutBuff);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> DefWindowProc(hwnd, uMsg, wParam, lParam);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_23-41-40.png" alt="images/download/attachments/12714992/image2021-6-1_23-41-40.png" width="600"  />
    </p>
<p   
>可以看见这边输出了一个0x1，想要知道这个对应着什么，我们可以在<strong class=" ">C:\Program Files\Microsoft Visual Studio\VC98\Include</strong>目录中找到<strong class=" ">WINUSER.H</strong>这个文件来查看，搜索0x0001就可以找到：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-1_23-46-11.png" alt="images/download/attachments/12714992/image2021-6-1_23-46-11.png" width="600"  />
    </p>
<p   
>那么我们可以看见对应的宏就是<strong class=" ">WM_CREATE</strong>，这个消息的意思就是窗口创建，所以我们有很多消息是不需要关注的，而且消息时刻都在产生，非常非常多。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5aSE55CG56qX5Y-j5YWz6Zet">
        <h3 class="heading "><span>&#22788;&#29702;&#31383;&#21475;&#20851;&#38381;</span></h3>
<p   
>在窗口关闭时，实际上进程并不会关闭，所以我们需要在窗口函数中筛选条件，当窗口关闭了就退出进程。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 窗口函数定义</code></div>
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">switch</code><code class="plain">(uMsg) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当窗口关闭则退出进程</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> WM_DESTROY:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            PostQuitMessage(</code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> DefWindowProc(hwnd, uMsg, wParam, lParam);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5aSE55CG6ZSu55uY5oyJ5LiL">
        <h3 class="heading "><span>&#22788;&#29702;&#38190;&#30424;&#25353;&#19979;</span></h3>
<p   
>我们除了可以处理窗口关闭，处理键盘按下也是没问题的，键盘按下的宏是WM_KEYDOWN，但是我们想要按下a这个键之后才处理该怎么办？首先我们需要查阅一下MSDN Library：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(</code></div>
<div class="line"><code class="plain">  HWND hwnd,       </code><code class="comments">// handle to window</code></div>
<div class="line"><code class="plain">  UINT uMsg,       </code><code class="comments">// WM_KEYDOWN</code></div>
<div class="line"><code class="plain">  WPARAM wParam,   </code><code class="comments">// virtual-key code</code></div>
<div class="line"><code class="plain">  LPARAM lParam    </code><code class="comments">// key data</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>可以很清楚的看见窗口函数的第三个参数就是虚拟键码（键盘上每个键都对应一个虚拟键码），我们可以输出下按下a，其对应虚拟键码是什么：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 窗口函数定义</code></div>
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">switch</code><code class="plain">(uMsg) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当键盘按下则处理</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> WM_KEYDOWN:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">            sprintf(szOutBuff, </code><code class="string">"keycode: %x \n"</code><code class="plain">, wParam);</code></div>
<div class="line"><code class="plain">            OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> DefWindowProc(hwnd, uMsg, wParam, lParam);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_0-10-19.png" alt="images/download/attachments/12714992/image2021-6-2_0-10-19.png" width="600"  />
    </p>
<p   
>如上图所示，按下a之后输出的虚拟键码是0x41，所以我们可以根据这个来进行判断。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6L2s5o2i5raI5oGv">
        <h2 class="heading "><span>&#36716;&#25442;&#28040;&#24687;</span></h2>
<p   
>之前我们举例可以处理键盘按下的消息，但是我们想要直观的看到底输入了什么而不是虚拟键码该怎么办？这时候我们就需要使用WM_CHAR这个宏了，但是在这之前，我们的消息是必须要经过转换的，只有其转换了，我们的虚拟键码才能变成具体的字符。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_0-17-29.png" alt="images/download/attachments/12714992/image2021-6-2_0-17-29.png" width="600"  />
    </p>
<p   
>WM_CHAR宏对应的窗口函数参数作用如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(</code></div>
<div class="line"><code class="plain">  HWND hwnd,       </code><code class="comments">// handle to window</code></div>
<div class="line"><code class="plain">  UINT uMsg,       </code><code class="comments">// WM_CHAR</code></div>
<div class="line"><code class="plain">  WPARAM wParam,   </code><code class="comments">// character code (TCHAR)</code></div>
<div class="line"><code class="plain">  LPARAM lParam    </code><code class="comments">// key data</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>第三个参数就是字符所以我们直接输出这个即可：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_0-16-57.png" alt="images/download/attachments/12714992/image2021-6-2_0-16-57.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5a2Q56qX5Y-j5o6n5Lu2">
        <h1 class="heading "><span>&#23376;&#31383;&#21475;&#25511;&#20214;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YWz5LqO5a2Q56qX5Y-j5o6n5Lu2">
        <h2 class="heading "><span>&#20851;&#20110;&#23376;&#31383;&#21475;&#25511;&#20214;</span></h2>
<ol class=" "><li class=" "><p   
>Windows提供了几个预定义的窗口类以方便我们的使用，我们一般叫它们为子窗口控件，简称控件；</p>
</li><li class=" "><p   
>控件会自己处理消息，并在自己状态发生改变时通知父窗口；</p>
</li><li class=" "><p   
>预定义的控件有：按钮、复选框、编辑框、静态字符串标签和滚动条等。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Yib5bu657yW6L6R5qGG5ZKM5oyJ6ZKu">
        <h2 class="heading "><span>&#21019;&#24314;&#32534;&#36753;&#26694;&#21644;&#25353;&#38062;</span></h2>
<p   
>我们想使用子窗口控件可以使用CreateWindow函数来创建，创建位置我们可以选在窗口函数中，当窗口创建则开始创建子窗口控件。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// Windows.cpp : Defines the entry point for the application.</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"><code class="comments">// 定义子窗口标识</code></div>
<div class="line"><code class="plain">#define CWA_EDIT </code><code class="value">0x100</code></div>
<div class="line"><code class="plain">#define CWA_BUTTON_0 </code><code class="value">0x101</code></div>
<div class="line"><code class="plain">#define CWA_BUTTON_1 </code><code class="value">0x102</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 定义全局模块</code></div>
<div class="line"><code class="plain">HINSTANCE gHinstance;</code></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><code class="comments">// 窗口函数定义</code></div>
<div class="line"><code class="plain">LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">switch</code><code class="plain"> (uMsg) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当键盘按下则处理</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> WM_CHAR:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">            sprintf(szOutBuff, </code><code class="string">"keycode: %c \n"</code><code class="plain">, wParam);</code></div>
<div class="line"><code class="plain">            OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当窗口创建则开始创建子窗口控件</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> WM_CREATE:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 创建编辑框</code></div>
<div class="line"><code class="plain">            CreateWindow(</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">"EDIT"</code><code class="plain">),  </code><code class="comments">// registered class name 注册的类名，使用EDIT则为编辑框</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">""</code><code class="plain">), </code><code class="comments">// window name 窗口名称</code></div>
<div class="line"><code class="plain">                WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE,        </code><code class="comments">// window style 子窗口控件样式：子窗口、创建后可以看到、滚动条、自动换行</code></div>
<div class="line"><code class="plain">                </code><code class="value">0</code><code class="plain">,                </code><code class="comments">// horizontal position of window 在父窗口上的x坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">0</code><code class="plain">,                </code><code class="comments">// vertical position of window 在父窗口上的y坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">400</code><code class="plain">,           </code><code class="comments">// window width 控件宽度</code></div>
<div class="line"><code class="plain">                </code><code class="value">300</code><code class="plain">,          </code><code class="comments">// window height 控件高度</code></div>
<div class="line"><code class="plain">                hwnd,      </code><code class="comments">// menu handle or child identifier 父窗口句柄</code></div>
<div class="line"><code class="plain">                (HMENU)CWA_EDIT,          </code><code class="comments">// menu handle or child identifier 子窗口标识</code></div>
<div class="line"><code class="plain">                gHinstance,  </code><code class="comments">// handle to application instance 模块</code></div>
<div class="line"><code class="plain">                NULL        </code><code class="comments">// window-creation data 附加数据</code></div>
<div class="line"><code class="plain">            );</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            </code><code class="comments">// 创建"设置"按钮</code></div>
<div class="line"><code class="plain">            CreateWindow(</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">"BUTTON"</code><code class="plain">),  </code><code class="comments">// registered class name 注册的类名，使用BUTTON则为按钮</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">"设置"</code><code class="plain">), </code><code class="comments">// window name 按钮名称</code></div>
<div class="line"><code class="plain">                WS_CHILD | WS_VISIBLE,        </code><code class="comments">// window style 子窗口控件样式：子窗口、创建后可以看到</code></div>
<div class="line"><code class="plain">                </code><code class="value">450</code><code class="plain">,                </code><code class="comments">// horizontal position of window 在父窗口上的x坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">150</code><code class="plain">,                </code><code class="comments">// vertical position of window 在父窗口上的y坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">80</code><code class="plain">,           </code><code class="comments">// window width 控件宽度</code></div>
<div class="line"><code class="plain">                </code><code class="value">20</code><code class="plain">,          </code><code class="comments">// window height 控件高度</code></div>
<div class="line"><code class="plain">                hwnd,      </code><code class="comments">// menu handle or child identifier 父窗口句柄</code></div>
<div class="line"><code class="plain">                (HMENU)CWA_BUTTON_0,          </code><code class="comments">// menu handle or child identifier 子窗口标识</code></div>
<div class="line"><code class="plain">                gHinstance,  </code><code class="comments">// handle to application instance 模块</code></div>
<div class="line"><code class="plain">                NULL        </code><code class="comments">// window-creation data 附加数据</code></div>
<div class="line"><code class="plain">            );</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            </code><code class="comments">// 创建"获取"按钮</code></div>
<div class="line"><code class="plain">            CreateWindow(</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">"BUTTON"</code><code class="plain">),  </code><code class="comments">// registered class name 注册的类名，使用BUTTON则为按钮</code></div>
<div class="line"><code class="plain">                TEXT(</code><code class="string">"获取"</code><code class="plain">), </code><code class="comments">// window name 按钮名称</code></div>
<div class="line"><code class="plain">                WS_CHILD | WS_VISIBLE,        </code><code class="comments">// window style 子窗口控件样式：子窗口、创建后可以看到</code></div>
<div class="line"><code class="plain">                </code><code class="value">450</code><code class="plain">,                </code><code class="comments">// horizontal position of window 在父窗口上的x坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">100</code><code class="plain">,                </code><code class="comments">// vertical position of window 在父窗口上的y坐标</code></div>
<div class="line"><code class="plain">                </code><code class="value">80</code><code class="plain">,           </code><code class="comments">// window width 控件宽度</code></div>
<div class="line"><code class="plain">                </code><code class="value">20</code><code class="plain">,          </code><code class="comments">// window height 控件高度</code></div>
<div class="line"><code class="plain">                hwnd,      </code><code class="comments">// menu handle or child identifier 父窗口句柄</code></div>
<div class="line"><code class="plain">                (HMENU)CWA_BUTTON_1,          </code><code class="comments">// menu handle or child identifier 子窗口标识</code></div>
<div class="line"><code class="plain">                gHinstance,  </code><code class="comments">// handle to application instance 模块</code></div>
<div class="line"><code class="plain">                NULL        </code><code class="comments">// window-creation data 附加数据</code></div>
<div class="line"><code class="plain">            );</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当按钮点击则处理</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> WM_COMMAND:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 宏WM_COMMAND中，wParam参数的低16位中有标识，根据标识我们才能判断哪个按钮和编辑框，使用LOWORD()可以获取低16位</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">switch</code><code class="plain"> (LOWORD(wParam)) {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 当按钮为设置</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> CWA_BUTTON_0:</code></div>
<div class="line"><code class="plain">                {</code></div>
<div class="line"><code class="plain">                    </code><code class="comments">// SetDlgItemText函数修改编辑框内容</code></div>
<div class="line"><code class="plain">                    SetDlgItemText(hwnd, (</code><code class="keyword">int</code><code class="plain">)CWA_EDIT, TEXT(</code><code class="string">"HACK THE WORLD"</code><code class="plain">));</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">                }</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 当按钮为获取</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> CWA_BUTTON_1:</code></div>
<div class="line"><code class="plain">                {</code></div>
<div class="line"><code class="plain">                    </code><code class="comments">// MessageBox弹框输出编辑框内容</code></div>
<div class="line"><code class="plain">                    TCHAR szEditBuffer[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"><code class="plain">                    GetDlgItemText(hwnd, (</code><code class="keyword">int</code><code class="plain">)CWA_EDIT, szEditBuffer, </code><code class="value">0x80</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                    MessageBox(NULL, szEditBuffer, NULL, NULL);</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">                }</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> DefWindowProc(hwnd, uMsg, wParam, lParam);</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> APIENTRY WinMain(HINSTANCE hInstance,</code></div>
<div class="line"><code class="plain">                     HINSTANCE hPrevInstance,</code></div>
<div class="line"><code class="plain">                     LPSTR     lpCmdLine,</code></div>
<div class="line"><code class="plain">                     </code><code class="keyword">int</code><code class="plain">       nCmdShow)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> szOutBuff[</code><code class="value">0x80</code><code class="plain">];</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 定义创建的窗口(创建注册窗口类)</code></div>
<div class="line"><code class="plain">    TCHAR className[] = TEXT(</code><code class="string">"My First Window"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WNDCLASS wndClass = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置窗口背景色</code></div>
<div class="line"><code class="plain">    wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置类名字</code></div>
<div class="line"><code class="plain">    wndClass.lpszClassName = className;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 设置模块地址</code></div>
<div class="line"><code class="plain">    gHinstance = hInstance;</code></div>
<div class="line"><code class="plain">    wndClass.hInstance = hInstance;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 处理消息的窗口函数</code></div>
<div class="line"><code class="plain">    wndClass.lpfnWndProc = WindowProc; </code><code class="comments">// 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 注册窗口类</code></div>
<div class="line"><code class="plain">    RegisterClass(&amp;wndClass);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 创建并显示窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    CreateWindow 语法格式：</code></div>
<div class="line"><code class="comments">    HWND CreateWindow(</code></div>
<div class="line"><code class="comments">        LPCTSTR lpClassName,  // registered class name 类名字</code></div>
<div class="line"><code class="comments">        LPCTSTR lpWindowName, // window name 窗口名字</code></div>
<div class="line"><code class="comments">        DWORD dwStyle,        // window style 窗口外观的样式</code></div>
<div class="line"><code class="comments">        int x,                // horizontal position of window 相对于父窗口x坐标</code></div>
<div class="line"><code class="comments">        int y,                // vertical position of window 相对于父窗口y坐标</code></div>
<div class="line"><code class="comments">        int nWidth,           // window width 窗口宽度：像素</code></div>
<div class="line"><code class="comments">        int nHeight,          // window height 窗口长度：像素</code></div>
<div class="line"><code class="comments">        HWND hWndParent,      // handle to parent or owner window 父窗口句柄</code></div>
<div class="line"><code class="comments">        HMENU hMenu,          // menu handle or child identifier 菜单句柄</code></div>
<div class="line"><code class="comments">        HINSTANCE hInstance,  // handle to application instance 模块</code></div>
<div class="line"><code class="comments">        LPVOID lpParam        // window-creation data  附加数据</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    HWND hWnd = CreateWindow(className, TEXT(</code><code class="string">"窗口"</code><code class="plain">), WS_OVERLAPPEDWINDOW, </code><code class="value">10</code><code class="plain">, </code><code class="value">10</code><code class="plain">, </code><code class="value">600</code><code class="plain">, </code><code class="value">300</code><code class="plain">, NULL, NULL, hInstance, NULL);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hWnd == NULL) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 如果为NULL则窗口创建失败，输出错误信息</code></div>
<div class="line"><code class="plain">        sprintf(szOutBuff, </code><code class="string">"Error: %d"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 显示窗口</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    ShowWindow 语法格式：</code></div>
<div class="line"><code class="comments">    BOOL ShowWindow(</code></div>
<div class="line"><code class="comments">        HWND hWnd,     // handle to window 窗口句柄</code></div>
<div class="line"><code class="comments">        int nCmdShow   // show state 显示的形式</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    ShowWindow(hWnd, SW_SHOW);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 接收消息并处理</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    GetMessage 语法格式：</code></div>
<div class="line"><code class="comments">    BOOL GetMessage(</code></div>
<div class="line"><code class="comments">        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针</code></div>
<div class="line"><code class="comments">        // 后三个参数都是过滤条件</code></div>
<div class="line"><code class="comments">        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要</code></div>
<div class="line"><code class="comments">        UINT wMsgFilterMin,  // first message 第一条信息</code></div>
<div class="line"><code class="comments">        UINT wMsgFilterMax   // last message 最后一条信息</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    MSG msg;</code></div>
<div class="line"><code class="plain">    BOOL bRet;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain">( (bRet = GetMessage( &amp;msg, NULL, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain"> )) != </code><code class="value">0</code><code class="plain">)</code></div>
<div class="line"><code class="plain">    { </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (bRet == -</code><code class="value">1</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// handle the error and possibly exit</code></div>
<div class="line"><code class="plain">            sprintf(szOutBuff, </code><code class="string">"Error: %d"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">            OutputDebugString(szOutBuff);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">else</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 转换消息</code></div>
<div class="line"><code class="plain">            TranslateMessage(&amp;msg);</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 分发消息：就是给系统调用窗口处理函数</code></div>
<div class="line"><code class="plain">            DispatchMessage(&amp;msg);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>运行结果如下：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_1-25-5.png" alt="images/download/attachments/12714992/image2021-6-2_1-25-5.png" width="600"  />
    </p>
<p   
>Windows预定义的窗口类可以在MSDN Library的CreateWindow函数下面找到：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_0-55-43.png" alt="images/download/attachments/12714992/image2021-6-2_0-55-43.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6Jma5ouf5YaF5a2Y5LiO54mp55CG5YaF5a2Y">
        <h1 class="heading "><span>&#34394;&#25311;&#20869;&#23384;&#19982;&#29289;&#29702;&#20869;&#23384;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6Jma5ouf5YaF5a2Y5LiO54mp55CG5YaF5a2Y55qE5YWz57O7">
        <h2 class="heading "><span>&#34394;&#25311;&#20869;&#23384;&#19982;&#29289;&#29702;&#20869;&#23384;&#30340;&#20851;&#31995;</span></h2>
<p   
>每个进程都有自己的4GB内存，但是这个4GB内存并不是真实存在的，而是一块虚拟内存。</p>
<p   
>在进程A的0x12345678内存地址中存入一个值，在进程B的0x12345678内存地址中也存入一个值，两者并不会冲突，而是各自存放各自的。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_16-45-14.png" alt="images/download/attachments/12714992/image2021-6-2_16-45-14.png" width="400"  />
    </p>
<p   
>但是存放的这个值是存放在物理内存上的，所以这里的虚拟内存和物理内存就有一个对应关系，当你真正使用的时候才会给分配物理内存，不使用的时候则就只有虚拟内存（空头支票）。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_16-47-48.png" alt="images/download/attachments/12714992/image2021-6-2_16-47-48.png" width="400"  />
    </p>
<p   
>每一个物理内存的大小是4KB，<strong class=" ">按照4KB大小来分页（Page）</strong>，所以如上图所示，就有物理页这个概念。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6Jma5ouf5YaF5a2Y5Zyw5Z2A5YiS5YiG">
        <h2 class="heading "><span>&#34394;&#25311;&#20869;&#23384;&#22320;&#22336;&#21010;&#20998;</span></h2>
<p   
>每个进程都有4GB的虚拟内存，虚拟内存的地址是如何划分的？首先，我们需要知道一个虚拟内存分为<strong class=" ">高2G、低2G</strong>。</p>
<p   
>如下图所示，用户空间是低2G，内核空间是高2G，对我们来说只能<strong class=" ">使用低2G的用户空间</strong>，<strong class=" ">高2G内核空间是所有进程共用的</strong>。</p>
<p   
>但是需要注意的是低2G的用户空间使用还有<strong class=" ">前64KB的空指针赋值区和后64KB的用户禁入区是我们目前不能使用的</strong>。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_16-59-9.png" alt="images/download/attachments/12714992/image2021-6-2_16-59-9.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-1-46.png" alt="images/download/attachments/12714992/image2021-6-2_17-1-46.png" width="400"  />
    </p>
<p   
>术语：线性地址就是虚拟内存的地址</p>
<p   
><strong class=" ">特别说明</strong>：线性地址有4G ，但未必都能访问，所以需要记录哪些地方分配了。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt54mp55CG5YaF5a2Y">
        <h2 class="heading "><span>&#29289;&#29702;&#20869;&#23384;</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Y-v5L2_55So55qE54mp55CG5YaF5a2Y">
        <h3 class="heading "><span>&#21487;&#20351;&#29992;&#30340;&#29289;&#29702;&#20869;&#23384;</span></h3>
<p   
>为了管理方便，物理内存以4KB大小来分页，那么在系统里面这个物理页的数量是多少呢？我使用的虚拟机是可以设置内存大小的（从物理上可以理解为这就是一个内存条）：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-30-25.png" alt="images/download/attachments/12714992/image2021-6-2_17-30-25.png" width="400"  />
    </p>
<p   
>比如我现在的是是2GB（2048MB），我们可以在任务管理器清晰的看见物理内存的总数是接近2048*1024的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-31-33.png" alt="images/download/attachments/12714992/image2021-6-2_17-31-33.png" width="400"  />
    </p>
<p   
>那么这一块物理内存能有多少物理页呢？我们可以将总数/4：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-35-12.png" alt="images/download/attachments/12714992/image2021-6-2_17-35-12.png" width="400"  />
    </p>
<p   
>也就是有524138个物理页（十进制），转为十六进制就是0x7FF6A</p>
<p   
>那么物理页面只有这些不够用该怎么办？<strong class=" ">这时候操作系统会分配硬盘空间来做虚拟内存</strong>。我们可以通过<strong class=" ">系统属性来查看、更改当前分配的虚拟内存大小</strong>：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-39-19.png" alt="images/download/attachments/12714992/image2021-6-2_17-39-19.png" width="400"  />
    </p>
<p   
>可以看见当前初始大小是2046MB，那么这个是存放在哪的呢？我们可以在C盘下查看（需要显示系统隐藏文件）pagefile.sys这个文件，它刚好是2046MB这个大小，这个文件就是用来做虚拟内存的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-41-30.png" alt="images/download/attachments/12714992/image2021-6-2_17-41-30.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Y-v6K-G5Yir55qE54mp55CG5YaF5a2Y">
        <h3 class="heading "><span>&#21487;&#35782;&#21035;&#30340;&#29289;&#29702;&#20869;&#23384;</span></h3>
<p   
><strong class=" ">32位操作系统最多可以识别物理内存为64G</strong>，但是操作系统会进行限制，<strong class=" ">例如XP这个系统只能识别4G的物理内存</strong>（Windows Server 2003服务器版本可以识别4G以上）。</p>
<p   
>但是我们可以通过HOOK系统函数来突破XP操作系统的4GB限制。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt54mp55CG6aG155qE5L2_55So">
        <h2 class="heading "><span>&#29289;&#29702;&#39029;&#30340;&#20351;&#29992;</span></h2>
<p   
>我们知道了进程在使用虚拟内存时，就会分配一块物理内存（物理页），但是有那么多程序，很快就会占满物理页，操作系统不会这样设计，而是会去看你的程序是否需要频繁的使用物理页，如果不是很频繁就会将你存储在物理页的内容放在pagefile.sys文件中，然后将这个物理页分配给其他需要的进程；</p>
<p   
>如果你的程序再次访问物理页的话，就会重新给你分配物理页，然后把数据从pagefile.sys文件中拿出来放到新的物理页中，这都是操作系统在操作的，写程序是感受不到这样的细节的。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_17-51-1.png" alt="images/download/attachments/12714992/image2021-6-2_17-51-1.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt56eB5pyJ5YaF5a2Y55qE55Sz6K-36YeK5pS-">
        <h1 class="heading "><span>&#31169;&#26377;&#20869;&#23384;&#30340;&#30003;&#35831;&#37322;&#25918;</span></h1>
<p   
>物理内存分为两类，一个是私有内存（Private）一个是共享内存（Mapped），私有内存的意思是这块物理内存（物理页）只有你使用，而共享内存则是多个进程一起用。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_18-6-49.png" alt="images/download/attachments/12714992/image2021-6-2_18-6-49.png" width="400"  />
    </p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt55Sz6K-35YaF5a2Y55qE5Lik56eN5pa55byP">
        <h2 class="heading "><span>&#30003;&#35831;&#20869;&#23384;&#30340;&#20004;&#31181;&#26041;&#24335;</span></h2>
<ol class=" "><li class=" "><p   
>私有内存通过<strong class=" ">VirtualAlloc/VirtualAllocEx函数</strong>申请，这两个函数在底层实现是没有区别的，但是后者是可以在其他进程中申请内存。</p>
</li><li class=" "><p   
>共享内存通过<strong class=" ">CreateFileMapping函数</strong>映射</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5a2Y55Sz6K-35LiO6YeK5pS-">
        <h2 class="heading "><span>&#20869;&#23384;&#30003;&#35831;&#19982;&#37322;&#25918;</span></h2>
<p   
>申请内存的函数是<strong class=" ">VirtualAlloc</strong>，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LPVOID VirtualAlloc(</code></div>
<div class="line"><code class="plain">  LPVOID lpAddress,        </code><code class="comments">// region to reserve or commit 要分配的内存区域的地址，没有特殊需求通常不指定</code></div>
<div class="line"><code class="plain">  SIZE_T dwSize,           </code><code class="comments">// size of region 分配的大小，一个物理页大小是0x1000（4KB），看你需要申请多少个物理页就乘以多少</code></div>
<div class="line"><code class="plain">  DWORD flAllocationType,  </code><code class="comments">// type of allocation 分配的类型，常用的是MEM_COMMIT（占用线性地址，也需要物理内存）和MEM_RESERVE（占用线性地址，但不需要物理内存）</code></div>
<div class="line"><code class="plain">  DWORD flProtect          </code><code class="comments">// type of access protection 该内存的初始保护属性</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>第三、第四参数可以根据MSDN Library查看系统定义的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_18-20-32.png" alt="images/download/attachments/12714992/image2021-6-2_18-20-32.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_18-20-40.png" alt="images/download/attachments/12714992/image2021-6-2_18-20-40.png" width="400"  />
    </p>
<p   
>如下代码则表示申请2个物理页，占用线性地址并分配物理内存，该内存可读写：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LPVOID pm = VirtualAlloc(NULL, </code><code class="value">0x1000</code><code class="plain">*</code><code class="value">2</code><code class="plain">, MEM_COMMIT, PAGE_READWRITE);</code></div>
</div>
    </div>
<p   
>那么内存申请好了我们不想要了，这时候就需要释放，释放函数为<strong class=" ">VirtualFree</strong>，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL VirtualFree(</code></div>
<div class="line"><code class="plain">  LPVOID lpAddress,   </code><code class="comments">// address of region 内存区域的地址</code></div>
<div class="line"><code class="plain">  SIZE_T dwSize,      </code><code class="comments">// size of region 内存大小</code></div>
<div class="line"><code class="plain">  DWORD dwFreeType    </code><code class="comments">// operation type 如何释放，释放的类型，一共有两个类型：MEM_DECOMMIT（释放物理内存，但线性地址保留）、MEM_RELEASE（释放物理内存，释放线性地址，使用这个设置的时候内存大小就必须为0）</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>所以我们想要<strong class=" ">释放物理内存，释放线性地址</strong>就写如下代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">VirtualFree(pm, </code><code class="value">0</code><code class="plain">, MEM_RELEASE);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5aCG5LiO5qCI">
        <h2 class="heading "><span>&#22534;&#19982;&#26632;</span></h2>
<p   
><strong class=" ">之前我们学习过的malloc或者new申请内存，它们是申请的什么内存呢？</strong>其实通过它们申请的内存是假申请，因为它们是从已经申请好的内存中申请给自己用的，通过它们申请的内存称为堆内存，局部变量称为栈内存。</p>
<p   
>无论堆内存还是栈内存，都是操作系统启动时操作系统使用<strong class=" ">VirtualAlloc函数</strong>替我们申请好的。</p>
<p   
>所以堆、栈的本质就是私有内存，也就是通过<strong class=" ">VirtualAlloc函数</strong>申请的。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> x = </code><code class="value">0x12345678</code><code class="plain">; </code><code class="comments">// 栈</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">* y = (</code><code class="keyword">int</code><code class="plain">*)malloc(sizeof(</code><code class="keyword">int</code><code class="plain">)*</code><code class="value">128</code><code class="plain">); </code><code class="comments">// 堆</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5YWx5Lqr5YaF5a2Y55qE55Sz6K-36YeK5pS-">
        <h1 class="heading "><span>&#20849;&#20139;&#20869;&#23384;&#30340;&#30003;&#35831;&#37322;&#25918;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YWx5Lqr5YaF5a2Y">
        <h2 class="heading "><span>&#20849;&#20139;&#20869;&#23384;</span></h2>
<p   
>共享内存通过<strong class=" ">CreateFileMapping函数</strong>映射，该函数语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateFileMapping( </code><code class="comments">// 内核对象，这个对象可以为我们准备物理内存，还可以将文件映射到物理页</code></div>
<div class="line"><code class="plain">  HANDLE hFile,                       </code><code class="comments">// handle to file 文件句柄，如果不想将文件映射到物理页，则不指定该参数</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpAttributes, </code><code class="comments">// security 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  DWORD flProtect,                    </code><code class="comments">// protection 保护模式，物理页的属性</code></div>
<div class="line"><code class="plain">  DWORD dwMaximumSizeHigh,            </code><code class="comments">// high-order DWORD of size 高32位，在32位计算机里通常设置为空</code></div>
<div class="line"><code class="plain">  DWORD dwMaximumSizeLow,             </code><code class="comments">// low-order DWORD of size 低32位，指定物理内存的大小</code></div>
<div class="line"><code class="plain">  LPCTSTR lpName                      </code><code class="comments">// object name 对象名字，公用时写，自己使用则可以不指定</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>该函数的作用就是为我们准备好物理内存（物理页），但是创建好了并不代表就可以使用了，我们还需要通过<strong class=" ">MapViewOffile函数</strong>将物理页与线性地址进行映射，<strong class=" ">MapViewOffile函数</strong>语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">LPVOID MapViewOfFile(</code></div>
<div class="line"><code class="plain">  HANDLE hFileMappingObject,   </code><code class="comments">// handle to file-mapping object file-mapping对象的句柄</code></div>
<div class="line"><code class="plain">  DWORD dwDesiredAccess,       </code><code class="comments">// access mode 访问模式(虚拟内存的限制必须比物理地址更加严格)</code></div>
<div class="line"><code class="plain">  DWORD dwFileOffsetHigh,      </code><code class="comments">// high-order DWORD of offset 高32位，在32位计算机里通常设置为空</code></div>
<div class="line"><code class="plain">  DWORD dwFileOffsetLow,       </code><code class="comments">// low-order DWORD of offset 低32位，指定从哪里开始映射</code></div>
<div class="line"><code class="plain">  SIZE_T dwNumberOfBytesToMap  </code><code class="comments">// number of bytes to map 共享内存的大小，一般与物理页大小一致</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define MapFileName </code><code class="string">"共享内存"</code></div>
<div class="line"><code class="plain">#define BUF_SIZE </code><code class="value">0x1000</code></div>
<div class="line"><code class="plain">HANDLE g_hMapFile;</code></div>
<div class="line"><code class="plain">LPTSTR g_lpBuff;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 内核对象：准备好物理页，无效句柄值-1、物理页可读写、申请一个物理页</code></div>
<div class="line"><code class="plain">    g_hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, </code><code class="value">0</code><code class="plain">, BUF_SIZE, MapFileName);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 将物理页与线性地址进行映射</code></div>
<div class="line"><code class="plain">    g_lpBuff = (LPTSTR)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, BUF_SIZE);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 向物理内存中存储</code></div>
<div class="line"><code class="plain">    *(PDWORD)g_lpBuff = </code><code class="value">0x12345678</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 关闭映射，关闭映射则表示释放了线形地址，但是物理页还存在</code></div>
<div class="line"><code class="plain">    UnmapViewOfFile(g_lpBuff);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 关闭句柄，这样才能释放物理页，但需要等待物理页使用完毕才会真正的释放，这里只是告诉系统我们当前进程不使用该句柄（物理页）罢了</code></div>
<div class="line"><code class="plain">    CloseHandle(g_hMapFile);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_21-52-57.png" alt="images/download/attachments/12714992/image2021-6-2_21-52-57.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5paH5Lu257O757uf">
        <h1 class="heading "><span>&#25991;&#20214;&#31995;&#32479;</span></h1>
<p   
>文件系统是操作系统用于管理磁盘上文件的方法和数据结构；简单点说就是在磁盘上如何组织文件的方法。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_21-53-48.png" alt="images/download/attachments/12714992/image2021-6-2_21-53-48.png" width="400"  />
    </p>
<p   
>在Windows下有NTFS、FAT32这两种文件系统，我们可以通过查看本地磁盘的属性查看：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_22-43-42.png" alt="images/download/attachments/12714992/image2021-6-2_22-43-42.png" width="400"  />
    </p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Y2355u45YWzQVBJ">
        <h2 class="heading "><span>&#21367;&#30456;&#20851;API</span></h2>
<p   
>卷可以理解为就是我们的本地磁盘（逻辑驱动器），我们可以把一块2GB的内存条分为两个卷，卷里头的就是文件和目录。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5Y2377yI6YC76L6R6amx5Yqo5Zmo77yJ">
        <h3 class="heading "><span>&#33719;&#21462;&#21367;&#65288;&#36923;&#36753;&#39537;&#21160;&#22120;&#65289;</span></h3>
<p   
>函数<strong class=" ">GetLogicalDrives</strong>用于获取当前计算机所有逻辑驱动器，语法格式为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD GetLogicalDrives(VOID); </code><code class="comments">// 返回值是一个DOWRD，没有参数</code></div>
</div>
    </div>
<p   
>如下图所示代码，我们最终获取到的就是一个十六进制的d，在MSDN Library中明确说明了这个返回值表示的结果：</p>
<p   
>二进制位标志着存在哪些驱动器，<strong class=" ">位0为1则表示存在驱动器A，位1为1则表示存在驱动器B</strong>，以此类推，这里我们获取的0xd二进制是1101，位1为1、位2为0、位3为1、位4为1，那么就表示我们存在驱动器A、C、D。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 获取卷（逻辑驱动器）</code></div>
<div class="line"><code class="plain">DWORD gLd = GetLogicalDrives();</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"GetLogicalDrives: %x"</code><code class="plain">, gLd);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_23-0-14.png" alt="images/download/attachments/12714992/image2021-6-2_23-0-14.png" width="600"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_23-6-34.png" alt="images/download/attachments/12714992/image2021-6-2_23-6-34.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5omA5pyJ6YC76L6R6amx5Yqo5Zmo55qE5a2X56ym5Liy">
        <h3 class="heading "><span>&#33719;&#21462;&#25152;&#26377;&#36923;&#36753;&#39537;&#21160;&#22120;&#30340;&#23383;&#31526;&#20018;</span></h3>
<p   
>函数<strong class=" ">GetLogicalDriveStrings</strong>用于获取所有逻辑驱动器的字符串，语法格式为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD GetLogicalDriveStrings(</code></div>
<div class="line"><code class="plain">  DWORD nBufferLength,  </code><code class="comments">// size of buffer 输入类型，要获取字符串的大小</code></div>
<div class="line"><code class="plain">  LPTSTR lpBuffer       </code><code class="comments">// drive strings buffer 输出类型，将获取的字符串放到该参数中</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>如下图所示我可以获取所有逻辑驱动器的字符串，那么很清晰的可以看见逻辑驱动器的字符串就是盘符加上冒号和反斜杠：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 获取一个逻辑驱动器的字符串</code></div>
<div class="line"><code class="plain">DWORD nBufferLength = </code><code class="value">100</code><code class="plain">;</code></div>
<div class="line"><code class="keyword">char</code><code class="plain"> szOutBuffer[</code><code class="value">100</code><code class="plain">];</code></div>
<div class="line"><code class="plain">GetLogicalDriveStrings(nBufferLength, szOutBuffer);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_23-13-34.png" alt="images/download/attachments/12714992/image2021-6-2_23-13-34.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5Y2377yI6YC76L6R6amx5Yqo5Zmo77yJ55qE57G75Z6L">
        <h3 class="heading "><span>&#33719;&#21462;&#21367;&#65288;&#36923;&#36753;&#39537;&#21160;&#22120;&#65289;&#30340;&#31867;&#22411;</span></h3>
<p   
>函数<strong class=" ">GetLogicalDriveStrings</strong>用于获取卷的类型，语法格式为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">UINT GetDriveType(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpRootPathName   </code><code class="comments">// root directory 根目录，这里我们可以使用驱动器字符串</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>如下图所示，我获取了逻辑驱动器C的类型：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 获取卷的类型</code></div>
<div class="line"><code class="plain">UINT type;</code></div>
<div class="line"><code class="plain">type = GetDriveType(TEXT(</code><code class="string">"C:\\"</code><code class="plain">));</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">if</code><code class="plain"> (type == DRIVE_UNKNOWN) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"无法确定驱动器的类型 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_NO_ROOT_DIR) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"根路径是无效的，例如: 在该路径上没有安装任何卷 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_REMOVABLE) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"磁盘可以从驱动器中取出 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_FIXED) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"磁盘不能从驱动器中取出 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_REMOTE) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"该驱动器是一个远程（网络）驱动器 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_CDROM) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"该驱动器是一个CD-ROM驱动器 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">} </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type == DRIVE_RAMDISK) {</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"该驱动器是一个RAM磁盘 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-2_23-34-27.png" alt="images/download/attachments/12714992/image2021-6-2_23-34-27.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5Y2355qE5L-h5oGv">
        <h3 class="heading "><span>&#33719;&#21462;&#21367;&#30340;&#20449;&#24687;</span></h3>
<p   
>函数<strong class=" ">GetVolumeInformation</strong>用于获取卷的信息，语法格式为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL GetVolumeInformation(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpRootPathName,           </code><code class="comments">// root directory 输入类型，驱动器字符串</code></div>
<div class="line"><code class="plain">  LPTSTR lpVolumeNameBuffer,        </code><code class="comments">// volume name buffer 输出类型，返回卷名</code></div>
<div class="line"><code class="plain">  DWORD nVolumeNameSize,            </code><code class="comments">// length of name buffer 输入类型，卷名长度</code></div>
<div class="line"><code class="plain">  LPDWORD lpVolumeSerialNumber,     </code><code class="comments">// volume serial number 输出类型，卷宗序列号</code></div>
<div class="line"><code class="plain">  LPDWORD lpMaximumComponentLength, </code><code class="comments">// maximum file name length 输出类型，指定文件系统支持的文件名组件的最大长度</code></div>
<div class="line"><code class="plain">  LPDWORD lpFileSystemFlags,        </code><code class="comments">// file system options 输出类型，与指定文件系统相关的标志</code></div>
<div class="line"><code class="plain">  LPTSTR lpFileSystemNameBuffer,    </code><code class="comments">// file system name buffer 输出类型，文件系统（如FAT或NTFS）名称</code></div>
<div class="line"><code class="plain">  DWORD nFileSystemNameSize         </code><code class="comments">// length of file system name buffer 输入类型，文件系统名称的长度</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>如下图所示，我获取了逻辑驱动器C的相关信息：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 获取卷的信息</code></div>
<div class="line"><code class="plain">TCHAR szVolumeName[</code><code class="value">260</code><code class="plain">];</code></div>
<div class="line"><code class="plain">DWORD dwVolumeSerialNumber;</code></div>
<div class="line"><code class="plain">DWORD dwMaximumComponentLength;</code></div>
<div class="line"><code class="plain">DWORD dwFileSystemFlags;</code></div>
<div class="line"><code class="plain">TCHAR szFileSystemNameBuffer[</code><code class="value">260</code><code class="plain">];</code></div>
<div class="line"><code class="plain">GetVolumeInformation(</code><code class="string">"C:\\"</code><code class="plain">, szVolumeName, </code><code class="value">260</code><code class="plain">, &amp;dwVolumeSerialNumber, &amp;dwMaximumComponentLength, &amp;dwFileSystemFlags, szFileSystemNameBuffer, </code><code class="value">260</code><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-8-48.png" alt="images/download/attachments/12714992/image2021-6-3_0-8-48.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt55uu5b2V55u45YWzQVBJ">
        <h2 class="heading "><span>&#30446;&#24405;&#30456;&#20851;API</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Yib5bu655uu5b2V">
        <h3 class="heading "><span>&#21019;&#24314;&#30446;&#24405;</span></h3>
<p   
>函数<strong class=" ">CreateDirectory</strong>用于创建目录，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL CreateDirectory(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpPathName,                         </code><code class="comments">// directory name 目录名称，需要指定完整路径包含盘符的</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpSecurityAttributes  </code><code class="comments">// SD 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>在C盘下创建test目录：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 创建目录，如果不指定绝对路径，则默认会在程序当前目录下</code></div>
<div class="line"><code class="plain">CreateDirectory(TEXT(</code><code class="string">"C:\\test"</code><code class="plain">), NULL);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-26-12.png" alt="images/download/attachments/12714992/image2021-6-3_0-26-12.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Yig6Zmk55uu5b2V">
        <h3 class="heading "><span>&#21024;&#38500;&#30446;&#24405;</span></h3>
<p   
>函数<strong class=" ">RemoveDirectory</strong>用于删除目录，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL RemoveDirectory(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpPathName   </code><code class="comments">// directory name 目录名称，需要指定完整路径包含盘符的</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>删除C盘下的test目录：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 删除目录</code></div>
<div class="line"><code class="plain">RemoveDirectory(TEXT(</code><code class="string">"C:\\test"</code><code class="plain">));</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5L-u5pS555uu5b2V5ZCN56ew77yI56e75Yqo77yJ">
        <h3 class="heading "><span>&#20462;&#25913;&#30446;&#24405;&#21517;&#31216;&#65288;&#31227;&#21160;&#65289;</span></h3>
<p   
>函数<strong class=" ">MoveFile</strong>用于修改目录名称（移动），其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL MoveFile(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpExistingFileName, </code><code class="comments">// file name 目录名</code></div>
<div class="line"><code class="plain">  LPCTSTR lpNewFileName       </code><code class="comments">// new file name 新目录名</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>将C盘下的test文件夹重命名为test1，也可以理解为以新的名称移动到新的目录下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 修改目录名称（移动）</code></div>
<div class="line"><code class="plain">MoveFile(TEXT(</code><code class="string">"C:\\test"</code><code class="plain">), TEXT(</code><code class="string">"C:\\test1"</code><code class="plain">));</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-30-18.png" alt="images/download/attachments/12714992/image2021-6-3_0-30-18.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W56iL5bqP5b2T5YmN55uu5b2V">
        <h3 class="heading "><span>&#33719;&#21462;&#31243;&#24207;&#24403;&#21069;&#30446;&#24405;</span></h3>
<p   
>函数<strong class=" ">GetCurrentDirectory</strong>用于获取程序当前目录，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD GetCurrentDirectory(</code></div>
<div class="line"><code class="plain">  DWORD nBufferLength,  </code><code class="comments">// size of directory buffer 输入类型，获取当前目录名的大小</code></div>
<div class="line"><code class="plain">  LPTSTR lpBuffer       </code><code class="comments">// directory buffer 输出类型，当前目录名称</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 获取程序当前目录</code></div>
<div class="line"><code class="plain">TCHAR dwOutDirectory[</code><code class="value">200</code><code class="plain">];</code></div>
<div class="line"><code class="plain">GetCurrentDirectory(</code><code class="value">200</code><code class="plain">, dwOutDirectory);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-33-36.png" alt="images/download/attachments/12714992/image2021-6-3_0-33-36.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6K6-572u56iL5bqP5b2T5YmN55uu5b2V">
        <h3 class="heading "><span>&#35774;&#32622;&#31243;&#24207;&#24403;&#21069;&#30446;&#24405;</span></h3>
<p   
>函数<strong class=" ">SetCurrentDirectory</strong>用于设置程序当前目录，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL SetCurrentDirectory(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpPathName   </code><code class="comments">// new directory name 新的目录名称</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 设置程序当前目录</code></div>
<div class="line"><code class="plain">SetCurrentDirectory(TEXT(</code><code class="string">"C:\\test"</code><code class="plain">));</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5paH5Lu255u45YWzQVBJ">
        <h2 class="heading "><span>&#25991;&#20214;&#30456;&#20851;API</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Yib5bu65paH5Lu2">
        <h3 class="heading "><span>&#21019;&#24314;&#25991;&#20214;</span></h3>
<p   
>函数<strong class=" ">CreateFile</strong>用于创建文件，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateFile(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName,                         </code><code class="comments">// file name 文件名</code></div>
<div class="line"><code class="plain">  DWORD dwDesiredAccess,                      </code><code class="comments">// access mode 访问模式</code></div>
<div class="line"><code class="plain">  DWORD dwShareMode,                          </code><code class="comments">// share mode 共享模式，如果为0则是排他性，就是目前在使用时其他人是无法使用的</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpSecurityAttributes, </code><code class="comments">// SD 安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  DWORD dwCreationDisposition,                </code><code class="comments">// how to create 如何创建，可以打开一个已经存在的文件</code></div>
<div class="line"><code class="plain">  DWORD dwFlagsAndAttributes,                 </code><code class="comments">// file attributes 文件属性，可以创建隐藏文件</code></div>
<div class="line"><code class="plain">  HANDLE hTemplateFile                        </code><code class="comments">// handle to template file </code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>以可读可写方式不管有没有，有就覆盖没有就新建的方式创建一个隐藏文件：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 创建文件</code></div>
<div class="line"><code class="plain">CreateFile(TEXT(</code><code class="string">"C:\\A.txt"</code><code class="plain">), GENERIC_READ|GENERIC_WRITE, </code><code class="value">0</code><code class="plain">, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-51-50.png" alt="images/download/attachments/12714992/image2021-6-3_0-51-50.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5YWz6Zet5paH5Lu2">
        <h3 class="heading "><span>&#20851;&#38381;&#25991;&#20214;</span></h3>
<p   
>函数<strong class=" ">CloseHandle</strong>用于关闭文件，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL CloseHandle(</code></div>
<div class="line"><code class="plain">  HANDLE hObject   </code><code class="comments">// handle to object 文件句柄</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_0-53-6.png" alt="images/download/attachments/12714992/image2021-6-3_0-53-6.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5paH5Lu25aSn5bCP">
        <h3 class="heading "><span>&#33719;&#21462;&#25991;&#20214;&#22823;&#23567;</span></h3>
<p   
>函数<strong class=" ">GetFileSize</strong>用于获取文件大小，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD GetFileSize(</code></div>
<div class="line"><code class="plain">  HANDLE hFile,           </code><code class="comments">// handle to file 输入类型，文件句柄</code></div>
<div class="line"><code class="plain">  LPDWORD lpFileSizeHigh  </code><code class="comments">// high-order word of file size，输出类型，高32位的文件大小，这个没有用，长度一般在低32位中，也就是当前函数的返回值</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 创建文件</code></div>
<div class="line"><code class="plain">HANDLE hFile = CreateFile(TEXT(</code><code class="string">"C:\\A.txt"</code><code class="plain">), GENERIC_READ, </code><code class="value">0</code><code class="plain">, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></div>
<div class="line"><code class="comments">// 获取文件大小，单位是字节</code></div>
<div class="line"><code class="plain">DWORD lpFileSizeHigh;</code></div>
<div class="line"><code class="plain">DWORD dwLow = GetFileSize(hFile, &amp;lpFileSizeHigh);</code></div>
<div class="line"><code class="comments">// 关闭文件</code></div>
<div class="line"><code class="plain">CloseHandle(hFile);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_1-0-17.png" alt="images/download/attachments/12714992/image2021-6-3_1-0-17.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6I635Y-W5paH5Lu255qE5bGe5oCn5ZKM5L-h5oGv">
        <h3 class="heading "><span>&#33719;&#21462;&#25991;&#20214;&#30340;&#23646;&#24615;&#21644;&#20449;&#24687;</span></h3>
<p   
>函数<strong class=" ">GetFileAttributes、GetFileAttributesEx</strong>用于获取文件的属性和信息，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD GetFileAttributes( </code><code class="comments">// 这个仅能获取属性</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName   </code><code class="comments">// name of file or directory 文件或目录的名称</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL GetFileAttributesEx( </code><code class="comments">// 这个可以获取属性、信息</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName,                   </code><code class="comments">// file or directory name 输入类型，文件或目录的名称</code></div>
<div class="line"><code class="plain">  GET_FILEEX_INFO_LEVELS fInfoLevelId,  </code><code class="comments">// attribute class 输入类型，这个只有GetFileExInfoStandard一个值</code></div>
<div class="line"><code class="plain">  LPVOID lpFileInformation              </code><code class="comments">// attribute information 输出类型，文件属性和信息的结果</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">WIN32_FILE_ATTRIBUTE_DATA data; </code><code class="comments">// 定义一个结构体</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">GetFileAttributesEx(TEXT(</code><code class="string">"C:\\A.txt"</code><code class="plain">), GetFileExInfoStandard, &amp;data); </code><code class="comments">// 传递结构体指针</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_1-9-3.png" alt="images/download/attachments/12714992/image2021-6-3_1-9-3.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6K-7L-WGmS_mi7fotJ0v5Yig6Zmk5paH5Lu2">
        <h3 class="heading "><span>&#35835;/&#20889;/&#25335;&#36125;/&#21024;&#38500;&#25991;&#20214;</span></h3>
<p   
>函数<strong class=" ">ReadFile、WriteFile、CopyFile、DeleteFile</strong>用于读/写/拷贝/删除文件，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL ReadFile( </code><code class="comments">// 读取文件</code></div>
<div class="line"><code class="plain">  HANDLE hFile,                </code><code class="comments">// handle to file 文件句柄</code></div>
<div class="line"><code class="plain">  LPVOID lpBuffer,             </code><code class="comments">// data buffer 输出类型，数据放哪</code></div>
<div class="line"><code class="plain">  DWORD nNumberOfBytesToRead,  </code><code class="comments">// number of bytes to read 要读多少字节</code></div>
<div class="line"><code class="plain">  LPDWORD lpNumberOfBytesRead, </code><code class="comments">// number of bytes read 真正读多少字节</code></div>
<div class="line"><code class="plain">  LPOVERLAPPED lpOverlapped    </code><code class="comments">// overlapped buffer</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL WriteFile( </code><code class="comments">// 写入文件</code></div>
<div class="line"><code class="plain">  HANDLE hFile,                    </code><code class="comments">// handle to file 文件句柄</code></div>
<div class="line"><code class="plain">  LPCVOID lpBuffer,                </code><code class="comments">// data buffer 要写入的数据在哪</code></div>
<div class="line"><code class="plain">  DWORD nNumberOfBytesToWrite,     </code><code class="comments">// number of bytes to write 要写多少字节</code></div>
<div class="line"><code class="plain">  LPDWORD lpNumberOfBytesWritten,  </code><code class="comments">// number of bytes written 真正写多少字节</code></div>
<div class="line"><code class="plain">  LPOVERLAPPED lpOverlapped        </code><code class="comments">// overlapped buffer</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL CopyFile( </code><code class="comments">// 拷贝文件</code></div>
<div class="line"><code class="plain">  LPCTSTR lpExistingFileName, </code><code class="comments">// name of an existing file 已经存在的文件</code></div>
<div class="line"><code class="plain">  LPCTSTR lpNewFileName,      </code><code class="comments">// name of new file 复制的文件</code></div>
<div class="line"><code class="plain">  BOOL bFailIfExists          </code><code class="comments">// operation if file exists FALSE则复制位置的文件已经存在就覆盖，TRUE反之</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL DeleteFile( </code><code class="comments">// 删除文件</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName   </code><code class="comments">// file name 文件名</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码如下（举一反三）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;stdlib.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    HANDLE hFile = CreateFile(TEXT(</code><code class="string">"C:\\A.txt"</code><code class="plain">), GENERIC_READ, </code><code class="value">0</code><code class="plain">, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 读取文件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 分配空间</code></div>
<div class="line"><code class="plain">    DWORD lpFileSizeHigh;</code></div>
<div class="line"><code class="plain">    DWORD fileSize = GetFileSize(hFile, &amp;lpFileSizeHigh);</code></div>
<div class="line"><code class="plain">    LPSTR pszBuffer = (LPSTR)malloc(fileSize);</code></div>
<div class="line"><code class="plain">    ZeroMemory(pszBuffer, fileSize);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 设置当前读取的位置</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 文件句柄、第几个开始读、高32位、从文件最开始的位置</code></div>
<div class="line"><code class="plain">    SetFilePointer(hFile, </code><code class="value">0</code><code class="plain">, NULL, FILE_BEGIN);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 读取数据</code></div>
<div class="line"><code class="plain">    DWORD dwReadLength;</code></div>
<div class="line"><code class="plain">    ReadFile(hFile, pszBuffer, fileSize, &amp;dwReadLength, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 释放内存</code></div>
<div class="line"><code class="plain">    free(pszBuffer);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 关闭文件</code></div>
<div class="line"><code class="plain">    CloseHandle(hFile);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_1-27-9.png" alt="images/download/attachments/12714992/image2021-6-3_1-27-9.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5p-l5om-5paH5Lu2">
        <h3 class="heading "><span>&#26597;&#25214;&#25991;&#20214;</span></h3>
<p   
>函数<strong class=" ">FindFirstFile、FindNextFile</strong>用于查找文件，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE FindFirstFile(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName,               </code><code class="comments">// file name 输入类型，文件名</code></div>
<div class="line"><code class="plain">  LPWIN32_FIND_DATA lpFindFileData  </code><code class="comments">// data buffer 输出类型，WIN32_FIND_DATA结构体指针，找到的文件数据</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL FindNextFile(</code></div>
<div class="line"><code class="plain">  HANDLE hFindFile,                </code><code class="comments">// search handle  输入类型，搜索句柄</code></div>
<div class="line"><code class="plain">  LPWIN32_FIND_DATA lpFindFileData </code><code class="comments">// data buffer 输出类型，WIN32_FIND_DATA结构体指针，存放找到的文件数据</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>示例代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">WIN32_FIND_DATA firstFile;</code></div>
<div class="line"><code class="plain">WIN32_FIND_DATA nextFile;</code></div>
<div class="line"><code class="comments">// 在C盘下搜索.txt后缀的文件</code></div>
<div class="line"><code class="plain">HANDLE hFile = FindFirstFile(TEXT(</code><code class="string">"C:\\*.txt"</code><code class="plain">), &amp;firstFile);</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"第一个文件名: %s 文件大小: %d\n"</code><code class="plain">, firstFile.cFileName, firstFile.nFileSizeLow);</code></div>
<div class="line"><code class="keyword">if</code><code class="plain"> (hFile != INVALID_HANDLE_VALUE) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 有搜索到，就使用FindNextFile寻找下一个文件，FindNextFile函数返回为真则表示搜索到了</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (FindNextFile(hFile, &amp;nextFile)) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"文件名: %s 文件大小: %d\n"</code><code class="plain">, nextFile.cFileName, nextFile.nFileSizeLow);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_1-40-57.png" alt="images/download/attachments/12714992/image2021-6-3_1-40-57.png" width="600"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5YaF5a2Y5pig5bCE5paH5Lu2">
        <h1 class="heading "><span>&#20869;&#23384;&#26144;&#23556;&#25991;&#20214;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv5YaF5a2Y5pig5bCE5paH5Lu2">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#20869;&#23384;&#26144;&#23556;&#25991;&#20214;</span></h2>
<p   
>内存映射文件就如下图，将硬盘某个文件映射到物理页上，然后再将物理页映射到虚拟内存中。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_9-42-45.png" alt="images/download/attachments/12714992/image2021-6-3_9-42-45.png" width="400"  />
    </p>
<p   
><strong class=" ">优点</strong>：</p>
<ol class=" "><li class=" "><p   
>访问文件就像访问内存一样简单，想读就读，想怎么样就怎么样，不用那么繁杂；</p>
</li><li class=" "><p   
>当文件过大时，使用内存映射文件的方式，性能相对于普通I/O的访问要好很多。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5a2Y5pig5bCE5paH5Lu26K-75YaZ">
        <h2 class="heading "><span>&#20869;&#23384;&#26144;&#23556;&#25991;&#20214;&#35835;&#20889;</span></h2>
<p   
>之前我们学习过用CreateFileMapping函数来创建共享内存，这个函数同样也可以将文件映射到物理页，只不过在这之前我们需要传递一个文件句柄。</p>
<p   
>如下代码我们写了一个读取文件最开始第一个字节的值：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD MappingFile(LPSTR lpcFile) {</code></div>
<div class="line"><code class="plain">    HANDLE hFile;</code></div>
<div class="line"><code class="plain">    HANDLE hMapFile;</code></div>
<div class="line"><code class="plain">    LPVOID lpAddr;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建文件（获取文件句柄）</code></div>
<div class="line"><code class="plain">    hFile = CreateFile(lpcFile, GENERIC_READ|GENERIC_WRITE, </code><code class="value">0</code><code class="plain">, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断CreateFile是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hFile == NULL) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateFile failed: %d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 创建FileMapping对象</code></div>
<div class="line"><code class="plain">    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断CreateFileMapping是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hMapFile == NULL) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateFileMapping failed: %d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 物理页映射到虚拟内存</code></div>
<div class="line"><code class="plain">    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_COPY, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 读取文件</code></div>
<div class="line"><code class="plain">    DWORD dwTest1 = *(LPDWORD)lpAddr; </code><code class="comments">// 读取最开始的4字节</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"dwTest1: %x \n"</code><code class="plain">, dwTest1);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 写文件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// *(LPDWORD)lpAddr = 0x12345678;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 关闭资源</code></div>
<div class="line"><code class="plain">    UnmapViewOfFile(lpAddr);</code></div>
<div class="line"><code class="plain">    CloseHandle(hFile);</code></div>
<div class="line"><code class="plain">    CloseHandle(hMapFile);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>调用函数运行之后成功输出，并获取到对应内容：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">MappingFile(TEXT(</code><code class="string">"C:\\A.txt"</code><code class="plain">));</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_10-31-18.png" alt="images/download/attachments/12714992/image2021-6-3_10-31-18.png" width="600"  />
    </p>
<p   
><strong class=" ">小技巧</strong> &rarr; 在VC6中想要以HEX的形式查看某个文件的话可以在打开文件的时候这样设置：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_10-35-29.png" alt="images/download/attachments/12714992/image2021-6-3_10-35-29.png" width="400"  />
    </p>
<p   
>举一反三，写文件也很简单，但是需要注意的是<strong class=" ">写文件不是立即生效的</strong>，而是先将写入的存放到缓存中，只有等到你释放资源了才会把缓存里的值真正的写入到文件。</p>
<p   
>如果你希望修改可以立即生效，我们可以通过<strong class=" ">FlushViewOfFile函数</strong>来强制更新缓存，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL FlushViewOfFile(</code></div>
<div class="line"><code class="plain">  LPCVOID lpBaseAddress,         </code><code class="comments">// starting address 你要刷新的地址</code></div>
<div class="line"><code class="plain">  SIZE_T dwNumberOfBytesToFlush  </code><code class="comments">// number of bytes in range 要刷新的大小（字节）</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p  class="auto-cursor-target" 
>示例代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">FlushViewOfFile(((LPDWORD)lpAddr), </code><code class="value">4</code><code class="plain">);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5a2Y5pig5bCE5paH5Lu25LmL5YWx5Lqr">
        <h2 class="heading "><span>&#20869;&#23384;&#26144;&#23556;&#25991;&#20214;&#20043;&#20849;&#20139;</span></h2>
<p   
>内存映射文件可以让2个进程同时共享一个文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_10-46-18.png" alt="images/download/attachments/12714992/image2021-6-3_10-46-18.png" width="400"  />
    </p>
<p   
>其实本质很简单，我们只需要在创建FileMapping对象时候给其一个对象名称即可。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-13-0.png" alt="images/download/attachments/12714992/image2021-6-3_11-13-0.png" width="600"  />
    </p>
<p   
>现在我们来A进程写入，B进程读取看看到底能不能跨进程恭喜，写入代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define MAPPINGNAME </code><code class="string">"Share File"</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD MappingFile(LPSTR lpcFile) {</code></div>
<div class="line"><code class="plain">    HANDLE hFile;</code></div>
<div class="line"><code class="plain">    HANDLE hMapFile;</code></div>
<div class="line"><code class="plain">    LPVOID lpAddr;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建文件（获取文件句柄）</code></div>
<div class="line"><code class="plain">    hFile = CreateFile(lpcFile, GENERIC_READ|GENERIC_WRITE, </code><code class="value">0</code><code class="plain">, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断CreateFile是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hFile == NULL) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateFile failed: %d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 创建FileMapping对象</code></div>
<div class="line"><code class="plain">    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, MAPPINGNAME);</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断CreateFileMapping是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hMapFile == NULL) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateFileMapping failed: %d \n"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 物理页映射到虚拟内存</code></div>
<div class="line"><code class="plain">    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 读取文件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// printf("dwTest1: %x \n", dwTest1);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 写文件</code></div>
<div class="line"><code class="plain">    *(LPDWORD)lpAddr = </code><code class="value">0x41414142</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    FlushViewOfFile(((LPDWORD)lpAddr), </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Process A Write"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 关闭资源</code></div>
<div class="line"><code class="plain">    UnmapViewOfFile(lpAddr);</code></div>
<div class="line"><code class="plain">    CloseHandle(hFile);</code></div>
<div class="line"><code class="plain">    CloseHandle(hMapFile);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>读取代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define MAPPINGNAME </code><code class="string">"Share File"</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD MappingFile(LPSTR lpcFile) {</code></div>
<div class="line"><code class="plain">    HANDLE hMapFile;</code></div>
<div class="line"><code class="plain">    LPVOID lpAddr;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 打开FileMapping对象</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/*</code></div>
<div class="line"><code class="comments">    OpenFileMapping 函数语法格式：</code></div>
<div class="line"><code class="comments">    HANDLE OpenFileMapping(</code></div>
<div class="line"><code class="comments">        DWORD dwDesiredAccess,  // access mode 访问模式</code></div>
<div class="line"><code class="comments">        BOOL bInheritHandle,    // inherit flag 继承标识，为真则表示这个可以被新进程继承，为假反之</code></div>
<div class="line"><code class="comments">        LPCTSTR lpName          // object name 对象名称</code></div>
<div class="line"><code class="comments">    );</code></div>
<div class="line"><code class="comments">    */</code></div>
<div class="line"><code class="plain">    hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, MAPPINGNAME);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 物理页映射到虚拟内存</code></div>
<div class="line"><code class="plain">    lpAddr = MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 读取文件</code></div>
<div class="line"><code class="plain">    DWORD dwTest1 = *(LPDWORD)lpAddr; </code><code class="comments">// 读取最开始的4字节</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"dwTest1: %x \n"</code><code class="plain">, dwTest1);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 写文件</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// *(LPDWORD)lpAddr = 0x41414142;</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Process B Read"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 关闭资源</code></div>
<div class="line"><code class="plain">    UnmapViewOfFile(lpAddr);</code></div>
<div class="line"><code class="plain">    CloseHandle(hMapFile);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>分别使用getchar函数挂住了运行，A进程写入0x41414142，B进程也成功读取到了这个值：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-15-43.png" alt="images/download/attachments/12714992/image2021-6-3_11-15-43.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5YaF5a2Y5pig5bCE5paH5Lu25LmL5YaZ5ou36LSd">
        <h2 class="heading "><span>&#20869;&#23384;&#26144;&#23556;&#25991;&#20214;&#20043;&#20889;&#25335;&#36125;</span></h2>
<p   
>我们知道了内存映射文件可以共享，但是这样也有弊端，如下图所示，实际上我们程序调用的user32.dll这类dll文件，也是通过这种方式进行调用的，如果我们进场A修改了某个DLL，就会导致进程B出问题。</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-30-12.png" alt="images/download/attachments/12714992/image2021-6-3_11-30-12.png" width="400"  />
    </p>
<p   
>为了解决这种隐患，我们可以使用写拷贝的方式来处理。</p>
<p   
>写拷贝的实现就是<strong class=" ">MapViewOfFile函数</strong>中的第二个参数值为<strong class=" ">FILE_MAP_COPY</strong>，<strong class=" ">它的意思表示当你在写的时候进行拷贝</strong>。</p>
<p   
>当我们设置为该熟悉时，则多进程之间读取的是同一块物理页，但是当进程A写入的时候则会将这份物理页拷贝为一个新的物理页进行写：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-34-32.png" alt="images/download/attachments/12714992/image2021-6-3_11-34-32.png" width="400"  />
    </p>
<p   
>写拷贝属性时候，写入时并<strong class=" ">不会影响</strong>原本的文件内容。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6Z2Z5oCB6ZO-5o6l5bqT">
        <h1 class="heading "><span>&#38745;&#24577;&#38142;&#25509;&#24211;</span></h1>
<p   
>软件随着更迭会越来越复杂，包含的功能会很多，一个大型软件参与开发的人会非常多，因为不可能一个把所有事情干了，这样就会把软件分为多个模块，每个模块有对应的人去写，静态链接库就是软件模块化的一种解决方案。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt57yW5YaZ6Z2Z5oCB6ZO-5o6l5bqT5paH5Lu2">
        <h2 class="heading "><span>&#32534;&#20889;&#38745;&#24577;&#38142;&#25509;&#24211;&#25991;&#20214;</span></h2>
<p   
>在VC6中创建静态链接库项目：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-48-16.png" alt="images/download/attachments/12714992/image2021-6-3_11-48-16.png" width="400"  />
    </p>
<p   
>创建项目A，然后新建A.cpp和A.h，在A.h中声明一个add方法，在A.cpp中实现该方法：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-53-39.png" alt="images/download/attachments/12714992/image2021-6-3_11-53-39.png" width="600"  />
    </p>
<p   
>编译一下，在<strong class=" ">项目目录的Debug目录下会有一个A.lib文件</strong>，这就是我们的静态链接库：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_11-54-49.png" alt="images/download/attachments/12714992/image2021-6-3_11-54-49.png" width="400"  />
    </p>
<p   
>如果我们需要给别人用的话那就需要A.lib + A.h这个头文件一起给别人。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6Z2Z5oCB6ZO-5o6l5bqT55qE5L2_55So">
        <h2 class="heading "><span>&#38745;&#24577;&#38142;&#25509;&#24211;&#30340;&#20351;&#29992;</span></h2>
<p   
>静态链接库的使用有两种方法：</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt6aG555uu5qC555uu5b2V">
        <h3 class="heading "><span>&#39033;&#30446;&#26681;&#30446;&#24405;</span></h3>
<p   
>第一种方法：将生成的.h与.lib文件复制到项目根目录，然后在代码中引用：</p>
<p   
></p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include </code><code class="string">"xxxx.h"</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"xxxx.lib"</code><code class="plain">)</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-4-7.png" alt="images/download/attachments/12714992/image2021-6-3_12-4-7.png" width="600"  />
    </p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItVkM25a6J6KOF55uu5b2V">
        <h3 class="heading "><span>VC6&#23433;&#35013;&#30446;&#24405;</span></h3>
<p   
>第二种方法：将xxxx.h与xxxx.lib文件复制到VC6安装目录，与库文件放在一起，然后在工程-&gt;设置-&gt;连接-&gt;对象/库模块中添加xxxx.lib，最后就可以像使用C语言库一样使用它了</p>
<ul class=" "><li class=" "><p   
>头文件路径：C:\Program Files\Microsoft Visual Studio\VC98\Include</p>
</li><li class=" "><p   
>静态链接库路径：C:\Program Files\Microsoft Visual Studio\VC98\Lib</p>
</li></ul><p   
></p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-5-37.png" alt="images/download/attachments/12714992/image2021-6-3_12-5-37.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-5-51.png" alt="images/download/attachments/12714992/image2021-6-3_12-5-51.png" width="400"  />
    </p>
<p   
>在编辑框中写入A.lib，多个lib文件以空格隔开：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-7-6.png" alt="images/download/attachments/12714992/image2021-6-3_12-7-6.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-10-33.png" alt="images/download/attachments/12714992/image2021-6-3_12-10-33.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6Z2Z5oCB6ZO-5o6l5bqT55qE57y654K5">
        <h2 class="heading "><span>&#38745;&#24577;&#38142;&#25509;&#24211;&#30340;&#32570;&#28857;</span></h2>
<p   
><strong class=" ">第一个</strong>：<strong class=" ">使用静态链接生成的可执行文件体积较大</strong>，例如我们从汇编层面来看，是根本无法区分哪个是静态库中的代码的：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-11-59.png" alt="images/download/attachments/12714992/image2021-6-3_12-11-59.png" width="600"  />
    </p>
<p   
>同时我们也了解了静态链接库的<strong class=" ">本质</strong>，<strong class=" ">那就是把你想要调用的接口（函数）直接写入到你的程序中</strong>。</p>
<p   
><strong class=" ">第二个</strong>：包含相同的公共代码，造成浪费，假设我们在多个项目中使用同一个静态链接库，其实也就表示相同的代码复制多份。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5Yqo5oCB6ZO-5o6l5bqT">
        <h1 class="heading "><span>&#21160;&#24577;&#38142;&#25509;&#24211;</span></h1>
<p   
>动态链接库弥补了静态链接库的两个缺点，动态链接库（<strong class=" ">Dynamic Link Library，缩写为DLL</strong>），是微软公司在微软Windows操作系统中对<strong class=" ">共享函数库概念</strong>的一种<strong class=" ">实现方式</strong>，这些库函数的文件扩展名称为：.dll、.ocx（包含ActiveX控制的库）。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Yib5bu65Yqo5oCB6ZO-5o6l5bqT">
        <h2 class="heading "><span>&#21019;&#24314;&#21160;&#24577;&#38142;&#25509;&#24211;</span></h2>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzItZXh0ZXJu55qE5pa55byP">
        <h3 class="heading "><span>extern&#30340;&#26041;&#24335;</span></h3>
<p   
>VC6创建项目：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-27-35.png" alt="images/download/attachments/12714992/image2021-6-3_12-27-35.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-28-22.png" alt="images/download/attachments/12714992/image2021-6-3_12-28-22.png" width="400"  />
    </p>
<p   
>与静态链接库的创建方式一样，我们创建一个新的类MyDLL，这样就会自动创建MyDLL.h和MyDLL.cpp：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-32-14.png" alt="images/download/attachments/12714992/image2021-6-3_12-32-14.png" width="100"  />
    </p>
<p   
>在头文件MyDLL.h中我们要声明接口（函数），需要使用固定格式来声明而不能像静态链接库那样直接使用，格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">extern </code><code class="string">"C"</code><code class="plain"> _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-35-8.png" alt="images/download/attachments/12714992/image2021-6-3_12-35-8.png" width="600"  />
    </p>
<p   
>在MyDLL.cpp中实现方法，需要在开头写上一致的调用约定：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-36-3.png" alt="images/download/attachments/12714992/image2021-6-3_12-36-3.png" width="600"  />
    </p>
<p   
>编译后在Debug目录就会生成B.dll文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-40-25.png" alt="images/download/attachments/12714992/image2021-6-3_12-40-25.png" width="400"  />
    </p>
<p   
>在这里我们可以使用LordPE来查看我们这个DLL文件的导出表（<strong class=" ">涉及中级班课程暂时可以略过</strong>），我们只要知道在这个导出表中有这个DLL声明的函数：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-50-10.png" alt="images/download/attachments/12714992/image2021-6-3_12-50-10.png" width="600"  />
    </p>
<p   
>可以很清楚的看见我们的函数名称变成了<strong class=" ">_add@8</strong>。</p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5L2_55SoLkRFRuaWh-S7tg">
        <h3 class="heading "><span>&#20351;&#29992;.DEF&#25991;&#20214;</span></h3>
<p   
>我们可以在项目中创建一个文件扩展名为.def的文件，在该文件中使用如下格式来声明：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">EXPORTS    </code></div>
<div class="line"><code class="plain">函数名 @编号 </code><code class="comments">// 有编号，也有名称</code></div>
<div class="line"><code class="plain">函数名 @编号     NONAME </code><code class="comments">// 有编号，没有名称</code></div>
</div>
    </div>
<p   
>按照这种方式修改如下：</p>
<p   
>头文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-56-52.png" alt="images/download/attachments/12714992/image2021-6-3_12-56-52.png" width="600"  />
    </p>
<p   
>CPP文件：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-57-14.png" alt="images/download/attachments/12714992/image2021-6-3_12-57-14.png" width="600"  />
    </p>
<p   
>DEF文件：</p>
<p   
><img  class="confluence-embedded-image confluence-thumbnail confluence-external-resource"  src="images/download/thumbnails/12714992/image2021-6-3_12-57-32.png" alt="images/download/thumbnails/12714992/image2021-6-3_12-57-32.png" width="200"  />
    </p>
<p   
>然后编译，用LordPE打开查看一下函数名称就会发现其没有了@xxx这样的格式而是我们定义什么样就是什么样：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_12-59-57.png" alt="images/download/attachments/12714992/image2021-6-3_12-59-57.png" width="600"  />
    </p>
<p   
>这样做的好处就是：<strong class=" ">可以很直观的看见函数名，并且在应用层面可以达到隐藏的目的</strong>。</p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5L2_55So5Yqo5oCB6ZO-5o6l5bqT">
        <h2 class="heading "><span>&#20351;&#29992;&#21160;&#24577;&#38142;&#25509;&#24211;</span></h2>
<p   
>使用动态链接库的步骤比较繁琐，一共有如下几个步骤：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 将DLL文件复制到项目目录下</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤1：定义函数指针,如：</code></div>
<div class="line"><code class="plain">typedef </code><code class="keyword">int</code><code class="plain"> (*lpAdd)(</code><code class="keyword">int</code><code class="plain">,</code><code class="keyword">int</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤2：声明函数指针变量,如：</code></div>
<div class="line"><code class="plain">lpAdd myAdd;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤3：动态加载dll到内存中,如：</code></div>
<div class="line"><code class="comments">// LoadLibrary函数会先从当前目录寻找，然后在系统目录寻找</code></div>
<div class="line"><code class="plain">HINSTANCE hModule = LoadLibrary(</code><code class="string">"B.dll"</code><code class="plain">); </code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤4：获取函数地址,如：</code></div>
<div class="line"><code class="plain">myAdd = (lpAdd)GetProcAddress(hModule, </code><code class="string">"add"</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤5：调用函数,如：</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> a = myAdd(</code><code class="value">10</code><code class="plain">,</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 步骤6：释放动态链接库,如：</code></div>
<div class="line"><code class="plain">FreeLibrary(hModule);</code></div>
</div>
    </div>
<p   
>执行结果如下图：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-11-23.png" alt="images/download/attachments/12714992/image2021-6-3_13-11-23.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6ZqQ5byP6ZO-5o6l">
        <h1 class="heading "><span>&#38544;&#24335;&#38142;&#25509;</span></h1>
<p   
>之前我们调用动态链接库（DLL文件）使用的方式实际上是<strong class=" ">显式链接</strong>，它的优点是非常灵活，缺点就是使用起来非常麻烦，步骤很繁琐。</p>
<p   
>本章节我们来学习<strong class=" ">隐式链接</strong>，通过隐式链接我们只需要一次配置，之后就会非常的方便。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6ZqQ5byP6ZO-5o6lLjE">
        <h2 class="heading "><span>&#38544;&#24335;&#38142;&#25509;</span></h2>
<p   
>隐式链接有这几个步骤：</p>
<ol class=" "><li class=" "><p   
>将<strong class=" ">.dll和.lib</strong>放到项目目录下</p>
</li><li class=" "><p   
>将 <u class=" "><strong class=" ">#pragma comment(lib, &quot;DLL名.lib&quot;)</strong></u> 添加到调用文件</p>
</li><li class=" "><p   
>加入函数声明</p>
</li></ol><p   
>函数声明格式如下：</p>
<p   
>注意：在课程中给出的_declspec是有两个下划线的，经过查询之后实际上<strong class=" ">一个下划线和两个下划线是等价</strong>的。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">_declspec(dllimport) _调用约定 返回值 函数名称 (函数参数列表);</code></div>
</div>
    </div>
<p  class="auto-cursor-target" 
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-23-30.png" alt="images/download/attachments/12714992/image2021-6-3_13-23-30.png" width="600"  />
    </p>
<p  class="auto-cursor-target" 
>注意，如果你创建动态链接库的方式是extern的方式，那么在第三步加入函数声明时就应该按照extern的格式来：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">extern </code><code class="string">"C"</code><code class="plain"> _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表);</code></div>
<div class="line"><code class="plain">extern </code><code class="string">"C"</code><code class="plain"> _declspec(dllimport) 调用约定 返回类型 函数名 (参数列表);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6ZqQ5byP6ZO-5o6l55qE5a6e546w">
        <h2 class="heading auto-cursor-target"><span>&#38544;&#24335;&#38142;&#25509;&#30340;&#23454;&#29616;</span></h2>
<p  class="auto-cursor-target" 
>使用隐式链接，编译器会将链接的DLL文件存放到<strong class=" ">导入表</strong>中：</p>
<p  class="auto-cursor-target" 
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-33-45.png" alt="images/download/attachments/12714992/image2021-6-3_13-33-45.png" width="400"  />
    </p>
<p  class="auto-cursor-target" 
>我们可以使用LordPE来查看一下：</p>
<p  class="auto-cursor-target" 
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-34-54.png" alt="images/download/attachments/12714992/image2021-6-3_13-34-54.png" width="600"  />
    </p>
<p  class="auto-cursor-target" 
>并且它可以详细的记录使用了DLL中的哪些函数：</p>
<p  class="auto-cursor-target" 
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-35-44.png" alt="images/download/attachments/12714992/image2021-6-3_13-35-44.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItRExM55qE5LyY54K5">
        <h2 class="heading auto-cursor-target"><span>DLL&#30340;&#20248;&#28857;</span></h2>
<p   
>DLL的优点如下图所示，DLL只在内存中加载一份，修改的时候就是写拷贝原理，不会影响别的进程使用DLL以及不会影响DLL本身：</p>
<p   
><img  class="confluence-embedded-image confluence-external-resource"  src="images/download/attachments/12714992/image2021-6-3_13-37-10.png" alt="images/download/attachments/12714992/image2021-6-3_13-37-10.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzItRGxsTWFpbuWHveaVsA">
        <h2 class="heading "><span>DllMain&#20989;&#25968;</span></h2>
<p   
>我们的控制台程序入口是Main函数，而DLL文件的入口函数是<strong class=" ">DllMain函数（D</strong><strong class=" ">llMain函数</strong>可能会执行很多次，不像我们的Main函数只执行一次<strong class=" ">）</strong>，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL WINAPI DllMain(</code></div>
<div class="line"><code class="plain">  HINSTANCE hinstDLL,   </code><code class="comments">// handle to the DLL module DLL模块的句柄，当前DLL被加载到什么位置</code></div>
<div class="line"><code class="plain">  DWORD fdwReason,      </code><code class="comments">// reason for calling function DLL被调用的原因，有4种情况：DLL_PROCESS_ATTACH（当某个进程第一次执行LoadLibrary）、DLL_PROCESS_DETACH（当某个进程释放了DLL）、DLL_THREAD_ATTACH（当某个进程的其他线程再次执行LoadLibrary）、DLL_THREAD_DETACH（当某个进程的其他线程释放了DLL）</code></div>
<div class="line"><code class="plain">  LPVOID lpvReserved    </code><code class="comments">// reserved</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6L-c56iL57q_56iL">
        <h1 class="heading "><span>&#36828;&#31243;&#32447;&#31243;</span></h1>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt57q_56iL55qE5qaC5b-1">
        <h2 class="heading "><span>&#32447;&#31243;&#30340;&#27010;&#24565;</span></h2>
<p   
>线程是附属在进程上的执行实体，是代码的执行流程；代码必须通过线程才能执行。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Yib5bu66L-c56iL57q_56iL">
        <h2 class="heading "><span>&#21019;&#24314;&#36828;&#31243;&#32447;&#31243;</span></h2>
<p   
>创建远程线程的函数是<strong class=" ">CreateRemoteThread</strong>，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HANDLE CreateRemoteThread(</code></div>
<div class="line"><code class="plain">  HANDLE hProcess,                          </code><code class="comments">// handle to process 输入类型，进程句柄</code></div>
<div class="line"><code class="plain">  LPSECURITY_ATTRIBUTES lpThreadAttributes, </code><code class="comments">// SD 输入类型，安全属性，包含安全描述符</code></div>
<div class="line"><code class="plain">  SIZE_T dwStackSize,                       </code><code class="comments">// initial stack size 输入类型，堆大小</code></div>
<div class="line"><code class="plain">  LPTHREAD_START_ROUTINE lpStartAddress,    </code><code class="comments">// thread function 输入类型，线程函数，线程函数地址应该是在别的进程中存在的</code></div>
<div class="line"><code class="plain">  LPVOID lpParameter,                       </code><code class="comments">// thread argument　输入类型，线程参数</code></div>
<div class="line"><code class="plain">  DWORD dwCreationFlags,                    </code><code class="comments">// creation option 输入类型，创建设置</code></div>
<div class="line"><code class="plain">  LPDWORD lpThreadId                        </code><code class="comments">// thread identifier 输出类型，线程id</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><strong class=" ">CreateThread</strong>函数是在当前进程中创建线程，而<strong class=" ">CreateRemoteThread</strong>函数是允许在其他进程中创建线程，所以<strong class=" ">远程线程就可以理解为是非本进程中的线程</strong>。</p>
<p   
>首先创建A进程，代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Fun() {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt;= </code><code class="value">5</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Fun running... \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">1000</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    Fun();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[]) {</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    HANDLE hThread = CreateThread(NULL, NULL, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>进程B写了一个远程线程创建的代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">BOOL MyCreateRemoteThread(DWORD dwProcessId, DWORD dwProcessAddr) {</code></div>
<div class="line"><code class="plain">    DWORD dwThreadId;</code></div>
<div class="line"><code class="plain">    HANDLE hProcess;</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 获取进程句柄</code></div>
<div class="line"><code class="plain">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断OpenProcess是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hProcess == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"OpenProcess failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 创建远程线程</code></div>
<div class="line"><code class="plain">    hThread = CreateRemoteThread(</code></div>
<div class="line"><code class="plain">        hProcess,                          </code><code class="comments">// handle to process</code></div>
<div class="line"><code class="plain">        NULL, </code><code class="comments">// SD</code></div>
<div class="line"><code class="plain">        </code><code class="value">0</code><code class="plain">,                       </code><code class="comments">// initial stack size</code></div>
<div class="line"><code class="plain">        (LPTHREAD_START_ROUTINE)dwProcessAddr,    </code><code class="comments">// thread function</code></div>
<div class="line"><code class="plain">        NULL,                       </code><code class="comments">// thread argument</code></div>
<div class="line"><code class="plain">        </code><code class="value">0</code><code class="plain">,                    </code><code class="comments">// creation option</code></div>
<div class="line"><code class="plain">        &amp;dwThreadId                        </code><code class="comments">// thread identifier</code></div>
<div class="line"><code class="plain">    );</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 判断CreateRemoteThread是否执行成功</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain">(hThread == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"CreateRemoteThread failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 关闭</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"><code class="plain">    CloseHandle(hProcess);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 返回</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>函数MyCreateRemoteThread传入2个参数，一个是进程ID，一个是线程函数地址。</p>
<p   
>进程ID通过任务管理器查看：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_14-21-36.png" alt="images/download/attachments/12714992/image2021-6-3_14-21-36.png" width="600"  />
    </p>
<p   
>我们在进程A的代码下断点找到线程函数地址：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_14-22-38.png" alt="images/download/attachments/12714992/image2021-6-3_14-22-38.png" width="600"  />
    </p>
<p   
>然后将对应值填入即可远程创建线程：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_14-23-58.png" alt="images/download/attachments/12714992/image2021-6-3_14-23-58.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6L-c56iL57q_56iL5rOo5YWl">
        <h1 class="heading "><span>&#36828;&#31243;&#32447;&#31243;&#27880;&#20837;</span></h1>
<p   
>之前我们是远程创建线程，调用的也是人家自己的线程函数，而如果我们想要创建远程线程调用自己定义的线程函数就需要使用<strong class=" ">远程线程注入</strong>技术。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5LuA5LmI5piv5rOo5YWl">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#27880;&#20837;</span></h2>
<p   
>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p>
<p   
>在安全领域，&ldquo;注入&rdquo;是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p>
<p   
><strong class=" ">已知的注入方式：</strong></p>
<p   
>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt6L-c56iL57q_56iL5rOo5YWl55qE5rWB56iL">
        <h2 class="heading "><span>&#36828;&#31243;&#32447;&#31243;&#27880;&#20837;&#30340;&#27969;&#31243;</span></h2>
<p   
>远程线程注入的思路就是在进程A中创建线程，<strong class=" ">将线程函数指向LoadLibrary函数</strong>。</p>
<p   
>那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可（ThreadProc就是这样的条件）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_15-6-49.png" alt="images/download/attachments/12714992/image2021-6-3_15-6-49.png" width="400"  />
    </p>
<p   
>我们再来看一下<strong class=" ">LoadLibrary函数的语法格式</strong>：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">HMODULE LoadLibrary(</code></div>
<div class="line"><code class="plain">  LPCTSTR lpFileName   </code><code class="comments">// file name of module</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>我们可以跟进（F12）一下<strong class=" ">HMODULE和LPCTSTR这两个宏的定义，就会发现其实都是4字节宽度</strong>。</p>
<p   
>具体实现步骤如下图所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_15-11-55.png" alt="images/download/attachments/12714992/image2021-6-3_15-11-55.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5aaC5L2V5omn6KGM5Luj56CB">
        <h2 class="heading "><span>&#22914;&#20309;&#25191;&#34892;&#20195;&#30721;</span></h2>
<p   
>DLL文件，在DLL文件入口函数判断并创建线程：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// B.cpp : Defines the entry point for the DLL application.</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParaneter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (;;) {</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">1000</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"DLL RUNNING..."</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL APIENTRY DllMain( HANDLE hModule, </code></div>
<div class="line"><code class="plain">                       DWORD  ul_reason_for_call, </code></div>
<div class="line"><code class="plain">                       LPVOID lpReserved</code></div>
<div class="line"><code class="plain">                     )</code></div>
<div class="line"><code class="plain">{   </code><code class="comments">// 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">switch</code><code class="plain"> (ul_reason_for_call) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> DLL_PROCESS_ATTACH:</code></div>
<div class="line"><code class="plain">        CreateThread(NULL, </code><code class="value">0</code><code class="plain">, ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>文件我们用之前写的Test1.exe即可，将编译好的DLL和Test1.exe放在同一个目录并打开Test1.exe。</p>
<p   
>注入实现：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// Test.cpp : Defines the entry point for the console application.</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include </code><code class="string">"StdAfx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径</code></div>
<div class="line"><code class="plain">BOOL LoadDll(DWORD dwProcessID, </code><code class="keyword">char</code><code class="plain">* szDllPathName) {</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    BOOL bRet;</code></div>
<div class="line"><code class="plain">    HANDLE hProcess;</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    DWORD dwLength;</code></div>
<div class="line"><code class="plain">    DWORD dwLoadAddr;</code></div>
<div class="line"><code class="plain">    LPVOID lpAllocAddr;</code></div>
<div class="line"><code class="plain">    DWORD dwThreadID;</code></div>
<div class="line"><code class="plain">    HMODULE hModule;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    bRet = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    dwLoadAddr = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    hProcess = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 获取进程句柄</code></div>
<div class="line"><code class="plain">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hProcess == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"OpenProcess failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</code></div>
<div class="line"><code class="plain">    dwLength = strlen(szDllPathName) + </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 在目标进程分配内存</code></div>
<div class="line"><code class="plain">    lpAllocAddr = VirtualAllocEx(hProcess, NULL, dwLength, MEM_COMMIT, PAGE_READWRITE);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (lpAllocAddr == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"VirtualAllocEx failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 拷贝DLL路径名字到目标进程的内存</code></div>
<div class="line"><code class="plain">    bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!bRet) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"WriteProcessMemory failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 获取模块句柄</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄</code></div>
<div class="line"><code class="plain">    hModule = GetModuleHandle(</code><code class="string">"kernel32.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!hModule) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"GetModuleHandle failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 获取LoadLibraryA函数地址</code></div>
<div class="line"><code class="plain">    dwLoadAddr = (DWORD)GetProcAddress(hModule, </code><code class="string">"LoadLibraryA"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!dwLoadAddr){</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"GetProcAddress failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 7. 创建远程线程，加载DLL</code></div>
<div class="line"><code class="plain">    hThread = CreateRemoteThread(hProcess, NULL, </code><code class="value">0</code><code class="plain">, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, </code><code class="value">0</code><code class="plain">, &amp;dwThreadID);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!hThread){</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"CreateRemoteThread failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 8. 关闭进程句柄</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"><code class="plain">    CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[]) {</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    LoadDll(</code><code class="value">384</code><code class="plain">, </code><code class="string">"C:\\Documents and Settings\\Administrator\\桌面\\test\\B.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>注入成功：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_15-38-24.png" alt="images/download/attachments/12714992/image2021-6-3_15-38-24.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt6L-b56iL6Ze06YCa5L-h">
        <h1 class="heading "><span>&#36827;&#31243;&#38388;&#36890;&#20449;</span></h1>
<p   
>同一台机器上进程之间的通信虽然有很多种方法，但其本质就是共享内存。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_21-19-13.png" alt="images/download/attachments/12714992/image2021-6-3_21-19-13.png" width="400"  />
    </p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Li-5L6L6K-05piO">
        <h2 class="heading "><span>&#20030;&#20363;&#35828;&#26126;</span></h2>
<p   
>假设现在我们<strong class=" ">进程A的代码</strong>是这样的：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Attack()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"**********攻击********** \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Rest()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"**********打坐********** \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Blood()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"**********加血********** \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[]) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> cGetchar;</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"**********GAME BEGIN********** \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain">(</code><code class="value">1</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        cGetchar = getchar();</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">switch</code><code class="plain">(cGetchar) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">case</code><code class="plain"> </code><code class="string">'A'</code><code class="plain">:</code></div>
<div class="line"><code class="plain">            {</code></div>
<div class="line"><code class="plain">                Attack();</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">case</code><code class="plain"> </code><code class="string">'R'</code><code class="plain">:</code></div>
<div class="line"><code class="plain">            {</code></div>
<div class="line"><code class="plain">                Rest();</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">case</code><code class="plain"> </code><code class="string">'B'</code><code class="plain">:</code></div>
<div class="line"><code class="plain">            {</code></div>
<div class="line"><code class="plain">                Blood();</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>这就是获取输入的字符来攻击、打坐、加血的小程序，我们想要自动化的控制这个程序而不是自己输入该怎么办？这时候就需要使用平时中大家常提的外挂技术，在这里实际上就是<strong class=" ">远程线程注入，通过进程B控制进程A的执行流程</strong>。</p>
<p   
>如下是DLL文件的代码：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// B.cpp : Defines the entry point for the DLL application.</code></div>
<div class="line"><code class="comments">//</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#include </code><code class="string">"stdafx.h"</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define _MAP_ </code><code class="string">"共享内存"</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="comments">// 首先需要获取函数的地址</code></div>
<div class="line"><code class="plain">#define ATTACK </code><code class="value">0x00401030</code></div>
<div class="line"><code class="plain">#define REST </code><code class="value">0x00401080</code></div>
<div class="line"><code class="plain">#define BLOOD </code><code class="value">0x004010D0</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">HANDLE g_hModule;</code></div>
<div class="line"><code class="plain">HANDLE g_hMapFile;</code></div>
<div class="line"><code class="plain">LPTSTR lpBuffer;</code></div>
<div class="line"><code class="plain">DWORD dwType;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    dwType = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    g_hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, _MAP_);</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (g_hMapFile == NULL)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"OpenFileMapping failed: %d"</code><code class="plain">, GetLastError());</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">//映射内存</code></div>
<div class="line"><code class="plain">    lpBuffer = (LPTSTR)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, BUFSIZ);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (;;)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (lpBuffer != NULL)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 读取数据</code></div>
<div class="line"><code class="plain">            CopyMemory(&amp;dwType, lpBuffer, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (dwType == </code><code class="value">1</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 攻击</code></div>
<div class="line"><code class="plain">            __asm {</code></div>
<div class="line"><code class="plain">                mov eax, ATTACK</code></div>
<div class="line"><code class="plain">                    call eax</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            dwType == </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            CopyMemory(&amp;dwType, lpBuffer, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (dwType == </code><code class="value">2</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 打坐</code></div>
<div class="line"><code class="plain">            __asm {</code></div>
<div class="line"><code class="plain">                mov eax, REST</code></div>
<div class="line"><code class="plain">                    call eax</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            dwType == </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            CopyMemory(&amp;dwType, lpBuffer, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (dwType == </code><code class="value">3</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 加血</code></div>
<div class="line"><code class="plain">            __asm {</code></div>
<div class="line"><code class="plain">                mov eax, BLOOD</code></div>
<div class="line"><code class="plain">                    call eax</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            dwType == </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            CopyMemory(&amp;dwType, lpBuffer, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (dwType == </code><code class="value">4</code><code class="plain">)</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">//卸载自身并退出</code></div>
<div class="line"><code class="plain">            FreeLibraryAndExitThread((HMODULE)g_hModule, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">500</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL APIENTRY DllMain( HMODULE hModule,</code></div>
<div class="line"><code class="plain">                      DWORD  ul_reason_for_call,</code></div>
<div class="line"><code class="plain">                      LPVOID lpReserved</code></div>
<div class="line"><code class="plain">                      )</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">switch</code><code class="plain"> (ul_reason_for_call) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">case</code><code class="plain"> DLL_PROCESS_ATTACH:</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            CreateThread(NULL, </code><code class="value">0</code><code class="plain">, (LPTHREAD_START_ROUTINE)ThreadProc, NULL, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>需要注意的是我们首先需要获取函数的地址，这个我们可以通过VC6反汇编来寻找：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-6-28.png" alt="images/download/attachments/12714992/image2021-6-3_22-6-28.png" width="600"  />
    </p>
<p   
>编译好DLL之后，我们需要一个进程B来控制进程A，代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;tlhelp32.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">#define _MAP_ </code><code class="string">"共享内存"</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="plain">HANDLE g_hMapFile;</code></div>
<div class="line"><code class="plain">LPTSTR lpBuffer;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">BOOL LoadDll(DWORD dwProcessID, </code><code class="keyword">char</code><code class="plain">* szDllPathName) {</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    BOOL bRet;</code></div>
<div class="line"><code class="plain">    HANDLE hProcess;</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    DWORD dwLength;</code></div>
<div class="line"><code class="plain">    DWORD dwLoadAddr;</code></div>
<div class="line"><code class="plain">    LPVOID lpAllocAddr;</code></div>
<div class="line"><code class="plain">    DWORD dwThreadID;</code></div>
<div class="line"><code class="plain">    HMODULE hModule;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    bRet = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    dwLoadAddr = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    hProcess = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 获取进程句柄</code></div>
<div class="line"><code class="plain">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hProcess == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"OpenProcess failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</code></div>
<div class="line"><code class="plain">    dwLength = strlen(szDllPathName) + </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 在目标进程分配内存</code></div>
<div class="line"><code class="plain">    lpAllocAddr = VirtualAllocEx(hProcess, NULL, dwLength, MEM_COMMIT, PAGE_READWRITE);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (lpAllocAddr == NULL) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"VirtualAllocEx failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 拷贝DLL路径名字到目标进程的内存</code></div>
<div class="line"><code class="plain">    bRet = WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!bRet) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"WriteProcessMemory failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 获取模块句柄</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄</code></div>
<div class="line"><code class="plain">    hModule = GetModuleHandle(</code><code class="string">"kernel32.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!hModule) {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"GetModuleHandle failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 获取LoadLibraryA函数地址</code></div>
<div class="line"><code class="plain">    dwLoadAddr = (DWORD)GetProcAddress(hModule, </code><code class="string">"LoadLibraryA"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!dwLoadAddr){</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"GetProcAddress failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 7. 创建远程线程，加载DLL</code></div>
<div class="line"><code class="plain">    hThread = CreateRemoteThread(hProcess, NULL, </code><code class="value">0</code><code class="plain">, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, </code><code class="value">0</code><code class="plain">, &amp;dwThreadID);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!hThread){</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"CreateRemoteThread failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 8. 关闭进程句柄</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"><code class="plain">    CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="plain">BOOL Init()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 创建共享内存</code></div>
<div class="line"><code class="plain">    g_hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, </code><code class="value">0</code><code class="plain">, </code><code class="value">0x1000</code><code class="plain">, _MAP_);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (g_hMapFile == NULL)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"CreateFileMapping failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 映射内存</code></div>
<div class="line"><code class="plain">    lpBuffer = (LPTSTR)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS, </code><code class="value">0</code><code class="plain">, </code><code class="value">0</code><code class="plain">, BUFSIZ);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (lpBuffer == NULL)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"MapViewOfFile failed! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 根据进程名称获取进程ID</code></div>
<div class="line"><code class="plain">DWORD GetPID(</code><code class="keyword">char</code><code class="plain"> *szName)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    HANDLE hProcessSnapShot = NULL;</code></div>
<div class="line"><code class="plain">    PROCESSENTRY32 pe32 = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    hProcessSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hProcessSnapShot == (HANDLE)-</code><code class="value">1</code><code class="plain">)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    pe32.dwSize = sizeof(PROCESSENTRY32);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (Process32First(hProcessSnapShot, &amp;pe32))</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain"> (!strcmp(szName, pe32.szExeFile)) {</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">return</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain">)pe32.th32ProcessID;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">while</code><code class="plain"> (Process32Next(hProcessSnapShot, &amp;pe32));</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcessSnapShot);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> main()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    DWORD dwCtrlCode = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 指令队列</code></div>
<div class="line"><code class="plain">    DWORD dwOrderList[</code><code class="value">10</code><code class="plain">] = {</code><code class="value">1</code><code class="plain">, </code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">1</code><code class="plain">, </code><code class="value">2</code><code class="plain">, </code><code class="value">1</code><code class="plain">, </code><code class="value">3</code><code class="plain">, </code><code class="value">4</code><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Are you ready? \n"</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (Init()) {</code></div>
<div class="line"><code class="plain">        LoadDll(GetPID(</code><code class="string">"Test.exe"</code><code class="plain">), (</code><code class="keyword">char</code><code class="plain">*)</code><code class="string">"C:\\Documents and Settings\\Administrator\\桌面\\test\\B.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">10</code><code class="plain">; i++)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        dwCtrlCode = dwOrderList[i];</code></div>
<div class="line"><code class="plain">        CopyMemory(lpBuffer, &amp;dwCtrlCode, </code><code class="value">4</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        Sleep(</code><code class="value">2000</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>成功执行并控制了进程A：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-20-26.png" alt="images/download/attachments/12714992/image2021-6-3_22-20-26.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5qih5Z2X6ZqQ6JeP">
        <h1 class="heading "><span>&#27169;&#22359;&#38544;&#34255;</span></h1>
<p   
>之前我们了解了直接注入一个DLL到进程中，但是这样实际上是很难存活的，因为程序很容易就可以通过API来获取当前加载的DLL模块，所以我们需要使用模块隐藏技术来隐藏自己需要注入的DLL模块。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5qih5Z2X6ZqQ6JeP5LmL5pat6ZO-">
        <h2 class="heading "><span>&#27169;&#22359;&#38544;&#34255;&#20043;&#26029;&#38142;</span></h2>
<p   
>API是通过什么将模块查询出来的？其实API都是从这几个结构体（<strong class=" ">结构体属于3环应用层</strong>）中查询出来的：</p>
<ol class=" "><li class=" "><p   
>TEB(Thread Environment Block，线程环境块)，它存放线程的相关信息，每一个线程都有自己的TEB信息，FS:[0]即是当前线程的TEB。</p>
</li><li class=" "><p   
>PEB(Process Environment Block，进程环境块)，它存放进程的相关信息，每个进程都有自己的PEB信息，FS:[0x30]即当前进程的PEB。</p>
</li></ol><p   
>如下图所示（只介绍与本章节相关的信息）</p>
<ol class=" "><li class=" "><p   
>TEB第一个成员是一个结构体，这个结构体包含了当前线程栈栈底和当前线程栈的界限；TEB的<strong class=" ">020</strong>偏移是一个结构体，其包含了两个成员，一个是当前线程所在进程的PID和当前线程自己的线程ID；</p>
</li><li class=" "><p   
>PEB的<strong class=" ">00c</strong>偏移是一个结构体，这个结构体包括<strong class=" ">模块链表</strong>，API函数遍历模块就是查看这个链表。</p>
</li></ol><p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-31-12.png" alt="images/download/attachments/12714992/image2021-6-3_22-31-12.png" width="600"  />
    </p>
<p   
>我们如何去获取这个<strong class=" ">TEB结构体</strong>呢？我们可以随便找一个EXE拖进DTDebug，然后来看一下<strong class=" ">FS寄存器</strong>（目前你只需要知道TEB的地址就存储在FS寄存器中即可，具体细节在中级课程中）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-41-14.png" alt="images/download/attachments/12714992/image2021-6-3_22-41-14.png" width="600"  />
    </p>
<p   
>我们可以在左下角使用<strong class=" ">dd 7FFDF000</strong>命令来查看TEB结构体：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-44-58.png" alt="images/download/attachments/12714992/image2021-6-3_22-44-58.png" width="400"  />
    </p>
<p   
>FS寄存器中存储的就是当前正在使用的线程的TEB结构体的地址。</p>
<p   
>PEB结构体同理，我们只需要找到FS寄存器中存储地址的0x30偏移然后跟进即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-51-48.png" alt="images/download/attachments/12714992/image2021-6-3_22-51-48.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-52-17.png" alt="images/download/attachments/12714992/image2021-6-3_22-52-17.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_22-52-21.png" alt="images/download/attachments/12714992/image2021-6-3_22-52-21.png" width="400"  />
    </p>
<p   
>我们之前已经了解到了API函数遍历模块就是查看PEB那个链表，所以我们要想办法让它<strong class=" ">在查询的时候断链</strong>。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5pat6ZO-5a6e546w5Luj56CB">
        <h3 class="heading "><span>&#26029;&#38142;&#23454;&#29616;&#20195;&#30721;</span></h3>
<p   
>如下我们通过断链的方式实现了一个隐藏模块的函数：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> HideModule(</code><code class="keyword">char</code><code class="plain">* szModuleName) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 获取模块的句柄</code></div>
<div class="line"><code class="plain">    HMODULE hMod = GetModuleHandle(szModuleName);</code></div>
<div class="line"><code class="plain">    PLIST_ENTRY Head, Cur;</code></div>
<div class="line"><code class="plain">    PPEB_LDR_DATA ldr;</code></div>
<div class="line"><code class="plain">    PLDR_MODULE ldmod;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    __asm {</code></div>
<div class="line"><code class="plain">        mov eax, fs:[</code><code class="value">0x30</code><code class="plain">] </code><code class="comments">// 取PEB结构体</code></div>
<div class="line"><code class="plain">            mov ecx, [eax + </code><code class="value">0x0c</code><code class="plain">] </code><code class="comments">// 取PEB结构体的00c偏移的结构体，就是PEB_LDR_DATA</code></div>
<div class="line"><code class="plain">            mov ldr, ecx </code><code class="comments">// 将ecx给到ldr</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 获取正在加载的模块列表</code></div>
<div class="line"><code class="plain">    Head = &amp;(ldr-&gt;InLoadOrderModuleList);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// </code></div>
<div class="line"><code class="plain">    Cur = Head-&gt;Flink;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 宏CONTAINING_RECORD根据结构体中某成员的地址来推算出该结构体整体的地址</code></div>
<div class="line"><code class="plain">        ldmod = CONTAINING_RECORD(Cur, LDR_MODULE, InLoadOrderModuleList);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 循环遍历，如果地址一致则表示找到对应模块来，就进行断链</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain">(hMod == ldmod-&gt;BaseAddress) {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 断链原理很简单就是将属性交错替换</code></div>
<div class="line"><code class="plain">            ldmod-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InLoadOrderModuleList.Flink;</code></div>
<div class="line"><code class="plain">            ldmod-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InLoadOrderModuleList.Blink;</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            ldmod-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InInitializationOrderModuleList.Flink;</code></div>
<div class="line"><code class="plain">            ldmod-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InInitializationOrderModuleList.Blink;</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            ldmod-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InMemoryOrderModuleList.Flink;</code></div>
<div class="line"><code class="plain">            ldmod-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InMemoryOrderModuleList.Blink;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        Cur = Cur-&gt;Flink;</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (Head != Cur);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>我们可以调用隐藏kernel32.dll这个模块，然后用DTDebug来查看一下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[]) {</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    HideModule(</code><code class="string">"kernel32.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    getchar();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>编译打开（不使用VC6打开）Test.exe然后使用DTDebug来Attach进程：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-28-46.png" alt="images/download/attachments/12714992/image2021-6-3_23-28-46.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-29-2.png" alt="images/download/attachments/12714992/image2021-6-3_23-29-2.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-28-54.png" alt="images/download/attachments/12714992/image2021-6-3_23-28-54.png" width="400"  />
    </p>
<p   
>此刻我们是可以看见kernel32.dll模块的，但是当我们回车一下再来看就消失了：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-30-17.png" alt="images/download/attachments/12714992/image2021-6-3_23-30-17.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5qih5Z2X6ZqQ6JeP5LmLUEXmjIfnurk">
        <h2 class="heading "><span>&#27169;&#22359;&#38544;&#34255;&#20043;PE&#25351;&#32441;</span></h2>
<p   
>首先我们来看某一个模块的PE指纹，这里就用ntdll.dll举例：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-30-17.png" alt="images/download/attachments/12714992/image2021-6-3_23-30-17.png" width="400"  />
    </p>
<p   
>其地址是7c920000，我们在DTDebug中使用命令db 7c920000即可看到该模块的信息：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-39-28.png" alt="images/download/attachments/12714992/image2021-6-3_23-39-28.png" width="400"  />
    </p>
<p   
>该模块开头两个字节是4D 5A，<strong class=" ">也就是MZ</strong>，当看见这两个字节后，在其位置向后找第64字节，发现是E0，那么就从模块起始位置0x7c920000加0xE0，这样就成了<strong class=" ">0x7c9200E0</strong>，然后我们找到对应地址的两个字节为50 45，<strong class=" ">也就是PE</strong>。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-39-4.png" alt="images/download/attachments/12714992/image2021-6-3_23-39-4.png" width="400"  />
    </p>
<p   
>这就是一个PE指纹，如果能满足这一套流程则表示这是一个模块。</p>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5qih5Z2X6ZqQ6JeP5LmLVkFE5qCR">
        <h2 class="heading "><span>&#27169;&#22359;&#38544;&#34255;&#20043;VAD&#26641;</span></h2>
<p   
>这里涉及内核知识，建议观看视频简单讲解。</p>
    </div>
    </div>
    <div class="section section-1" id="src-12714992_safe-id-V2luMzIt5rOo5YWl5Luj56CB">
        <h1 class="heading "><span>&#27880;&#20837;&#20195;&#30721;</span></h1>
<p   
>最好的隐藏是无模块注入，也就是代码注入，将我们想要执行的代码注入进去。</p>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5rOo5YWl5Luj56CB55qE5oCd6Lev">
        <h2 class="heading "><span>&#27880;&#20837;&#20195;&#30721;&#30340;&#24605;&#36335;</span></h2>
<p   
>我们可以将自定义函数复制到目标进程中，这样目标进程就可以执行我们想要执行的代码了，这就是注入代码的思路：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-49-55.png" alt="images/download/attachments/12714992/image2021-6-3_23-49-55.png" width="400"  />
    </p>
<p   
>听起来很简单，但是其中有很多问题：</p>
<ol class=" "><li class=" "><p   
>你要将自定义函数复制到目标进程中，你复制的东西本质是什么？</p>
</li><li class=" "><p   
>你复制过去就一定可以执行吗？前提条件是什么？</p>
</li></ol>    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5py65Zmo56CB">
        <h3 class="heading "><span>&#26426;&#22120;&#30721;</span></h3>
<p   
>首先我们来解决一下第一个问题，我们之前通过VC6是可以查看反汇编代码的，而实际上一个程序能看见具体的汇编代码吗？其实不可以，其表现形式应该是机器码，<strong class=" ">如下图所示左边是机器码，右边是机器码对应的汇编代码，我们能看见汇编代码是因为VC6的反汇编引擎将机器码转为汇编代码</strong>：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-3_23-54-59.png" alt="images/download/attachments/12714992/image2021-6-3_23-54-59.png" width="600"  />
    </p>
<p   
>所以我们<strong class=" ">拷贝过去的应该是机器码</strong>。</p>
    </div>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5YmN5o-Q5p2h5Lu2">
        <h3 class="heading "><span>&#21069;&#25552;&#26465;&#20214;</span></h3>
<p   
>如下图所示，之间通过<strong class=" ">硬编码地址调用</strong>的机器码就<strong class=" ">没法注入</strong>执行，因为目标进程不可能会有目标地址内存给你进行使用：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-4_0-0-15.png" alt="images/download/attachments/12714992/image2021-6-4_0-0-15.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5aSN5Yi25Luj56CB55qE57yW5YaZ5Y6f5YiZ">
        <h2 class="heading "><span>&#22797;&#21046;&#20195;&#30721;&#30340;&#32534;&#20889;&#21407;&#21017;</span></h2>
<ol class=" "><li class=" "><p   
>不能有全局变量</p>
</li><li class=" "><p   
>不能使用常量字符串</p>
</li><li class=" "><p   
>不能使用系统调用</p>
</li><li class=" "><p   
>不能嵌套调用其他函数</p>
</li></ol>    </div>
    <div class="section section-2" id="src-12714992_safe-id-V2luMzIt5Lyg6YCS5Y-C5pWw">
        <h2 class="heading "><span>&#20256;&#36882;&#21442;&#25968;</span></h2>
<p   
>有这么多限制该怎么办？假设我们要将代码进程的代码拷贝过去，这段代码的作用就是创建文件，那么它得流程可以如下图所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/12714992/image2021-6-4_0-7-56.png" alt="images/download/attachments/12714992/image2021-6-4_0-7-56.png" width="400"  />
    </p>
<p   
>首先将代码进程的ThreadProc复制过去，然后将复制过去之后目标进程的地址给到<strong class=" ">CreateRemoteThread</strong>函数，这样就解决了自定义函数的问题；</p>
<p   
>其次我们要创建文件的话就必须要使用<strong class=" ">CreateFile</strong>函数，我们不能直接这样写，因为它依赖当前进程的导入表，当前进程和目标进程导入表的地址肯定是不一样的，<strong class=" ">所以不符合复制代码的编写原则</strong>；所以我们可以通过线程函数的参数来解决，我们先将所有用到的目标参数写到一个结构体中复制到目标进程，然后将目标进程结构体的地址作为线程函数的参数。</p>
    <div class="section section-3" id="src-12714992_safe-id-V2luMzIt5Luj56CB5a6e546w">
        <h3 class="heading "><span>&#20195;&#30721;&#23454;&#29616;</span></h3>
<p   
>如下是传递参数进行远程注入代码的实现：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;tlhelp32.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;stdio.h&gt;</code></div>
<div class="line"><code class="plain">#include &lt;windows.h&gt;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">typedef struct {</code></div>
<div class="line"><code class="plain">    DWORD dwCreateAPIAddr;                </code><code class="comments">// Createfile函数的地址</code></div>
<div class="line"><code class="plain">    LPCTSTR lpFileName;                    </code><code class="comments">// 下面都是CreateFile所需要用到的参数</code></div>
<div class="line"><code class="plain">    DWORD dwDesiredAccess;</code></div>
<div class="line"><code class="plain">    DWORD dwShareMode;</code></div>
<div class="line"><code class="plain">    LPSECURITY_ATTRIBUTES lpSecurityAttributes;</code></div>
<div class="line"><code class="plain">    DWORD dwCreationDisposition;</code></div>
<div class="line"><code class="plain">    DWORD dwFlagsAndAttributes;</code></div>
<div class="line"><code class="plain">    HANDLE hTemplateFile;</code></div>
<div class="line"><code class="plain">} CREATEFILE_PARAM;</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 定义一个函数指针</code></div>
<div class="line"><code class="plain">typedef HANDLE(WINAPI* PFN_CreateFile) (</code></div>
<div class="line"><code class="plain">    LPCTSTR lpFileName,</code></div>
<div class="line"><code class="plain">    DWORD dwDesiredAccess,</code></div>
<div class="line"><code class="plain">    DWORD dwShareMode,</code></div>
<div class="line"><code class="plain">    LPSECURITY_ATTRIBUTES lpSecurityAttributes,</code></div>
<div class="line"><code class="plain">    DWORD dwCreationDisposition,</code></div>
<div class="line"><code class="plain">    DWORD dwFlagsAndAttributes,</code></div>
<div class="line"><code class="plain">    HANDLE hTemplateFile</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 编写要复制到目标进程的函数</code></div>
<div class="line"><code class="plain">DWORD _stdcall CreateFileThreadProc(LPVOID lparam)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    CREATEFILE_PARAM* Gcreate = (CREATEFILE_PARAM*)lparam;</code></div>
<div class="line"><code class="plain">    PFN_CreateFile pfnCreateFile;</code></div>
<div class="line"><code class="plain">    pfnCreateFile = (PFN_CreateFile)Gcreate-&gt;dwCreateAPIAddr;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// creatFile结构体全部参数</code></div>
<div class="line"><code class="plain">    pfnCreateFile(</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;lpFileName,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;dwDesiredAccess,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;dwShareMode,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;lpSecurityAttributes,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;dwCreationDisposition,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;dwFlagsAndAttributes,</code></div>
<div class="line"><code class="plain">        Gcreate-&gt;hTemplateFile</code></div>
<div class="line"><code class="plain">    );</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 远程创建文件</code></div>
<div class="line"><code class="plain">BOOL RemotCreateFile(DWORD dwProcessID, </code><code class="keyword">char</code><code class="plain">* szFilePathName)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    BOOL bRet;</code></div>
<div class="line"><code class="plain">    DWORD dwThread;</code></div>
<div class="line"><code class="plain">    HANDLE hProcess;</code></div>
<div class="line"><code class="plain">    HANDLE hThread;</code></div>
<div class="line"><code class="plain">    DWORD dwThreadFunSize;</code></div>
<div class="line"><code class="plain">    CREATEFILE_PARAM GCreateFile;</code></div>
<div class="line"><code class="plain">    LPVOID lpFilePathName;</code></div>
<div class="line"><code class="plain">    LPVOID lpRemotThreadAddr;</code></div>
<div class="line"><code class="plain">    LPVOID lpFileParamAddr;</code></div>
<div class="line"><code class="plain">    DWORD dwFunAddr;</code></div>
<div class="line"><code class="plain">    HMODULE hModule;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    bRet = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    hProcess = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    dwThreadFunSize = </code><code class="value">0x400</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 获取进程的句柄</code></div>
<div class="line"><code class="plain">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hProcess == NULL)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"OpenProcessError! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 分配3段内存：存储参数，线程函数，文件名</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2.1 用来存储文件名 +1是要计算到结尾处</code></div>
<div class="line"><code class="plain">    lpFilePathName = VirtualAllocEx(hProcess, NULL, strlen(szFilePathName)+</code><code class="value">1</code><code class="plain">, MEM_COMMIT, PAGE_READWRITE); </code><code class="comments">// 在指定的进程中分配内存</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2.2 用来存储线程函数</code></div>
<div class="line"><code class="plain">    lpRemotThreadAddr = VirtualAllocEx(hProcess, NULL, dwThreadFunSize, MEM_COMMIT, PAGE_READWRITE); </code><code class="comments">// 在指定的进程中分配内存</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 2.3 用来存储文件参数</code></div>
<div class="line"><code class="plain">    lpFileParamAddr = VirtualAllocEx(hProcess, NULL, sizeof(CREATEFILE_PARAM), MEM_COMMIT, PAGE_READWRITE); </code><code class="comments">// 在指定的进程中分配内存</code></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 初始化CreateFile参数</code></div>
<div class="line"><code class="plain">    GCreateFile.dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;</code></div>
<div class="line"><code class="plain">    GCreateFile.dwShareMode = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    GCreateFile.lpSecurityAttributes = NULL;</code></div>
<div class="line"><code class="plain">    GCreateFile.dwCreationDisposition = OPEN_ALWAYS;</code></div>
<div class="line"><code class="plain">    GCreateFile.dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;</code></div>
<div class="line"><code class="plain">    GCreateFile.hTemplateFile = NULL;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 获取CreateFile的地址</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 因为每个进程中的LoadLibrary函数都在Kernel32.dll中，而且此dll的物理页是共享的，所以我们进程中获得的LoadLibrary地址和别的进程都是一样的</code></div>
<div class="line"><code class="plain">    hModule = GetModuleHandle(</code><code class="string">"kernel32.dll"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    GCreateFile.dwCreateAPIAddr = (DWORD)GetProcAddress(hModule, </code><code class="string">"CreateFileA"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    FreeLibrary(hModule);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 初始化CreatFile文件名</code></div>
<div class="line"><code class="plain">    GCreateFile.lpFileName = (LPCTSTR)lpFilePathName;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 修改线程函数起始地址</code></div>
<div class="line"><code class="plain">    dwFunAddr = (DWORD)CreateFileThreadProc;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 间接跳</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (*((BYTE*)dwFunAddr) == </code><code class="value">0xE9</code><code class="plain">)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        dwFunAddr = dwFunAddr + </code><code class="value">5</code><code class="plain"> + *(DWORD*)(dwFunAddr + </code><code class="value">1</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 7. 开始复制</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 7.1 拷贝文件名</code></div>
<div class="line"><code class="plain">    WriteProcessMemory(hProcess, lpFilePathName, szFilePathName, strlen(szFilePathName) + </code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 7.2 拷贝线程函数</code></div>
<div class="line"><code class="plain">    WriteProcessMemory(hProcess, lpRemotThreadAddr, (LPVOID)dwFunAddr, dwThreadFunSize, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 7.3 拷贝参数</code></div>
<div class="line"><code class="plain">    WriteProcessMemory(hProcess, lpFileParamAddr, &amp;GCreateFile, sizeof(CREATEFILE_PARAM), </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 8. 创建远程线程</code></div>
<div class="line"><code class="plain">    hThread = CreateRemoteThread(hProcess, NULL, </code><code class="value">0</code><code class="plain">, (LPTHREAD_START_ROUTINE)lpRemotThreadAddr, lpFileParamAddr, </code><code class="value">0</code><code class="plain">, &amp;dwThread);</code><code class="comments">// lpAllocAddr传给线程函数的参数.因为dll名字分配在内存中</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hThread == NULL)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        OutputDebugString(</code><code class="string">"CreateRemoteThread Error! \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">        CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> FALSE;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 9. 关闭资源</code></div>
<div class="line"><code class="plain">    CloseHandle(hProcess);</code></div>
<div class="line"><code class="plain">    CloseHandle(hThread);</code></div>
<div class="line"><code class="plain">    CloseHandle(hModule);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> TRUE;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 根据进程名称获取进程ID</code></div>
<div class="line"><code class="plain">DWORD GetPID(</code><code class="keyword">char</code><code class="plain"> *szName)</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    HANDLE hProcessSnapShot = NULL;</code></div>
<div class="line"><code class="plain">    PROCESSENTRY32 pe32 = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    hProcessSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (hProcessSnapShot == (HANDLE)-</code><code class="value">1</code><code class="plain">)</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    pe32.dwSize = sizeof(PROCESSENTRY32);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (Process32First(hProcessSnapShot, &amp;pe32))</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain"> (!strcmp(szName, pe32.szExeFile)) {</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">return</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain">)pe32.th32ProcessID;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">while</code><code class="plain"> (Process32Next(hProcessSnapShot, &amp;pe32));</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        CloseHandle(hProcessSnapShot);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main()</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    RemotCreateFile(GetPID(</code><code class="string">"进程名"</code><code class="plain">), </code><code class="string">"文件名"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    </div>
        </div>

    </article>


            <nav id="ht-post-nav">
                <a href="C%2B%2B%E8%AF%AD%E8%A8%80.html" class="ht-post-nav-prev">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-prev" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-45.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>C++&#35821;&#35328;</span>
        </a>
                <a href="MFC.html" class="ht-post-nav-next">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-next" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-225.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>MFC</span>
        </a>
    </nav>    
            
    <footer id="ht-footer">
    <a href="#" id="ht-jump-top" class="sp-aui-icon-small sp-aui-iconfont-arrows-up"></a>
</footer></div>

<div>
    <div id="ht-mq-detect"></div>
</div>

    <script src="js/lunr.js"></script>
    <script src="js/lunr-extras.js"></script>
    <script src="assets/js/scroll-search.js"></script>

    <script src="assets/js/expand-macro.js"></script>
</body>
</html>
