<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>&#32593;&#32476;&#32534;&#31243; - &#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</title>

    
    <link rel="stylesheet" href="assets/css/expand-macro.css">

            <meta name="scroll-content-language-key" content="">
    
    <meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=2.0, user-scalable=yes">

<script type="text/javascript" src="assets/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/js/jquery.scrollTo.min.js"></script>


<script type="text/javascript" src="assets/js/translate.js"></script>


<script type="text/javascript" src="assets/js/scroll-tree.js"></script>

<script type="text/javascript" src="assets/js/theme.main.js"></script>

    <script type="text/javascript" src="assets/js/iframeResizer.min.js"></script>

<link rel="stylesheet" href="assets/css/content-style.css">
    <link rel="stylesheet" href="assets/css/search.css">

<link rel="stylesheet" href="assets/css/theme.main.css">
<link rel="stylesheet" href="assets/css/theme.colors.css">

            <!-- ES5 support for older browsers, needed by lunr -->
        <script src="js/augment.js"></script>
        <script id="worker" type="javascript/worker">

        startIndex = function() {
            idx = lunr.Index.load(lunrIndex);
            idx.pipeline.remove(lunr.stopWordFilter);
            postMessage({type: "setup-complete"});
        }

        onmessage = function (event) {
            var message = event.data;

            if ((message.type === 'setup') && message.baseUrl) {
                var url = message.baseUrl;
                importScripts(url + 'js/lunr.js');
                importScripts(url + 'js/lunr-extras.js');
                importScripts(url + 'js/lunr-index.js');
                importScripts(url + 'js/lunr-data.js');
                startIndex();
            }

            if (idx && (message.type === 'search-request') && message.query) {
                var searchWord = message.query;
                var results = idx.search(searchWord).map(function (result) {
                    return lunrData.filter(function (d) {
                        return d.id === parseInt(result.ref, 10)
                    })[0]
                });
                postMessage({type: 'search-results', results: results, query: searchWord, queryId: message.queryId});
            }
        }

    </script>
    </head>

<body pageid="8684305">

<div id="ht-loader">
    <noscript>
        <p style="width: 100%; text-align:center; position: absolute; margin-top: 200px;">This content cannot be displayed without JavaScript.<br>Please enable JavaScript and reload the page.</p>
    </noscript>
</div>

<div>
   	<header id="ht-headerbar">
    <div class="ht-headerbar-left">
        <a href="" id="ht-menu-toggle" class="sp-aui-icon-small sp-aui-iconfont-appswitcher"></a>
    </div>
    <div class="ht-headerbar-right">
            <div class="sp-aui-icon-small ht-search-index-loader ht-header-icon"></div>

        <div id="ht-search">
            <div class="ht-search-input" style="display: none;">
              	<a href="#" class="sp-aui-icon-small sp-aui-iconfont-remove ht-search-clear"></a>

                <form action="#" method="GET" id="search">
                    <input class="search-input" type="text" placeholder="Search" tabindex="-1" autocomplete="off" name="q" value="">
                    <input type="hidden" name="max" value="15" />
                    <input type="submit" style="display:none" tabindex="-4"/>
                </form>

                <a href="#" id="ht-search-button" class="ht-header-icon ht-header-icon-svg">
                                        <svg width="40px" height="40px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <g>
                            <path d="M29.572,28.802 L28.801,29.571 C28.515,29.857 28.187,30 27.816,30 C27.445,30 27.116,29.857 26.831,29.571 L21.392,24.134 C20.193,24.762 18.908,25.076 17.538,25.076 C15.396,25.076 13.605,24.348 12.163,22.892 C10.721,21.436 10,19.651 10,17.538 C10,15.397 10.721,13.605 12.163,12.163 C13.605,10.721 15.396,10 17.538,10 C19.651,10 21.434,10.721 22.89,12.163 C24.347,13.605 25.075,15.397 25.075,17.538 C25.075,18.937 24.761,20.222 24.132,21.393 L29.572,26.832 C29.857,27.118 30,27.446 30,27.817 C30,28.188 29.857,28.517 29.572,28.802 L29.572,28.802 Z M13.662,21.414 C14.732,22.485 16.024,23.02 17.538,23.02 C19.051,23.02 20.343,22.485 21.413,21.414 C22.484,20.344 23.019,19.052 23.019,17.538 C23.019,16.025 22.484,14.733 21.413,13.662 C20.343,12.592 19.051,12.056 17.538,12.056 C16.024,12.056 14.732,12.592 13.662,13.662 C12.591,14.733 12.056,16.025 12.056,17.538 C12.056,19.052 12.591,20.344 13.662,21.414 L13.662,21.414 Z"></path>
                        </g>
                    </svg>
              	</a>

                <div class="ht-search-dropdown ht-dropdown">
                    <ul></ul>
                </div>
            </div>
        </div>
    </div>
    </header>   	<aside id="ht-sidebar">
    <div class="ht-sidebar-content">
        <div class="ht-sidebar-content-scroll-container">
            <header class="ht-sidebar-header">
                <h1 class="ht-logo">
                    <span class="ht-logo-label">BinaryLearning</span>
                    <img class="space-logo" src="global.logo" />
                </h1>
                <a href="Binary-Learning.html" class="ht-space-link">
                    <h2>&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</h2>
                </a>
                <p><br>ᴀᴜᴛʜᴏʀ: ᴋᴇʏ<br><br>不积跬步，无以至千里；<br>不积小流，无以成江海。</p>
            </header>
                            <iframe id="ht-nav" src="toc.html?pageId=17301746"></iframe>
                <script>
                    $('iframe#ht-nav').iFrameResize(
                            { 'log': true, 'autoResize': true, 'heightCalculationMethod': 'lowestElement', 'checkOrigin': false });
                </script>
                    </div>
    </div>

</aside></div>

<div id="ht-wrap-container">

            
    <div id="ht-sidebar-dragbar">
    <div class="ht-sidebar-drag-handle">
        <span class="drag-handle-1"></span>
        <span class="drag-handle-2"></span>
        <span class="drag-handle-3"></span>
    </div>
</div>
    <article id="ht-content" class="ht-content">
        <header class="ht-content-header">
            <div id="ht-breadcrumb">
    <ul>
        <li><a href="Binary-Learning.html">&#28404;&#27700;&#36870;&#21521;&#35838;&#31243;&#31508;&#35760;</a></li>
                                                                                     <li><a href="%E5%88%9D%E7%BA%A7%E7%AF%87.html">&#21021;&#32423;&#31687;</a></li>
                                                            </ul>
</div>            <h1 id="src-17301746"> <span>&#32593;&#32476;&#32534;&#31243;</span></h1>
        </header>

        <div id="main-content" class="wiki-content sp-grid-section" data-index-for-search="true">

    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWfuuacrOamguW_teaJq-ebsg">
        <h1 class="heading "><span>&#22522;&#26412;&#27010;&#24565;&#25195;&#30450;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS4uuS7gOS5iOmcgOimgeiuoeeul-acuue9kee7nA">
        <h2 class="heading "><span>&#20026;&#20160;&#20040;&#38656;&#35201;&#35745;&#31639;&#26426;&#32593;&#32476;</span></h2>
<p   
>如下图所示，A、B、C三个不同地域的主机要想进行通信不是凭空就可以通信的，而是需要基于互联网进行互相连接、通信。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-5_13-34-4.png" alt="images/download/attachments/17301746/image2021-7-5_13-34-4.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS4uuS7gOS5iOmcgOimgeWNj-iurg">
        <h2 class="heading "><span>&#20026;&#20160;&#20040;&#38656;&#35201;&#21327;&#35758;</span></h2>
<p   
>如下图所示，红和蓝是联合攻打绿，它们以烽火为信号出动攻打绿，那么这时候就需要一个约定，比如红先点烽火，然后蓝看见了狼烟再点烽火，红看见了蓝的狼烟之后熄灭烽火，以此表示自己看见了，而蓝看见了红熄灭烽火之后也熄灭自己的烽火以此表示自己知道红看见了此信号，而后两人就需要再约定信号一起整顿出军以确保没有失误。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-5_21-41-39.png" alt="images/download/attachments/17301746/image2021-7-5_21-41-39.png" width="400"  />
    </p>
<p   
>所以我们知道蓝和红之间的通信不能保证100%成功，但是要尽量保证没有失误的话就需要一遍又一遍的去确认，而这些一次又一次的确定就是双方定下的协议；由此我们可以清楚的认识到我们在网络通信中是必须要有协议的存在的。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS4uuS7gOS5iOmcgOimgei_meS5iOWkmuWNj-iurg">
        <h2 class="heading "><span>&#20026;&#20160;&#20040;&#38656;&#35201;&#36825;&#20040;&#22810;&#21327;&#35758;</span></h2>
<p   
>上文中我们举了两军协同作战，他们之间有个作战协议，而一旦作战成功，夺下对方城池那就需要另外一个瓜分战果的协议，所以每个不同的场景都会有对应的协议，这是有这么多协议的原因。</p>
<p   
>如下图所示，我们的计算机网络也有很多协议，下面是分为五层，如果你了解过计算机网络协议应该会知道七层模型、五层模型，但本章节不讲七层模型而是选择五层模型，因为七层模型是一种理想化的模型，实际应用我们用到的是五层模型。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-12_22-7-20.png" alt="images/download/attachments/17301746/image2021-7-12_22-7-20.png" width="400"  />
    </p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-20_13-17-26.png" alt="images/download/attachments/17301746/image2021-7-20_13-17-26.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWmguS9leWumuS9jeS6kuiBlOe9keS4iueahOe7iOerrw">
        <h2 class="heading "><span>&#22914;&#20309;&#23450;&#20301;&#20114;&#32852;&#32593;&#19978;&#30340;&#32456;&#31471;</span></h2>
<p   
>首先我们熟知的系统是通过线程ID、进程ID知道对应的线程和进程的，在每个国家公民都是有身份证号码的，这也用来定位你这个人；在互联网上同样也有这样一个标识去确认终端，这就是<strong class=" ">IP地址</strong>。</p>
<p   
>IP地址以&quot;<strong class=" ">.</strong>&quot;符号分割，一共有四组，例如：120.120.120.120，每一组都是的区间都是0到255，IP地址的组成是网络号加上主机号，而具体的界定我们可以查看下文。</p>
<p   
>IP地址分为5类，其分别如下所示：</p>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col  width="49.0"/>
                                    <col  width="81.0"/>
                                    <col  width="132.0"/>
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>类型</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>起始地址</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>结束地址</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>A类</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>0.0.0.0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>127.255.255.255</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>B类</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>128.0.0.0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>191.255.255.255</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>C类</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>192.0.0.0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>223.255.255.255</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>D类</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>224.0.0.0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>239.255.255.255</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>E类</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>240.0.0.0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>247.255.255.255</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
<p   
>我们不需要死记硬背，需要的时候自己查下就可以，具体含义网上很多，这里不过多赘述。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-14_20-56-53.png" alt="images/download/attachments/17301746/image2021-7-14_20-56-53.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWmguS9leWMuuWIhuWHuue9kee7nOWPt-OAgeS4u-acuuWPtw">
        <h2 class="heading "><span>&#22914;&#20309;&#21306;&#20998;&#20986;&#32593;&#32476;&#21495;&#12289;&#20027;&#26426;&#21495;</span></h2>
<p   
>如上图中我们可以知道IP地址分成了网络号和主机号两部分，通过子网掩码可以从IP地址中区分出网络号，其运算规则是：<u class=" "><strong class=" ">网络号 = IP地址 &amp;(按位与) 子网掩码</strong></u>。</p>
<p   
>我们查看自己本机的IP地址和子网掩码来计算：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-13_13-16-49.png" alt="images/download/attachments/17301746/image2021-7-13_13-16-49.png" width="400"  />
    </p>
<p   
>IP地址：<strong class=" ">192.168.8.117</strong>，子网掩码：<strong class=" ">255.255.255.0</strong>，将这两个转为二进制则为：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">11000000.10101000</code><code class="plain">.</code><code class="value">00001000.01110101</code></div>
<div class="line"><code class="value">11111111.11111111</code><code class="plain">.</code><code class="value">11111111.00000000</code></div>
</div>
    </div>
<p   
>我们进行按位与运算，结果就是：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">11000000.10101000</code><code class="plain">.</code><code class="value">00001000.00000000</code></div>
<div class="line"><code class="plain">C0.A8.</code><code class="value">08.00</code></div>
<div class="line"><code class="value">192.168</code><code class="plain">.</code><code class="value">8.0</code></div>
</div>
    </div>
<p   
>那么在这里<strong class=" ">192.168.8.0</strong>就是其网络号，同样我们可以根据子网掩码来获取主机号，其运算规则是：<u class=" "><strong class=" ">主机号 = IP地址 &amp;(按位与) ~(取反)子网掩码</strong></u>。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">~ </code><code class="value">11111111.11111111</code><code class="plain">.</code><code class="value">11111111.00000000</code><code class="plain"> </code><code class="comments">// 取反子网掩码</code></div>
<div class="line"><code class="plain">  </code><code class="value">00000000.00000000</code><code class="plain">.</code><code class="value">00000000.11111111</code></div>
<div class="line"><code class="plain">&amp; </code><code class="value">11000000.10101000</code><code class="plain">.</code><code class="value">00001000.01110101</code><code class="plain"> </code><code class="comments">// 按位与</code></div>
<div class="line"><code class="plain">  </code><code class="value">00000000.00000000</code><code class="plain">.</code><code class="value">00000000.01110101</code></div>
<div class="line"><code class="plain">Dec -&gt; </code><code class="value">0.0</code><code class="plain">.</code><code class="value">0.117</code><code class="plain"> </code><code class="comments">// 十进制结果</code></div>
</div>
    </div>
<p   
>最终结果我们知道了其主机号为<strong class=" ">0.0.0.117</strong>。</p>
<p   
>子网掩码本质上是32位的二进制，只不过是为了看着直观一些就转为了十进制，子网掩码1所对应的位为网络号位而0所对应的位为主机号位，其用来区分有几个子网，例如这里我们的<strong class=" ">255.255.255.0</strong>，转为二进制实际上前24位是网络位，后8位是主机位，那也就表示我们只有一个子网，在这里我们的子网地址范围就是：<strong class=" ">192.168.8.0-192.168.8.255</strong>，可用的主机号计算公式就是<strong class=" ">2的8（主机位）次方-2</strong>，这里结果也就是254，为什么我们还需要减去2，这是因为根据计算方法，<strong class=" ">192.168.8.0就是网络号（代表当前网络），</strong>同时根据定义，<strong class=" ">主机号位全为1的地址为此网段的广播地址</strong>，此时的广播地址为<strong class=" ">192.168.8.255</strong>，去掉网络地址和广播地址，也就是254个主机号可用。</p>
<p   
>而如果我们的子网掩码为<strong class=" ">255.255.255.192</strong>，转为二进制就是<strong class=" ">11111111.11111111.11111111.11000000</strong>，可以看见其在我们的原先的后8位主机位中占用了2位作为网络位，现在有26个1，那么根据二进制非0即1，其表现方式就有<strong class=" ">11000000、10000000、00000000、01000000</strong>，也就是说我们将原有的<strong class=" ">192.168.8.0</strong>这个网络分成了四份，即4个子网，也可以理解为这里就是<strong class=" ">2的2（后8位主机位中占用了2位）次方</strong>，现在我们将它们转换成10进制就分别是<strong class=" ">0、64、128、192</strong>，那么这4段网络的范围如下所示：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">192.168</code><code class="plain">.</code><code class="value">8.0</code><code class="plain"> - </code><code class="value">192.168</code><code class="plain">.</code><code class="value">8.63</code></div>
<div class="line"><code class="value">192.168</code><code class="plain">.</code><code class="value">8.64</code><code class="plain"> - </code><code class="value">192.168</code><code class="plain">.</code><code class="value">8.127</code></div>
<div class="line"><code class="value">192.168</code><code class="plain">.</code><code class="value">8.128</code><code class="plain"> - </code><code class="value">192.168</code><code class="plain">.</code><code class="value">8.191</code></div>
<div class="line"><code class="value">192.168</code><code class="plain">.</code><code class="value">8.192</code><code class="plain"> - </code><code class="value">192.168</code><code class="plain">.</code><code class="value">8.255</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeerr-WPo-WPt-aYr-S7gOS5iA">
        <h2 class="heading "><span>&#31471;&#21475;&#21495;&#26159;&#20160;&#20040;</span></h2>
<p   
>问题：系统中有很多个进程连着网，比如QQ、微信、迅雷...那么系统是如何区分出数据包应该分给哪个进程呢？</p>
<p   
>答案：系统是根据端口号来区分出数据包应该分给哪个进程，每个联网的进程都会分配一个系统唯一的ID，发送数据包的时候这个ID也会放进去，接受数据包的时候就可以根据这个ID来分别出对应进程，这个ID也就是端口号。</p>
<p   
>注意：端口号的范围就是0-65535</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLee9keWFs-aYr-S7gOS5iA">
        <h2 class="heading "><span>&#32593;&#20851;&#26159;&#20160;&#20040;</span></h2>
<p   
>如下图所示，路由器就是一个网关，网关就相当于是网络的一扇门，关内是一个网络，A、B、C、D都可以在这个网内进行通信，就不需要网关了，而如果A想跟E进行通信就需要通过网关将你的请求转发去通信，这是因为E不在关内。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-20_13-6-52.png" alt="images/download/attachments/17301746/image2021-7-20_13-6-52.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLUROU-aYr-S7gOS5iA">
        <h2 class="heading "><span>DNS&#26159;&#20160;&#20040;</span></h2>
<p   
>假设你访问的是www.baidu.com，这是一个域名，但是这个域名你想要去访问到真正的那些展示给你的资源其背后对应的正是某个服务器的IP，根据这个IP和对应的端口你才可以访问到资源，而将域名和IP进行关联的正是DNS。</p>
<p   
>DNS服务器通过记录域名和IP的关联，当你想要去访问某个域名的时候，就需要给DNS服务器发送请求，而后DNS服务器接收到你的请求，将请求中想要查询的域名在DNS服务器本身的记录中去搜索找到对应的IP，最后返回给你。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-20_13-11-43.png" alt="images/download/attachments/17301746/image2021-7-20_13-11-43.png" width="400"  />
    </p>
<p   
></p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOWuouaIt-err-WSjOacjeWKoeWZqOerr-e8lueoi-aetuaehA">
        <h1 class="heading "><span>TCP&#23458;&#25143;&#31471;&#21644;&#26381;&#21153;&#22120;&#31471;&#32534;&#31243;&#26550;&#26500;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS7gOS5iOaYr1RDUA">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;TCP</span></h2>
<p   
>TCP，英文全称是Transmission Control Protocol，中文为传输<strong class=" ">控制</strong>协议，在我们之前所说的五层还是七层模型中，TCP都属于传输层。</p>
<p   
>如下图所示，A和B基于TCP协议进行传输控制，该协议可以控制协议传输或者说保证传输过程中的数据是正确的：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-20_13-15-17.png" alt="images/download/attachments/17301746/image2021-7-20_13-15-17.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLemdouWQkei_nuaOpQ">
        <h2 class="heading "><span>&#38754;&#21521;&#36830;&#25509;</span></h2>
<p   
>之前我们说到TCP协议可以保证传输过程中的数据是正确的，这是因为其是<strong class=" ">面向连接</strong>的网络协议。</p>
<p   
>如下图所示，客户端和服务器端基于TCP进行传输通信，首先客户端要跟服务器端说（发送请求）我要跟你进行连接，其次服务器端要回应（发送请求）允许客户端进行连接，而后客户端才会在发送一个请求正式连接，这就是<strong class=" ">三次握手</strong>的特点。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-7-20_13-20-23.png" alt="images/download/attachments/17301746/image2021-7-20_13-20-23.png" width="400"  />
    </p>
<p   
>当客户端和服务器端连起来之后，才是会进入传输。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeacjeWKoeWZqOerr-e8lueoi-ahhuaetg">
        <h2 class="heading "><span>&#26381;&#21153;&#22120;&#31471;&#32534;&#31243;&#26694;&#26550;</span></h2>
<p   
>了解了理论之后就要付诸于行动，在编程的时候我们的服务器端要有七个步骤去完成：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">1</code><code class="plain">. 创建套接字</code></div>
<div class="line"><code class="value">2</code><code class="plain">. 绑定套接字</code></div>
<div class="line"><code class="value">3</code><code class="plain">. 监听套接字</code></div>
<div class="line"><code class="value">4</code><code class="plain">. 等待连接</code></div>
<div class="line"><code class="value">5</code><code class="plain">. 收发数据</code></div>
<div class="line"><code class="value">6</code><code class="plain">. 断开连接(被动)</code></div>
<div class="line"><code class="value">7</code><code class="plain">. 关闭套接字</code></div>
</div>
    </div>
<p   
>这时候就有一个新的东西，就是套接字，这是系统给你打包好的，你可以理解这是网络通信过程中端点的抽象表示，而想要客户端去连接服务器端，就需要一对套接字，一个运行在服务器端，一个运行在客户端；如果概念无法很清晰的去了解，没关系，在实际编程中你就会有所体会。</p>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeaMiemhuuW6j-e8luWGmeS7o-eggQ">
        <h3 class="heading "><span>&#25353;&#39034;&#24207;&#32534;&#20889;&#20195;&#30721;</span></h3>
<p   
>首先我们创建一个Win32控制台应用的项目，其次在头部包含文件和调用lib：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;WINSOCK2.H&gt;</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"ws2_32.lib"</code><code class="plain">)</code></div>
</div>
    </div>
<p   
>接着我们就需要按照顺序去编写代码，首先第一步是创建套接字，这个需要用到一个函数socket，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">SOCKET socket(</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> af,       </code><code class="comments">// 地址族规范：常见有IPv6（AF_INET6）或IPv4（AF_INET）</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> type,     </code><code class="comments">// 套接字类型：原始套接字SOCKET_RAW（对较低层次的协议直接访问，例如IP、ICMP协议）、SOCK_STREAM面向连接（TCP/IP协议）、SOCK_DGRAM面向无连接（UDP协议）</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> protocol  </code><code class="comments">// 使用的协议：这里我们可以直接写0，这样操作系统就会根据前面两个选项推断出你想用的协议</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">SOCKET sSocket = socket(AF_INET, SOCK_STREAM, </code><code class="value">0</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>接下来我们的就需要绑定套接字，使用函数bind，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> bind(</code></div>
<div class="line"><code class="plain">  SOCKET s,                          </code><code class="comments">// 套接字：将创建的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">const</code><code class="plain"> struct sockaddr FAR *name,   </code><code class="comments">// 网络地址信息：包含通信所需要的相关信息，传递的应该是一个sockaddr结构体，在具体传参的时候，会用该结构体的变体sockaddr_in形式去初始化相关字段</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> namelen                        </code><code class="comments">// sockaddr_in结构体的长度</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>sockaddr_in结构体的定义如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">/*</code></div>
<div class="line"><code class="comments"> * Socket address, internet style.</code></div>
<div class="line"><code class="comments"> */</code></div>
<div class="line"><code class="plain">struct sockaddr_in {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">short</code><code class="plain">   sin_family; </code><code class="comments">// 地址族规范：与创建套接字时候所使用的一致即可</code></div>
<div class="line"><code class="plain">        u_short sin_port; </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">        struct  in_addr sin_addr; </code><code class="comments">// IP地址</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">char</code><code class="plain">    sin_zero[</code><code class="value">8</code><code class="plain">]; </code><code class="comments">// 无特殊的含义，只是为了与sockaddr结构体一致，因为在给套接字分配网络地址的时候会调用bind函数，其中的参数会把sockaddr_in结构体转化为sockaddr结构体</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>我们只需要关注前三个成员即可，最后一个不用管，可以看见IP地址又是一个结构体，我们接着看看in_addr结构体：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">/*</code></div>
<div class="line"><code class="comments"> * Internet address (old style... should be updated)</code></div>
<div class="line"><code class="comments"> */</code></div>
<div class="line"><code class="plain">struct in_addr {</code></div>
<div class="line"><code class="plain">        union {</code></div>
<div class="line"><code class="plain">                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;</code></div>
<div class="line"><code class="plain">                struct { u_short s_w1,s_w2; } S_un_w;</code></div>
<div class="line"><code class="plain">                u_long S_addr;</code></div>
<div class="line"><code class="plain">        } S_un;</code></div>
<div class="line"><code class="plain">#define s_addr  S_un.S_addr</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* can be used for most tcp &amp; ip code */</code></div>
<div class="line"><code class="plain">#define s_host  S_un.S_un_b.s_b2</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* host on imp */</code></div>
<div class="line"><code class="plain">#define s_net   S_un.S_un_b.s_b1</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* network */</code></div>
<div class="line"><code class="plain">#define s_imp   S_un.S_un_w.s_w2</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* imp */</code></div>
<div class="line"><code class="plain">#define s_impno S_un.S_un_b.s_b4</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* imp # */</code></div>
<div class="line"><code class="plain">#define s_lh    S_un.S_un_b.s_b3</code></div>
<div class="line"><code class="plain">                                </code><code class="comments">/* logical host */</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>这个结构体里面又是一个联合体，联合体和结构体是差不多的，区别在于联合体用于覆盖使用而结构体是不覆盖使用；</p>
<p   
>并且我们通过代码可以看见这就是一个u_long类型的地址，我们可以使用函数inet_addr来按照网络字节序转换：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">inet_addr(</code><code class="string">"192.168.1.1"</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>最终，我们在赋值的时候还是要选择某个成员去赋值，代码实现如下（需要注意的是，这里的IP地址是不可以乱写的需要通过命令行或其他方式获取本机的IP地址）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"192.168.1.1"</code><code class="plain">); </code><code class="comments">// 地址</code></div>
<div class="line"><code class="plain">sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口需要按照网络字节序，所以需要使用htons函数</code></div>
<div class="line"><code class="plain">sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">bind(sSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
</div>
    </div>
<p   
>第三步就是监听套接字，使用函数listen，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> listen(</code></div>
<div class="line"><code class="plain">  SOCKET s,    </code><code class="comments">// 套接字：将创建的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> backlog  </code><code class="comments">// 待处理连接队列的最大长度：表示队列中最多同时有多少个连接请求</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">listen(sSocket, </code><code class="value">1</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>第四步等待连接，使用函数accept，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">SOCKET accept(</code></div>
<div class="line"><code class="plain">  SOCKET s, </code><code class="comments">// 套接字：将创建的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  struct sockaddr FAR *addr, </code><code class="comments">// 输出参数，需要传入一个sockaddr结构体的地址</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> FAR *addrlen </code><code class="comments">// 输出参数，需要传入一个sockaddr结构体长度的地址</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码，accept返回的也是一个SOCKET，我们需要赋值一下</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">sockaddr_in acceptSockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> acceptSockAddrLen = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">SOCKET aSocket = accept(sSocket, (sockaddr*)&amp;acceptSockAddrInfo, &amp;acceptSockAddrLen);</code></div>
</div>
    </div>
<p   
>第五步收发数据，首先我们看下收数据，使用到函数recv，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> recv(</code></div>
<div class="line"><code class="plain">  SOCKET s,       </code><code class="comments">// 套接字：将accept返回的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">char</code><code class="plain"> FAR *buf,  </code><code class="comments">// 输出参数，数据缓冲区，接收到的数据</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> len,        </code><code class="comments">// 缓冲区大小</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> flags       </code><code class="comments">// 指定调用方式的标志，这个我们就直接写0即可</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">char</code><code class="plain"> buf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">recv(aSocket, buf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">printf(</code><code class="string">"Recv data: %s\n"</code><code class="plain">, buf);</code></div>
</div>
    </div>
<p   
>接着我们看下发数据，使用函数send，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> send(</code></div>
<div class="line"><code class="plain">  SOCKET s,             </code><code class="comments">// 套接字：将accept返回的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">const</code><code class="plain"> </code><code class="keyword">char</code><code class="plain"> FAR *buf,  </code><code class="comments">// 传输数据的缓冲区</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> len,              </code><code class="comments">// 缓冲区大小</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> flags             </code><code class="comments">// 指定调用方式的标志，这个我们就直接写0即可</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">send(aSocket, buf, strlen(buf)+</code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
</div>
    </div>
<p   
>第六步断开连接，我们使用shutdown函数，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> shutdown(</code></div>
<div class="line"><code class="plain">  SOCKET s,  </code><code class="comments">// 套接字：将accept返回的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> how    </code><code class="comments">// 断开连接的形式：SD_SEND不再发送数据、SD_RECEIVE不再接受数据、SD_BOTH不再收发数据</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">shutdown(aSocket, SD_SEND);</code></div>
</div>
    </div>
<p   
>第七步也是最后一步，关闭套接字（这里有2个都要关闭），使用函数closesocket，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> closesocket(</code></div>
<div class="line"><code class="plain">  SOCKET s  </code><code class="comments">// 套接字：将accept返回的套接字变量名字写上去</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 实现代码</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">closesocket(aSocket);</code></div>
<div class="line"><code class="plain">closesocket(sSocket);</code></div>
</div>
    </div>
<p   
>这时候还没有结束，需要使用函数WSAStartup进行Winsock的初始化，其语法格式如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> WSAStartup(</code></div>
<div class="line"><code class="plain">  WORD wVersionRequested, </code><code class="comments">// 版本号，指定所需的Windows Sockets版本，我们可以使用MAKEWORD去创建一个版本号</code></div>
<div class="line"><code class="plain">  LPWSADATA lpWSAData </code><code class="comments">// 指向WSADATA数据结构的指针，用于接收Windows Sockets实现的细节</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>实现代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">WSAStartup(wsVersion, &amp;wsaData);</code></div>
</div>
    </div>
<p   
>最终我们实现了服务器端的功能，完整代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET sSocket = socket(AF_INET, SOCK_STREAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == sSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"172.16.176.5"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(sSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 监听套接字</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> lRes = listen(sSocket, </code><code class="value">1</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == lRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 等待连接</code></div>
<div class="line"><code class="plain">    sockaddr_in acceptSockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> acceptSockAddrLen = sizeof(acceptSockAddrInfo);</code></div>
<div class="line"><code class="plain">    SOCKET aSocket = accept(sSocket, (sockaddr*)&amp;acceptSockAddrInfo, &amp;acceptSockAddrLen);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (INVALID_SOCKET == aSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"服务端等待连接失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"服务端等待连接成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 收发数据</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> buf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 循环</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="keyword">true</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> ret = recv(aSocket, buf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (ret == </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 如果recv返回为0则表示客户端要断开连接，就跳出循环断开连接</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Recv data: %s\n"</code><code class="plain">, buf);</code></div>
<div class="line"><code class="plain">        send(aSocket, buf, strlen(buf)+</code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        memset(buf, </code><code class="value">0</code><code class="plain">, </code><code class="value">100</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 断开连接(被动)</code></div>
<div class="line"><code class="plain">    shutdown(aSocket, SD_SEND);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 7. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(aSocket);</code></div>
<div class="line"><code class="plain">    closesocket(sSocket);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>最后，如果你不使用了这个扩展就需要使用WSACleanup函数去终止使用；<strong class=" ">建议在实际编程过程中，应该将函数的返回值存储下来并做判断。</strong></p>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWuouaIt-err-e8lueoi-ahhuaetg">
        <h2 class="heading "><span>&#23458;&#25143;&#31471;&#32534;&#31243;&#26694;&#26550;</span></h2>
<p   
>客户端编程框架的步骤就简单了一些，只有六个步骤：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">1</code><code class="plain">. 创建套接字</code></div>
<div class="line"><code class="value">2</code><code class="plain">. 绑定套接字</code></div>
<div class="line"><code class="value">3</code><code class="plain">. 连接服务器</code></div>
<div class="line"><code class="value">4</code><code class="plain">. 收发数据</code></div>
<div class="line"><code class="value">5</code><code class="plain">. 断开连接(主动)</code></div>
<div class="line"><code class="value">6</code><code class="plain">. 关闭套接字</code></div>
</div>
    </div>
<p   
>了解了服务器端如何编写，客户端也就了如指掌的，实现代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET cSocket = socket(AF_INET, SOCK_STREAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == cSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"172.16.176.12"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2119</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(cSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 连接服务器</code></div>
<div class="line"><code class="plain">    sockaddr_in serverSockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    serverSockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"172.16.176.5"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    serverSockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    serverSockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> cRes = connect(cSocket, (sockaddr*)&amp;serverSockAddrInfo, sizeof(serverSockAddrInfo));</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == cRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"与服务器连接失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"与服务器连接成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 收发数据</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Input: "</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> sendData[</code><code class="value">100</code><code class="plain">];</code></div>
<div class="line"><code class="plain">    scanf(</code><code class="string">"%s"</code><code class="plain">, sendData);</code></div>
<div class="line"><code class="plain">    send(cSocket, sendData, strlen(sendData)+</code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> buf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    recv(cSocket, buf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Recv data: %s \n"</code><code class="plain">, buf);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 断开连接(主动)</code></div>
<div class="line"><code class="plain">    shutdown(cSocket, SD_SEND);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 6. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(cSocket);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>与服务器端不同的是，客户端需要连接服务器端，同样也是通过sockaddr_in结构体去指定服务器端的地址和端口，使用到了一个新的函数connect，该函数语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> connect(</code></div>
<div class="line"><code class="plain">  SOCKET s,                         </code><code class="comments">// 套接字：</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">const</code><code class="plain"> struct sockaddr FAR *name,  </code><code class="comments">// sockaddr 结构体</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> namelen                       </code><code class="comments">// 结构体长度</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-7_17-33-37.png" alt="images/download/attachments/17301746/image2021-8-7_17-33-37.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLemcgOimgeihpeWFheeahOiDjOaZr-efpeivhg">
        <h2 class="heading "><span>&#38656;&#35201;&#34917;&#20805;&#30340;&#32972;&#26223;&#30693;&#35782;</span></h2>
<p   
>补充的背景知识实际上是之前也了解过的存储数据的大、小端的存储模式，这里就不再过多赘述。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">字节序: 字节与存储位置的关系</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">小端: 将低序字节存储在起始地址</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">大端: 将高序字节存储在起始地址</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">网络字节序: 顾名思义就是网络上的字节序</code></div>
</div>
    </div>
<p   
>我们需要重点的是网络字节序，其顾名思义就是网络上的字节序，比如说一个数据在你电脑上存储的是小端存储，而可能在网络传输的时候就是大端模式，所以你就需要将你电脑上的存储的数据转换。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOS4ieasoeaPoeaJi-S4juaKk-WMheWIhuaekA">
        <h1 class="heading "><span>TCP&#19977;&#27425;&#25569;&#25163;&#19982;&#25235;&#21253;&#20998;&#26512;</span></h1>
<p   
>虽然我们已经了解过TCP三次握手的流程，但是里面具体的细节，我们并不了解，了解这些细节也有便于我们去深入了解TCP协议以及解决今后细节性的问题。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_11-48-17.png" alt="images/download/attachments/17301746/image2021-8-8_11-48-17.png" width="400"  />
    </p>
<p   
>在这里，我们使用Wireshark这个抓包工具，下载地址：<a  class="external-link" href="https://www.wireshark.org/">https://www.wireshark.org/</a></p>
<p   
>接下来我们使用两台机器作为服务器端和客户端，在客户端机器上安装Wireshark软件进行抓包，如下图（左服务器端，右客户端）：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-7_20-57-19.png" alt="images/download/attachments/17301746/image2021-8-7_20-57-19.png" width="400"  />
    </p>
<p   
>Wireshark直接抓网卡的流量即可，用过滤语法来过滤一下：<u class=" "><strong class=" ">(ip.dst==172.16.176.5 and tcp.port==2118) or (ip.src==172.16.176.5)</strong></u>，172.16.176.5地址为服务器端的IP地址，172.16.176.12地址为客户端的IP地址。</p>
<p   
>如下图所示，我们一共抓到了三个包， 这三个包就是我们所说的三次握手对应的包。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-7_20-59-39.png" alt="images/download/attachments/17301746/image2021-8-7_20-59-39.png" width="600"  />
    </p>
<p   
>首先我们可以看到第一个包，就是客户端向服务器端发送SYN（同步序列编号）包，我们可以看见其有一个seq=0，这表示一个序号，是随机的；</p>
<p   
>接着服务器端响应该请求，返回了SYN+ACK（确认字符）包表示允许连接，同样也有一个seq=0，并且多出了一个ack=1，同样这里的seq是随机表示的，而ack则是由第一个包的seq=0这个值+1的结果；</p>
<p   
>最后客户端收到确认请求，回应服务器端的请求表示连接成功，发送了ACK包，seq我们就不用管了，这里ack的值也是第二个包的seq=0这个值+1的结果。</p>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOWbm-asoeaPoeaJi-S4juaKk-WMheWIhuaekA">
        <h1 class="heading "><span>TCP&#22235;&#27425;&#25569;&#25163;&#19982;&#25235;&#21253;&#20998;&#26512;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS6huino-Wbm-asoeaPoeaJiw">
        <h2 class="heading "><span>&#20102;&#35299;&#22235;&#27425;&#25569;&#25163;</span></h2>
<p   
>之前我们所了解的三次握手，是在建立连接时的，而我们现在所需要了解的四次握手，则是在断开连接时的；你可以思考一下为什么在这里连接时需要三次握手，而在断开连接时，却需要四次握手呢？</p>
<p   
>我们可以看见如下图，假设服务器端和客户端是两个相亲相爱的恋人，客户端提出要跟服务器端分手，需要得到服务器端的确认，而不仅仅是单方面的分手，服务器端也要提出跟客户端分手，客户端也要确认。那么为什么需要这样呢？</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_11-47-48.png" alt="images/download/attachments/17301746/image2021-8-8_11-47-48.png" width="400"  />
    </p>
<p   
>这时候我们需要了解通信中的三种通信模式：</p>
<ol class=" "><li class=" "><p   
>单工：A和B进行通信，只能有一方发送，一方接收，只有一条通信线路；</p>
</li><li class=" "><p   
>双工：A和B进行通信，双方可以同时互相发送接收，有两条通信线路；</p>
</li><li class=" "><p   
>准双工：A和B进行通信，双方可以互相发送接收，但不可以同时进行，只有一条通信线路。</p>
</li></ol><p   
>在互联网中采用了这种双工的通信模式，所以说当客户端给服务器端说要断开通信的时候，实际上只断开了一条通信线路，还有一条通信线路需要服务器端给客户端说要断开通信才会断开。</p>
<p   
>如下图所示，发送断开连接就是先发送FIN包，等待对方发送ACK包回应：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_11-56-29.png" alt="images/download/attachments/17301746/image2021-8-8_11-56-29.png" width="400"  />
    </p>
<p   
>我们可以来看下TCP建立连接、通信、断开连接全貌：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_11-49-58.png" alt="images/download/attachments/17301746/image2021-8-8_11-49-58.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeaKk-WMheWIhuaekA">
        <h2 class="heading "><span>&#25235;&#21253;&#20998;&#26512;</span></h2>
<p   
>在抓包之前，我们需要改一下服务器端的代码，在收发数据时，我们应该写一个死循环，然后判断recv函数的返回值是否为0，为0则表示客户端要断开连接，就跳出循环从而进入断开连接的代码：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_16-46-1.png" alt="images/download/attachments/17301746/image2021-8-8_16-46-1.png" width="600"  />
    </p>
<p   
>最后，来使用Wireshark抓包测试一下看看这个全貌：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_12-32-24.png" alt="images/download/attachments/17301746/image2021-8-8_12-32-24.png" width="600"  />
    </p>
<p   
>可以看见果然如我们所了解的在断开连接的时候发送了FIN以及ACK包，这里的seq的值和ack的值与我们之前所说的是一样的，seq是随机的，但ack的值是根据上一条的seq的值+1所得出来的。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVVEUOWuouaIt-err-WSjOacjeWKoeWZqOerr-e8lueoi-aetuaehA">
        <h1 class="heading "><span>UDP&#23458;&#25143;&#31471;&#21644;&#26381;&#21153;&#22120;&#31471;&#32534;&#31243;&#26550;&#26500;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS7gOS5iOaYr1VEUA">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;UDP</span></h2>
<p   
>UDP是User Datagram Protocol的首字母简写，翻译过来就是标识用户数据报协议。UDP也是属于传输层的协议，从名字上来看，TCP是传输控制，而UDP是用户数据报，其实也就说明了UDP协议并不会去控制传输。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLemdouWQkeaXoOi_nuaOpQ">
        <h2 class="heading "><span>&#38754;&#21521;&#26080;&#36830;&#25509;</span></h2>
<p   
>面向无连接，就是不用去询问服务器允不允许发送数据，他不管你怎么办，直接就给你发送数据了。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-8_16-24-34.png" alt="images/download/attachments/17301746/image2021-8-8_16-24-34.png" width="400"  />
    </p>
<p   
>这样做的好处就是非常高效，但是却没办法保证数据是否正确地传递过去了。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeacjeWKoeWZqOerr-e8lueoi-ahhuaeti4x">
        <h2 class="heading "><span>&#26381;&#21153;&#22120;&#31471;&#32534;&#31243;&#26694;&#26550;</span></h2>
<p   
>在UDP协议中服务器端和客户端的概念被弱化了，很难界定客户端与服务端，所以一般在UDP协议中，我们不以服务器端和客户端概念去做称谓，而是以端对端这种概念。</p>
<p   
>接着就是服务器端编程框架：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">1</code><code class="plain">. 创建套接字</code></div>
<div class="line"><code class="value">2</code><code class="plain">. 绑定套接字</code></div>
<div class="line"><code class="value">3</code><code class="plain">. 收发数据</code></div>
<div class="line"><code class="value">4</code><code class="plain">. 关闭套接字</code></div>
</div>
    </div>
<p   
>实际代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET sSocket = socket(AF_INET, SOCK_DGRAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == sSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"172.16.176.5"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(sSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 收发数据</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> recvBuf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="keyword">true</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        recvfrom(sSocket, recvBuf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">, NULL, NULL);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (strlen(recvBuf) != </code><code class="value">0</code><code class="plain">){</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Recv Data: %s \n"</code><code class="plain">, recvBuf);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        memset(recvBuff, </code><code class="value">0</code><code class="plain">, </code><code class="value">100</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(sSocket);</code></div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>相比较TCP协议我们少了很多代码，并且在创建套接字的时候参数变成了SOCK_DGRAM，我们还需要了解一个新函数recvfrom，这个函数是用来收信息的，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> recvfrom(</code></div>
<div class="line"><code class="plain">  SOCKET s,                   </code><code class="comments">// 套接字</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">char</code><code class="plain"> FAR* buf,              </code><code class="comments">// 输出参数，接收数据的缓冲区</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> len,                    </code><code class="comments">// 缓冲区长度</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> flags,                  </code><code class="comments">// 指定调用方式的标志，这个我们就直接写0即可</code></div>
<div class="line"><code class="plain">  struct sockaddr FAR *from,  </code><code class="comments">// 输出参数（可选，我们可以直接写NULL），sockaddr结构体</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> FAR *fromlen            </code><code class="comments">// 输入输出共用参数（可选，我们可以直接写NULL），sockaddr结构体的大小，注意这里需要传入实际的大小</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWuouaIt-err-e8lueoi-ahhuaeti4x">
        <h2 class="heading "><span>&#23458;&#25143;&#31471;&#32534;&#31243;&#26694;&#26550;</span></h2>
<p   
>了解了，服务端变成框架之后我们再来看客户端会发现，它的步骤更加简单：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">1</code><code class="plain">. 创建套接字</code></div>
<div class="line"><code class="value">2</code><code class="plain">. 收发数据</code></div>
<div class="line"><code class="value">3</code><code class="plain">. 关闭套接字</code></div>
</div>
    </div>
<p   
>实际代码如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET cSocket = socket(AF_INET, SOCK_DGRAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == cSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 收发数据</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Input: "</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> sendBuf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    scanf(</code><code class="string">"%s"</code><code class="plain">, sendBuf);</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET;</code></div>
<div class="line"><code class="plain">    sendto(cSocket, sendBuf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(cSocket);</code></div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
>与服务端意义，这里有一个新函数sendto，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> sendto(</code></div>
<div class="line"><code class="plain">  SOCKET s,                        </code><code class="comments">// 套接字</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">const</code><code class="plain"> </code><code class="keyword">char</code><code class="plain"> FAR *buf,             </code><code class="comments">// 发送的数据</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> len,                         </code><code class="comments">// 发送的数据长度</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> flags,                       </code><code class="comments">// 指定调用方式的标志，这个我们就直接写0即可</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">const</code><code class="plain"> struct sockaddr FAR *to,   </code><code class="comments">// sockaddr 结构体，表示发送数据给谁</code></div>
<div class="line"><code class="plain">  </code><code class="keyword">int</code><code class="plain"> tolen                        </code><code class="comments">// sockaddr 结构体长度</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOWSjFVEUOeahOavlOi-gw">
        <h2 class="heading "><span>TCP&#21644;UDP&#30340;&#27604;&#36739;</span></h2>
<p   
>如下就是TCP协议和UDP协议的优缺点，我们可以根据实际场景情况，并根据两个协议的优缺点去选择适合当前场景的协议。</p>
    <div  class="tablewrap">
        <table class="relative-table wrapped confluenceTable">
                    <colgroup>
                                    <col  width="16.129%"/>
                                    <col  width="35.8065%"/>
                                    <col  width="48.0645%"/>
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>协议</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>优点</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>缺点</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>TCP</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>传输可靠</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>慢、低效、流程繁琐</p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>UDP</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>传输效率高</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>传输不可靠</p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunueOsOerr-Wvueerr-S6kuebuOaUtuWPkQ">
        <h2 class="heading "><span>&#23454;&#29616;&#31471;&#23545;&#31471;&#20114;&#30456;&#25910;&#21457;</span></h2>
<p   
>我们已经知道了，在UDP中不存在客户端和服务端着两个概念，所有传输都是端对端的，不会区分，现在我们实现端对端互相收发数据，并且在发出或收到数据内容为close的时候关闭连接：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET cSocket = socket(AF_INET, SOCK_DGRAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == cSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2119</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(cSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 收发数据</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> recvBuf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> sendBuf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    sockaddr sockclient = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfoS = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    sockAddrInfoS.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfoS.sin_port = htons(</code><code class="value">2118</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfoS.sin_family = AF_INET;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="keyword">true</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Input: "</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        gets(sendBuf); </code><code class="comments">// 这里使用了gets函数替换了scanf函数，是因为scanf函数在获取数据的时候遇到了空格，就不会再去管空格后面的数据了，相当于截断了</code></div>
<div class="line"><code class="plain">        sendto(cSocket, sendBuf, strlen(sendBuf)+</code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">, (sockaddr*)&amp;sockAddrInfoS, sizeof(sockAddrInfoS));</code></div>
<div class="line"><code class="plain">        recvfrom(cSocket, recvBuf, sizeof(recvBuf), </code><code class="value">0</code><code class="plain">, NULL, NULL);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (strlen(recvBuf) != </code><code class="value">0</code><code class="plain">){</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Recv Data: %s \n"</code><code class="plain">, recvBuf);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> ((strcmp(recvBuf, </code><code class="string">"close"</code><code class="plain">)==</code><code class="value">0</code><code class="plain">) || (strcmp(sendBuf, </code><code class="string">"close"</code><code class="plain">)==</code><code class="value">0</code><code class="plain">))</code></div>
<div class="line"><code class="plain">        {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        memset(recvBuf, </code><code class="value">0</code><code class="plain">, </code><code class="value">100</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(cSocket);</code></div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWkmui_nuaOpeS5i-Wkmue6v-eoi-ino-WGs-aWueahiA">
        <h1 class="heading "><span>&#22810;&#36830;&#25509;&#20043;&#22810;&#32447;&#31243;&#35299;&#20915;&#26041;&#26696;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWNlei_nuaOpemdouS4tOeahOeqmOWigw">
        <h2 class="heading "><span>&#21333;&#36830;&#25509;&#38754;&#20020;&#30340;&#31384;&#22659;</span></h2>
<p   
>单连接如下图所示当一个客户端和服务器进行通信时，其它客户端就需要排队，那如果是一个电商网站，你想一下有人买东西会先看很久，然后再对比，然后再挑选，当他这一系列动作完成之后可能已经几个小时过去了，那么请问你能忍受得了等这么几个小时的队伍吗？ 这也是当年结面临的窘境。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-9_19-34-8.png" alt="images/download/attachments/17301746/image2021-8-9_19-34-8.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS7gOS5iOaYr-Wkmui_nuaOpQ">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;&#22810;&#36830;&#25509;</span></h2>
<p   
>多连接就是解决单连接所面临的窘境，使得多个客户端可以同时跟一个服务器进行通信。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-9_19-49-13.png" alt="images/download/attachments/17301746/image2021-8-9_19-49-13.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWkmui_nuaOpeaJgOmdouS4tOeahOmXrumimA">
        <h2 class="heading "><span>&#22810;&#36830;&#25509;&#25152;&#38754;&#20020;&#30340;&#38382;&#39064;</span></h2>
<p   
>多连接解决了多客户端与服务器通信排队的问题，但同样也会出现新的问题，当多个客户端连接过来时，服务器应该先给谁回复？这时候就会有一个顺序逻辑的问题。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-9_20-2-18.png" alt="images/download/attachments/17301746/image2021-8-9_20-2-18.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWkmue6v-eoi-ino-WGs-aWueahiA">
        <h2 class="heading "><span>&#22810;&#32447;&#31243;&#35299;&#20915;&#26041;&#26696;</span></h2>
<p   
>为了解决多连接所面临的问题，这时候就需要用到多线程的解决方案，为每个客户端连接开一个线程，主线程只管负责监听客户端连接请求，而真正负责通信的任务转交为工作线程。</p>
<p   
>同样一个东西总会有好也有坏，在这里多线程解决方案优点很明显，但缺点同样也很致命。</p>
<p   
>优点：整个逻辑非常清楚，编程实现及维护都相对容易；</p>
<p   
>缺点：占用系统资源太严重，客户端数量上升到一定程度，容易造成系统瘫痪（资源用光了）。</p>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmQ">
        <h3 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h3>
<p   
>学过Win32的话应该了解到当我们打开一个进程的时候，会默认启用一个线程（每个进程至少需要一个线程），那么我们可以用这个线程作为主线程，负责监听客户端连接请求，再用之前学习到的<strong class=" ">CreateThread</strong>函数创建新的工作线程负责通信（收发信息）。</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter);</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET sSocket = socket(AF_INET, SOCK_STREAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == sSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(sSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 监听套接字</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> lRes = listen(sSocket, </code><code class="value">1</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == lRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 循环</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="keyword">true</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 4. 等待连接</code></div>
<div class="line"><code class="plain">        sockaddr_in acceptSockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> acceptSockAddrLen = sizeof(acceptSockAddrInfo);</code></div>
<div class="line"><code class="plain">        SOCKET aSocket = accept(sSocket, (sockaddr*)&amp;acceptSockAddrInfo, &amp;acceptSockAddrLen);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (INVALID_SOCKET != aSocket) {</code></div>
<div class="line"><code class="plain">            HANDLE hThread = CreateThread(NULL, NULL, ThreadProc, (LPVOID)aSocket, </code><code class="value">0</code><code class="plain">, NULL);</code></div>
<div class="line"><code class="plain">            CloseHandle(hThread);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 7. 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(sSocket);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">DWORD WINAPI ThreadProc(LPVOID lpParameter) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> ret = </code><code class="value">1</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    SOCKET aSocket = (SOCKET)lpParameter;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> buf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 收发数据</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> </code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        ret = recv(aSocket, buf, </code><code class="value">100</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (strcmp(buf, </code><code class="string">"close"</code><code class="plain">) == </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Recv data: %s \n"</code><code class="plain">, buf);</code></div>
<div class="line"><code class="plain">        send(aSocket, buf, strlen(buf)+</code><code class="value">1</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        memset(buf, </code><code class="value">0</code><code class="plain">, </code><code class="value">100</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (ret != </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 断开连接(被动)</code></div>
<div class="line"><code class="plain">    shutdown(aSocket, SD_BOTH);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 关闭套接字</code></div>
<div class="line"><code class="plain">    closesocket(aSocket);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-9_22-27-57.png" alt="images/download/attachments/17301746/image2021-8-9_22-27-57.png" width="400"  />
    </p>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWkmui_nuaOpeS5i3NlbGVjdOaooeWeiw">
        <h1 class="heading "><span>&#22810;&#36830;&#25509;&#20043;select&#27169;&#22411;</span></h1>
<p   
>多连接需求使用多线程的方式去满足，但是同样也造成了当客户端连接数量到达一定程度，就会导致占用系统资源太过于严重，所以我们可以使用select模型解决方案处理多连接，并节省系统资源。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS7gOS5iOaYr3NlbGVjdOaooeWeiw">
        <h2 class="heading "><span>&#20160;&#20040;&#26159;select&#27169;&#22411;</span></h2>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLXNlbGVjdOaooeWei-eahOacrOi0qA">
        <h3 class="heading "><span>select&#27169;&#22411;&#30340;&#26412;&#36136;</span></h3>
<p   
>select的中文意思是选择，也就表示是从某些东西中去选择自己想要的，如下图所示，有两个地方可供我们选择，也就是可读检测池、可写检测池，在这两个池子里的是我们的套接字句柄（SOCKET）。</p>
<p   
>从字面意思理解，<strong class=" ">select可从诸多连接中检测出可读的（accpet函数），也就是有响应的连接；也可以从诸多连接中检测出可写的（recv、send函数），也就是可以发送消息的连接。</strong></p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-9_23-27-43.png" alt="images/download/attachments/17301746/image2021-8-9_23-27-43.png" width="400"  />
    </p>
    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLXNlbGVjdOaooeWei-mAu-i-kQ">
        <h3 class="heading "><span>select&#27169;&#22411;&#36923;&#36753;</span></h3>
<p   
>select模型逻辑步骤如下：</p>
<ol class=" "><li class=" "><p   
>将所有的socket装进一个数组中</p>
</li><li class=" "><p   
>通过select函数遍历socket数组，取出有响应（可读、可写）的socket放进另一个数组</p>
</li><li class=" "><p   
>对存入有响应的socket数组处理</p>
</li></ol>    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLXNlbGVjdOWHveaVsA">
        <h3 class="heading "><span>select&#20989;&#25968;</span></h3>
<p   
>select模型实际上就是调用了select这个函数，其语法如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> select (</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> nfds, </code><code class="comments">// 填0</code></div>
<div class="line"><code class="plain">    fd_set *readfds, </code><code class="comments">// 输入输出共用参数，检查/输出可读的socket</code></div>
<div class="line"><code class="plain">    fd_set *writefds, </code><code class="comments">// 输入输出共用参数，检查/输出可写的socket</code></div>
<div class="line"><code class="plain">    fd_set *exceptfds, </code><code class="comments">// 输入输出共用参数，检查/输出socket上的异常错误</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">const</code><code class="plain"> struct timeval *timeout </code><code class="comments">// struct timeval结构体，最大等待时间，当socket没有响应时，要等待的时间</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>该函数的作用就是检测出可读、可写的socket，它的返回值有这些：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">0</code><code class="plain">: 指定等待时间内没有socket响应，continue进行下一次等待</code></div>
<div class="line"><code class="plain">大于0: 有socket响应</code></div>
<div class="line"><code class="plain">SOCKET_ERROR(宏): 发送错误</code></div>
</div>
    </div>
<p   
>除了需要了解这个函数以外，我们可以看见其成员是一个fd_set结构体，我们还需要了解一下这个结构体和几个常用的宏。</p>
    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLWZkX3NldOe7k-aehOS9kw">
        <h3 class="heading "><span>fd_set&#32467;&#26500;&#20307;</span></h3>
<p   
>fd_set是用来装socket的结构体，默认情况下，它可以装64个socket：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#ifndef FD_SETSIZE</code></div>
<div class="line"><code class="plain">#define FD_SETSIZE      </code><code class="value">64</code></div>
<div class="line"><code class="plain">#endif </code><code class="comments">/* FD_SETSIZE */</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">typedef struct fd_set {</code></div>
<div class="line"><code class="plain">        u_int fd_count;               </code><code class="comments">// 统计的数量</code></div>
<div class="line"><code class="plain">        SOCKET  fd_array[FD_SETSIZE]; </code><code class="comments">// 存放SOCKET的数组</code></div>
<div class="line"><code class="plain">} fd_set;</code></div>
</div>
    </div>
<p   
>如果你想装更多的socket，可以通过在<strong class=" ">winsock2.h头文件前声明宏</strong>，给一个更大的值：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define FD_SETSIZE </code><code class="value">128</code></div>
<div class="line"><code class="plain">#include &lt;WinSock2.h&gt;</code></div>
</div>
    </div>
<p   
>select的原理就是不停的检测，越多的socket效率就越低，延迟就越大，所以说这个模型只适合小用户量去访问，应该自己选择一个合适的大小。</p>
    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWbm-S4quaTjeS9nGZkX3NldOeahOaTjeS9nOWujw">
        <h3 class="heading "><span>&#22235;&#20010;&#25805;&#20316;fd_set&#30340;&#25805;&#20316;&#23439;</span></h3>
    <div  class="tablewrap">
        <table class="wrapped confluenceTable">
                    <colgroup>
                                    <col />
                                    <col />
                                    <col />
                            </colgroup>
        <thead class=" ">    <tr>
            <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>操作宏</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>作用</p>
            </td>
                <td  class="confluenceTh" rowspan="1" colspan="1">
    <p   
>代码</p>
            </td>
        </tr>
</thead><tfoot class=" "></tfoot><tbody class=" ">    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>FD_ZERO</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>将客户端socket集合清零</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
><tt class=" ">FD_ZERO(&amp;clientSockets);</tt></p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>FD_SET</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>添加一个socket(超过默认值大小不再处理)</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
><tt class=" ">FD_SET(socketListen, &amp;clientSockets);</tt></p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>FD_CLR</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>从集合中删除指定的socket一定要close，手动释放</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
><tt class=" ">FD_CLR(socketListen, &amp;clientSockets);</tt></p>
<p   
><tt class=" ">closesocket(socketListen);</tt></p>
            </td>
        </tr>
    <tr>
            <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>FD_ISSET</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
>查询socket是否在集合中，不存在返回0，存在返回非0</p>
            </td>
                <td  class="confluenceTd" rowspan="1" colspan="1">
    <p   
><tt class=" ">FD_ISSET(socketListen, &amp;clientSockets);</tt></p>
            </td>
        </tr>
</tbody>        </table>
            </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS4x">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
<p   
>按照select模型逻辑编写代码即可：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 0. 初始化</code></div>
<div class="line"><code class="plain">    WORD wsVersion = MAKEWORD(</code><code class="value">2</code><code class="plain">, </code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    WSADATA wsaData = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    WSAStartup(wsVersion, &amp;wsaData);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 创建套接字</code></div>
<div class="line"><code class="plain">    SOCKET sSocket = socket(AF_INET, SOCK_STREAM, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == sSocket) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建失败!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"套接字闯创建成功!\n"</code><code class="plain"> );</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 绑定套接字</code></div>
<div class="line"><code class="plain">    sockaddr_in sockAddrInfo = {</code><code class="value">0</code><code class="plain">};    </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_addr.S_un.S_addr = inet_addr(</code><code class="string">"127.0.0.1"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_port = htons(</code><code class="value">2118</code><code class="plain">); </code><code class="comments">// 端口</code></div>
<div class="line"><code class="plain">    sockAddrInfo.sin_family = AF_INET; </code><code class="comments">// 地址族规范</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> bRes = bind(sSocket, (sockaddr*)&amp;sockAddrInfo, sizeof(sockAddrInfo));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == bRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"绑定成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 监听套接字</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> lRes = listen(sSocket, </code><code class="value">5</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (SOCKET_ERROR == lRes) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听失败!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"监听成功!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    fd_set fdSocket; </code><code class="comments">// 定义</code></div>
<div class="line"><code class="plain">    FD_ZERO(&amp;fdSocket); </code><code class="comments">// 初始化</code></div>
<div class="line"><code class="plain">    FD_SET(sSocket, &amp;fdSocket); </code><code class="comments">// 将当前服务器创建的socket放入集合中</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">while</code><code class="plain"> (</code><code class="keyword">true</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        fd_set readfds = fdSocket; </code><code class="comments">// 定义可读的集合</code></div>
<div class="line"><code class="plain">        fd_set writefds = fdSocket; </code><code class="comments">// 定义可写的集合</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// fd_set exceptfds = fdSocket;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">        </code><code class="comments">// 获取select函数的返回值</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">int</code><code class="plain"> iRes = select(</code><code class="value">0</code><code class="plain">, &amp;readfds, &amp;writefds, NULL, NULL);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 如果返回值大于0则说明不存在无响应、错误的情况，继续向下</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (iRes &gt; </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 遍历可写集合，给每个socket发送Hello</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (u_int i = </code><code class="value">0</code><code class="plain">; i &lt; writefds.fd_count; i++) {</code></div>
<div class="line"><code class="plain">                send(readfds.fd_array[i], </code><code class="string">"Hello"</code><code class="plain">, </code><code class="value">6</code><code class="plain">, </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            </code><code class="comments">// 遍历可读集合</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; readfds.fd_count; i++) {</code></div>
<div class="line"><code class="plain">                </code><code class="comments">// 如果socket为当前服务器创建的scoket则进入accept等待消息</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">if</code><code class="plain"> (readfds.fd_array[i] == sSocket) {</code></div>
<div class="line"><code class="plain">                    sockaddr_in s = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">int</code><code class="plain"> l = sizeof(s);</code></div>
<div class="line"><code class="plain">                    SOCKET aSocket = accept(sSocket, (sockaddr*)&amp;s, &amp;l);</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">if</code><code class="plain"> (INVALID_SOCKET == aSocket)</code></div>
<div class="line"><code class="plain">                    {</code></div>
<div class="line"><code class="plain">                        </code><code class="keyword">continue</code><code class="plain">;</code></div>
<div class="line"><code class="plain">                    }</code></div>
<div class="line"><code class="plain">                    FD_SET(aSocket, &amp;fdSocket);</code></div>
<div class="line"><code class="plain">                    </code><code class="comments">// inet_ntoa获取IP</code></div>
<div class="line"><code class="plain">                    printf(</code><code class="string">"Accpet Client IP: %s \n"</code><code class="plain">, inet_ntoa(s.sin_addr));</code></div>
<div class="line"><code class="plain">                </code><code class="comments">// 如果不是，则进入接收消息</code></div>
<div class="line"><code class="plain">                } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">char</code><code class="plain"> buf[</code><code class="value">100</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">int</code><code class="plain"> iRecv = recv(readfds.fd_array[i], buf, sizeof(buf), </code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                    </code><code class="comments">// 判断接收消息的返回值，大于0则表示接收成功。</code></div>
<div class="line"><code class="plain">                    </code><code class="keyword">if</code><code class="plain"> (iRecv &gt; </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">                        printf(</code><code class="string">"Recv: %s \n"</code><code class="plain">, buf);</code></div>
<div class="line"><code class="plain">                    </code><code class="comments">// 否则就关闭连接、关闭套接字</code></div>
<div class="line"><code class="plain">                    } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">                        SOCKET tSocket = readfds.fd_array[i];</code></div>
<div class="line"><code class="plain">                        FD_CLR(tSocket, &amp;fdSocket);</code></div>
<div class="line"><code class="plain">                        shutdown(tSocket, SD_BOTH);</code></div>
<div class="line"><code class="plain">                        closesocket(tSocket);</code></div>
<div class="line"><code class="plain">                    }</code></div>
<div class="line"><code class="plain">                }</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">continue</code><code class="plain">;</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    closesocket(sSocket);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    WSACleanup();</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_12-27-49.png" alt="images/download/attachments/17301746/image2021-8-10_12-27-49.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLemBjeWOhueJqeeQhue9keWNoQ">
        <h1 class="heading "><span>&#36941;&#21382;&#29289;&#29702;&#32593;&#21345;</span></h1>
<p   
>如果你要抓网络的包，首先你要知道你要处理的是哪个网卡，那么你就要知道这个网卡的相关信息，所以本章节就遍历物理网卡并获取相关信息。</p>
<p   
>我们都知道在Windows操作系统上，我们没有办法直接去操作硬件层的东西，因为这就涉及到驱动内核了，我们想要去用的话就需要通过Windows系统封装好的库，在这里我们使用到的就WinPcap库。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVdpblBjYXDku4vnu40">
        <h2 class="heading "><span>WinPcap&#20171;&#32461;</span></h2>
<p   
>WinPcap(Windows Packet Capture)是Windows平台下一个免费的、公共的库。开发WinPcap这个项目的目的在于为Win32 App提供访问网络底层的能力。</p>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeW4uOeUqOWKn-iDvQ">
        <h3 class="heading "><span>&#24120;&#29992;&#21151;&#33021;</span></h3>
<p   
>WinPcap常用的功能如下所示：</p>
<ol class=" "><li class=" "><p   
>捕获原始数据包，无论它是发往某台机器的，还是在其他设备(共享媒介)上进行交换的；</p>
</li><li class=" "><p   
>在数据包发送给某应用程序前，根据用户指定的规则过滤数据包；</p>
</li><li class=" "><p   
>将原始数据包通过网络发送出去；</p>
</li><li class=" "><p   
>收集并统计网络流量信息。</p>
</li></ol>    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS4i-i9veS4jumFjee9rg">
        <h3 class="heading "><span>&#19979;&#36733;&#19982;&#37197;&#32622;</span></h3>
<p   
>WinPcap库并不是Windows系统自带的，而是由外部开发者去维护的，我们可以从这个地址去下载：<a  class="external-link" href="https://www.winpcap.org/archive/4.0.1-WpdPack.zip">https://www.winpcap.org/archive/4.0.1-WpdPack.zip</a>，如果你是基于VC6去使用的话，选择&gt;=4.0.1的版本。</p>
<p   
>下载下来之后是一个压缩包，主要的就是Lib和Include这两个文件夹：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_15-13-14.png" alt="images/download/attachments/17301746/image2021-8-10_15-13-14.png" width="400"  />
    </p>
<p   
>将这两个文件夹存放好，在VC6中打开Tools-Options，填入两个文件夹所在路径：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_15-21-41.png" alt="images/download/attachments/17301746/image2021-8-10_15-21-41.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS4y">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
<p   
>接下来我们就要使用这个扩展库去遍历获取物理网卡的相关信息，首先我们需要包含头文件和库文件：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;WINSOCK2.H&gt;</code></div>
<div class="line"><code class="plain">#include &lt;pcap.h&gt;</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"ws2_32.lib"</code><code class="plain">)</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"wpcap.lib"</code><code class="plain">)</code></div>
</div>
    </div>
<p   
>接着我们需要通过封装好的函数pcap_findalldevs去获取物理网卡信息，其语法如下（参考官方手册：<a  class="external-link" href="https://www.winpcap.org/docs/docs_412/html/">https://www.winpcap.org/docs/docs_412/html/</a>）：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> pcap_findalldevs (</code></div>
<div class="line"><code class="plain">    pcap_if_t ** alldevsp, </code><code class="comments">// 输出参数，这是一个二级指针，它实际上是一个链表</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> * errbuf </code><code class="comments">// 输出参数，执行失败的错误信息存放的缓冲区</code></div>
<div class="line"><code class="plain">); </code><code class="comments">// 执行成功返回0，失败返回-1</code></div>
</div>
    </div>
<p   
>如下图所示就是这个结构体，我们可以看出，实际上他是有俩个成员都是链表，一个是每个网卡对应的next成员指针，一个是每个网卡对应的addresses成员指针的next成员：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_17-24-29.png" alt="images/download/attachments/17301746/image2021-8-10_17-24-29.png" width="600"  />
    </p>
<p   
>那么我们可以根据这个结构去获取网卡的信息：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    pcap_if_t* alldevsp = NULL;</code></div>
<div class="line"><code class="plain">    pcap_if_t* tmpdevsp = NULL;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> errbuf[PCAP_ERRBUF_SIZE] = {</code><code class="value">0</code><code class="plain">}; </code><code class="comments">// 错误信息</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> iRet = pcap_findalldevs(&amp;alldevsp, errbuf); </code><code class="comments">// 获取返回值</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (iRet == </code><code class="value">0</code><code class="plain">) { </code><code class="comments">// 判断是否为0</code></div>
<div class="line"><code class="plain">        tmpdevsp = alldevsp;</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 遍历网卡</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Name: %s\nDesc: %s\n"</code><code class="plain">, tmpdevsp-&gt;name, tmpdevsp-&gt;description);</code></div>
<div class="line"><code class="plain">            pcap_addr* tmpaddr = tmpdevsp-&gt;addresses;</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 遍历地址</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">do</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">                sockaddr_in* ipaddr = (sockaddr_in*)tmpaddr-&gt;addr;</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"IP: %s\n"</code><code class="plain">, inet_ntoa(ipaddr-&gt;sin_addr));</code></div>
<div class="line"><code class="plain">            } </code><code class="keyword">while</code><code class="plain"> (tmpaddr = tmpaddr-&gt;next);</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"===================================\n\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">while</code><code class="plain"> (tmpdevsp = tmpdevsp-&gt;next);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">else</code><code class="plain"> {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_findalldevs error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    pcap_freealldevs(alldevsp); </code><code class="comments">// 释放资源</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWOn-Wni-aVsOaNruWMheeahOiOt-WPluS4juaJk-WNsA">
        <h1 class="heading "><span>&#21407;&#22987;&#25968;&#25454;&#21253;&#30340;&#33719;&#21462;&#19982;&#25171;&#21360;</span></h1>
<p   
>原始数据包就是适配器（物理网卡、虚拟网卡都可以称为适配器）接收到，没有经过任何处理的包。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeiOt-WPlumAgumFjeWZqOS4iueahOaVsOaNruWMhQ">
        <h2 class="heading "><span>&#33719;&#21462;&#36866;&#37197;&#22120;&#19978;&#30340;&#25968;&#25454;&#21253;</span></h2>
<p   
>获取适配器上的数据包， 一共有如下几个步骤：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="value">1</code><code class="plain">. 遍历适配器，找到需要捕获的适配器(pcap_findalldevs函数)</code></div>
<div class="line"><code class="value">2</code><code class="plain">. 打开指定的适配器(pcap_open函数)</code></div>
<div class="line"><code class="value">3</code><code class="plain">. 关闭适配器，释放资源(pcap_freealldevs函数)</code></div>
<div class="line"><code class="value">4</code><code class="plain">. 设置回调函数开始捕获数据包(pcap_loop函数)</code></div>
<div class="line"><code class="value">5</code><code class="plain">. 编写回调函数进行数据的接收与处理</code></div>
</div>
    </div>
<p   
>pcap_open函数语法：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">pcap_t* pcap_open(</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">const</code><code class="plain"> </code><code class="keyword">char</code><code class="plain"> *source, </code><code class="comments">// 要打开的适配器名字</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> snaplen, </code><code class="comments">// 捕获包的长度（TCP包的最大长度是1460字节，UDP包则是65535字节）</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> flags, </code><code class="comments">// 这里就是设置你的适配器模式，我们需要抓包的话就要设置成混合模式，写1或者true都可以</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> read_timeout, </code><code class="comments">// 读取超时时间，这里可以直接写NULL，不管它</code></div>
<div class="line"><code class="plain">    struct pcap_rmtauth *auth, </code><code class="comments">// 认证，pcap_open</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> *errbuf </code><code class="comments">// 错误信息</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>pcap_loop函数语法：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain">    pcap_loop(</code></div>
<div class="line"><code class="plain">    pcap_t *, </code><code class="comments">// pcap_open返回的指针</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain">, </code><code class="comments">// 填0</code></div>
<div class="line"><code class="plain">    pcap_handler, </code><code class="comments">// 回调函数</code></div>
<div class="line"><code class="plain">    u_char * </code><code class="comments">// 填NULL</code></div>
<div class="line"><code class="plain">);</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> pcap_loop (</code></div>
<div class="line"><code class="plain">    pcap_t * p, </code><code class="comments">// pcap_open返回的指针</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> cnt, </code><code class="comments">// 填0</code></div>
<div class="line"><code class="plain">    pcap_handler callback, </code><code class="comments">// 回调函数</code></div>
<div class="line"><code class="plain">    u_char * user </code><code class="comments">// 用户自定义内容</code></div>
<div class="line"><code class="plain">);     </code></div>
</div>
    </div>
<p   
>回调函数原型：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">typedef </code><code class="keyword">void</code><code class="plain">(* pcap_handler)(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data)</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> pcap_handler(</code></div>
<div class="line"><code class="plain">    u_char *user, </code><code class="comments">// 用户定义的参数，包含了捕获会话的状态，它对应于 pcap_dispatch 和 pcap_loop 函数的user参数</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="comments">// 结构体指针，捕获驱动与数据包相关联的头（不是协议头）</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data </code><code class="comments">// 指针，指向数据包的数据，包括协议头。</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
<p   
>这里面有一个结构体，我们需要要看一下它的成员分别是什么：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct pcap_pkthdr {</code></div>
<div class="line"><code class="plain">    struct timeval ts;    </code><code class="comments">// 数据包捕获的时间戳</code></div>
<div class="line"><code class="plain">    bpf_u_int32 caplen;    </code><code class="comments">// 捕获到包的长度</code></div>
<div class="line"><code class="plain">    bpf_u_int32 len;    </code><code class="comments">// 这个包的长度</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>第一个成员是一个结构体timeval，自行了解，这里不再赘述，第二与第三个成员，理论应该是一样的大小，但有可能捕获到数据包的长度与实际的长度有出入（数据丢失）。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLemAgumFjeWZqOeahOa3t-WQiOaooeW8jw">
        <h2 class="heading "><span>&#36866;&#37197;&#22120;&#30340;&#28151;&#21512;&#27169;&#24335;</span></h2>
<p   
>通常，适配器(物理网卡)有多种工作模式，设置为混合模式之后，可以接收所有流经当前网卡的数据包，即使不是发给自己的。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS4z">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
<p   
>在实际编写代码之前，我们是要在包含pcap.h头文件之前定一个宏：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define HAVE_REMOTE</code></div>
<div class="line"><code class="plain">#include &lt;WINSOCK2.H&gt;</code></div>
<div class="line"><code class="plain">#include &lt;pcap.h&gt;</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"ws2_32.lib"</code><code class="plain">)</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"wpcap.lib"</code><code class="plain">)</code></div>
</div>
    </div>
<p   
>这是因为我们即将要使用到pcap_open这个函数，只有定义了这个宏，才能包含定义了这个函数的头文件，这个我们可以从pcap.h头文件中看到：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_20-25-8.png" alt="images/download/attachments/17301746/image2021-8-10_20-25-8.png" width="600"  />
    </p>
<p   
>接着，我们就按照顺序逐步去编写代码即可：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data);</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    pcap_if_t* alldevsp = NULL;</code></div>
<div class="line"><code class="plain">    pcap_if_t* tmpdevsp = NULL;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> errbuf[PCAP_ERRBUF_SIZE] = {</code><code class="value">0</code><code class="plain">}; </code><code class="comments">// 错误信息</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 遍历适配器</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> iRet = pcap_findalldevs(&amp;alldevsp, errbuf); </code><code class="comments">// 获取返回值</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (iRet != </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_findalldevs error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    tmpdevsp = alldevsp;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> </code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Name: %s \nDesc: %s \n================\n\n"</code><code class="plain">, tmpdevsp-&gt;name, tmpdevsp-&gt;description);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (tmpdevsp = tmpdevsp-&gt;next);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 打开指定的适配器</code></div>
<div class="line"><code class="plain">    pcap_t* pcap = pcap_open(</code><code class="string">"\\Device\\NPF_{C7C05FAA-6043-4EB3-9059-329655AC6FB0}"</code><code class="plain">, </code><code class="value">65535</code><code class="plain">, </code><code class="value">1</code><code class="plain">, NULL, NULL, errbuf);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!pcap) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_open error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 关闭适配器</code></div>
<div class="line"><code class="plain">    pcap_freealldevs(alldevsp);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 捕获数据包</code></div>
<div class="line"><code class="plain">    pcap_loop(pcap, </code><code class="value">0</code><code class="plain">, Mypcap_handler, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 编写回调函数</code></div>
<div class="line"><code class="plain">    struct tm *ltime;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> timestr[</code><code class="value">16</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    time_t local_tv_sec;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 将时间戳转换成可识别的格式</code></div>
<div class="line"><code class="plain">    local_tv_sec = pkt_header-&gt;ts.tv_sec;</code></div>
<div class="line"><code class="plain">    ltime = localtime(&amp;local_tv_sec);</code></div>
<div class="line"><code class="plain">    strftime(timestr, sizeof timestr, </code><code class="string">"%H:%M:%S"</code><code class="plain">, ltime);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Time: %s, Caplen: %d, Len: %d \n"</code><code class="plain">, timestr, pkt_header-&gt;caplen, pkt_header-&gt;len);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 根据分析，我们发现数据包的前六个字节为目地的MAC地址，第七个字节到第12个字节则为源的MAC地址，所以在这里输出</code></div>
<div class="line"><code class="plain">    u_char dstMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        dstMac[i] = *(pkt_data+i+</code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Dst Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, dstMac[</code><code class="value">0</code><code class="plain">], dstMac[</code><code class="value">1</code><code class="plain">], dstMac[</code><code class="value">2</code><code class="plain">], dstMac[</code><code class="value">3</code><code class="plain">], dstMac[</code><code class="value">4</code><code class="plain">], dstMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    u_char srcMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        srcMac[i] = *(pkt_data+i+</code><code class="value">6</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Src Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, srcMac[</code><code class="value">0</code><code class="plain">], srcMac[</code><code class="value">1</code><code class="plain">], srcMac[</code><code class="value">2</code><code class="plain">], srcMac[</code><code class="value">3</code><code class="plain">], srcMac[</code><code class="value">4</code><code class="plain">], srcMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// pkt_data 给的是存储数据的内存首地址，我们根据实际捕获的长度去遍历即可获取完整数据</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"\nData:\n------------------------\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; pkt_header-&gt;caplen; i++) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"%x"</code><code class="plain">, pkt_data[i]);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"\n------------------------\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-10_21-50-3.png" alt="images/download/attachments/17301746/image2021-8-10_21-50-3.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLU1BQ-W4p-e7k-aehOS4jk1BQ-WMheeahOino-aekA">
        <h1 class="heading "><span>MAC&#24103;&#32467;&#26500;&#19982;MAC&#21253;&#30340;&#35299;&#26512;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLU1BQ-W4p-e7k-aehA">
        <h2 class="heading "><span>MAC&#24103;&#32467;&#26500;</span></h2>
<p   
>在上一章中，我们用代码分别输出了原始数据包中的目标主机的MAC地址和源主机的MAC地址，这分别占6字节，还有2字节表示类型，加起来就是14字节，我们称之为MAC帧结构：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_11-1-23.png" alt="images/download/attachments/17301746/image2021-8-11_11-1-23.png" width="400"  />
    </p>
<p   
>MAC层是数据链路层的两个子层之一，如上图中的这2个字节则表示当前数据包属于哪一种网络层协议的类型（例如：IP、ARP）。</p>
<p   
>我们可以通过获取适配器上的原始数据包，在最开始的位置找到MAC帧结构，这是因为我们可以直接从网络模型看出网络协议的层级，这种数据包应该是按照层级一层一层的追加的，所以MAC帧结构应该在最开始的位置。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVdpcmVzaGFya-aKk-WMheino-aekA">
        <h2 class="heading "><span>Wireshark&#25235;&#21253;&#35299;&#26512;</span></h2>
<p   
>我们可以通过Wireshark去抓包，随便选择一个包展开就可以看到这样的一个结构：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_11-9-57.png" alt="images/download/attachments/17301746/image2021-8-11_11-9-57.png" width="600"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLUlQ5bin57uT5p6E5LiOSVDljIXnmoTop6PmnpA">
        <h1 class="heading "><span>IP&#24103;&#32467;&#26500;&#19982;IP&#21253;&#30340;&#35299;&#26512;</span></h1>
<p   
>接下来我们需要定位IP帧结构， 而我们想定位这个结构的话，按照网络协议的层级应该先从MAC帧说起：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_11-40-26.png" alt="images/download/attachments/17301746/image2021-8-11_11-40-26.png" width="400"  />
    </p>
<p   
>如上图所示，我们的IP帧就在其他数据中，我们根据MAC帧的最后2字节推断出其他数据中的帧对应什么帧。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLUlQ5bin57uT5p6E">
        <h2 class="heading "><span>IP&#24103;&#32467;&#26500;</span></h2>
<p   
>如下图就是IP帧结构，图中多次出现的位，表示的是BIT位：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_12-31-23.png" alt="images/download/attachments/17301746/image2021-8-11_12-31-23.png" width="400"  />
    </p>
<p   
>其分别表示如下：</p>
<ol class=" "><li class=" "><p   
><strong class=" ">版本</strong>：版本占了4位，用来表示该协议采用的是那一个版本的IP，相同版本的IP才能进行通信，一般此处的值为4，表示IPv4；</p>
</li><li class=" "><p   
><strong class=" ">首部头长度</strong>：该字段用四位表示，表示整个IP报文的头的长度，这里的长度表示有多少个单位，1个单位是4字节，如长度为1则表示该IP报文的头大小为4字节；它得范围即二进制数0000-1111（十进制数0-15），其中一个最小长度为0字节，最大长度为60字节，一般来说此处的值为0101，表示头长度为20字节；</p>
</li><li class=" "><p   
><strong class=" ">服务类型（TOS）</strong>：该字段用8位表示，该字段一般情况下不使用；</p>
</li><li class=" "><p   
><strong class=" ">总长度字节数</strong>：该字段表示整个IP报文的长度，这里的长度也表示有多少个单位，1个单位是1字节，能表示的最大字节为2^16-1=65535字节，不过由于链路层的MTU限制，超过1480字节后就会被分段（以太帧MTU为1500的情况下，除去20字节的包头）；</p>
</li><li class=" "><p   
><strong class=" ">标识</strong>：该字段是IP软件实现的时候自动产生的，该字段的目的不是为了接受方的按序接受而设置的，而是在IP分段以后，用来标识同一段分段的，方便IP分段的重组；</p>
</li><li class=" "><p   
><strong class=" ">标志</strong>：该字段是与IP分段有关的，其中有三位，但只有两位是有效的，分别为MF、DF、MF；MF表示后面是否还有分段，为1时，表示后面还有分段；DF表示是否能分段，为0表示可以分段；</p>
</li><li class=" "><p   
><strong class=" ">段偏移</strong>：该字段是与IP分段后，相应的IP段在总的IP段的位置；</p>
</li><li class=" "><p   
><strong class=" ">生存时间（TTL）</strong>：该字段表示生存周期，该值占8位，IP分段每经过一个路由器该值减一，它的出现是为了防止路由环路，浪费带宽的问题，Window系统默认为128；</p>
</li><li class=" "><p   
><strong class=" ">协议</strong>：该值表示上层的协议，占8位，其中1表示ICMP、2表示IGMP、6表示TCP、17表示UDP、89表示OSPF；</p>
</li><li class=" "><p   
><strong class=" ">首部校验和</strong>：该值是对整个数据包的包头进行的校验，占16位；</p>
</li><li class=" "><p   
><strong class=" ">源地址和目的地址</strong>：表示发送IP段的源和目的IP，分别占32位；</p>
</li><li class=" "><p   
><strong class=" ">可选的部分</strong>：一些特殊的要求会加在这个部分，一般情况下是不会有这个字段的；</p>
</li><li class=" "><p   
>数据。</p>
</li></ol><p   
>大概了解一下即可，我们主要关注几个重要字段：</p>
<ol class=" "><li class=" "><p   
>版本</p>
</li><li class=" "><p   
>首部长度</p>
</li><li class=" "><p   
>总长度</p>
</li><li class=" "><p   
>协议</p>
</li><li class=" "><p   
>源IP</p>
</li><li class=" "><p   
>目的IP</p>
</li></ol><p   
><strong class=" ">注意</strong>：网络传输的字节序和你主机本身的字节序是不一样的，所以在转换的时候需要注意一下。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVdpcmVzaGFya-aKk-WMheino-aekC4x">
        <h2 class="heading "><span>Wireshark&#25235;&#21253;&#35299;&#26512;</span></h2>
<p   
>我们可以通过Wireshark去抓包，随便选择一个包展开就可以看到这样的一个结构 ：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_13-26-17.png" alt="images/download/attachments/17301746/image2021-8-11_13-26-17.png" width="600"  />
    </p>
<p   
>同样，我们可以根据对应的位，编写程序去解析。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS40">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
<p   
>实际编写代码如下，在编写代码的过程中不要忘记偏移量+14再获取IP报文的信息：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data);</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    pcap_if_t* alldevsp = NULL;</code></div>
<div class="line"><code class="plain">    pcap_if_t* tmpdevsp = NULL;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> errbuf[PCAP_ERRBUF_SIZE] = {</code><code class="value">0</code><code class="plain">}; </code><code class="comments">// 错误信息</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 遍历适配器</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> iRet = pcap_findalldevs(&amp;alldevsp, errbuf); </code><code class="comments">// 获取返回值</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (iRet != </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_findalldevs error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    tmpdevsp = alldevsp;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> </code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Name: %s \nDesc: %s \n================\n\n"</code><code class="plain">, tmpdevsp-&gt;name, tmpdevsp-&gt;description);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (tmpdevsp = tmpdevsp-&gt;next);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 打开指定的适配器</code></div>
<div class="line"><code class="plain">    pcap_t* pcap = pcap_open(</code><code class="string">"\\Device\\NPF_{C7C05FAA-6043-4EB3-9059-329655AC6FB0}"</code><code class="plain">, </code><code class="value">65535</code><code class="plain">, </code><code class="value">1</code><code class="plain">, NULL, NULL, errbuf);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!pcap) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_open error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 关闭适配器</code></div>
<div class="line"><code class="plain">    pcap_freealldevs(alldevsp);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 捕获数据包</code></div>
<div class="line"><code class="plain">    pcap_loop(pcap, </code><code class="value">0</code><code class="plain">, Mypcap_handler, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">char</code><code class="plain">* MyStrCpy(</code><code class="keyword">char</code><code class="plain">* oStr, </code><code class="keyword">int</code><code class="plain"> index, </code><code class="keyword">int</code><code class="plain"> number) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain">* tmpStr = oStr;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain">* resStr = (</code><code class="keyword">char</code><code class="plain">*)malloc(number);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; number; i++) {</code></div>
<div class="line"><code class="plain">        *(resStr+i) = *(tmpStr+(index+i));</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> resStr;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 编写回调函数</code></div>
<div class="line"><code class="plain">    struct tm *ltime;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> timestr[</code><code class="value">16</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    time_t local_tv_sec;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 将时间戳转换成可识别的格式</code></div>
<div class="line"><code class="plain">    local_tv_sec = pkt_header-&gt;ts.tv_sec;</code></div>
<div class="line"><code class="plain">    ltime = localtime(&amp;local_tv_sec);</code></div>
<div class="line"><code class="plain">    strftime(timestr, sizeof timestr, </code><code class="string">"%H:%M:%S"</code><code class="plain">, ltime);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Time: %s, Caplen: %d, Len: %d \n"</code><code class="plain">, timestr, pkt_header-&gt;caplen, pkt_header-&gt;len);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"================MAC================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    u_char dstMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        dstMac[i] = *(pkt_data+i+</code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Dst Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, dstMac[</code><code class="value">0</code><code class="plain">], dstMac[</code><code class="value">1</code><code class="plain">], dstMac[</code><code class="value">2</code><code class="plain">], dstMac[</code><code class="value">3</code><code class="plain">], dstMac[</code><code class="value">4</code><code class="plain">], dstMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    u_char srcMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        srcMac[i] = *(pkt_data+i+</code><code class="value">6</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Src Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, srcMac[</code><code class="value">0</code><code class="plain">], srcMac[</code><code class="value">1</code><code class="plain">], srcMac[</code><code class="value">2</code><code class="plain">], srcMac[</code><code class="value">3</code><code class="plain">], srcMac[</code><code class="value">4</code><code class="plain">], srcMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    u_char type[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">2</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        type[i] = *(pkt_data+i+</code><code class="value">12</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Type: "</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">0</code><code class="plain">] == </code><code class="value">0x08</code><code class="plain">) {    </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">1</code><code class="plain">] == </code><code class="value">0x00</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"IPv4\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"\n================IP================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            u_char versionAndHeaderLen = *(pkt_data+</code><code class="value">14</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            u_char version = versionAndHeaderLen &gt;&gt; </code><code class="value">4</code><code class="plain">; </code><code class="comments">// 版本</code></div>
<div class="line"><code class="plain">            u_char headerLen = versionAndHeaderLen &lt;&lt; </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            headerLen = headerLen &gt;&gt; </code><code class="value">4</code><code class="plain">; </code><code class="comments">// 首部长度</code></div>
<div class="line"><code class="plain">            u_char realHeaderLen = headerLen * </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain"> (version == </code><code class="value">0x04</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Version: IPv4 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"HeaderLen: %d(%d Byte) \n"</code><code class="plain">, headerLen, realHeaderLen);</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            u_char allLen[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">2</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                allLen[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 手动字节序的转换</code></div>
<div class="line"><code class="plain">            u_short resLen = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            u_char* tmpLen = (u_char*)&amp;resLen;</code></div>
<div class="line"><code class="plain">            tmpLen[</code><code class="value">0</code><code class="plain">] = allLen[</code><code class="value">1</code><code class="plain">];</code></div>
<div class="line"><code class="plain">            tmpLen[</code><code class="value">1</code><code class="plain">] = allLen[</code><code class="value">0</code><code class="plain">];</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// 基于函数转换</code></div>
<div class="line"><code class="plain">            </code><code class="comments">// u_short resLen = ntohs(*((u_short*)allLen));</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"AllLen: %d Byte \n"</code><code class="plain">, resLen);</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            u_char protocol = *(pkt_data+</code><code class="value">14</code><code class="plain">+</code><code class="value">9</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">switch</code><code class="plain"> (protocol) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">1</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: ICMP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">2</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: IGMP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">6</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: TCP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">17</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: UDP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">89</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: OSPF \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            u_char srcIP[</code><code class="value">4</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">4</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                srcIP[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">12</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Src IP: %d.%d.%d.%d\n"</code><code class="plain">, srcIP[</code><code class="value">0</code><code class="plain">], srcIP[</code><code class="value">1</code><code class="plain">], srcIP[</code><code class="value">2</code><code class="plain">], srcIP[</code><code class="value">3</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">            u_char dstIP[</code><code class="value">4</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">4</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                dstIP[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">16</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Dst IP: %d.%d.%d.%d \n"</code><code class="plain">, dstIP[</code><code class="value">0</code><code class="plain">], dstIP[</code><code class="value">1</code><code class="plain">], dstIP[</code><code class="value">2</code><code class="plain">], dstIP[</code><code class="value">3</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"\n================IP================\n\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">1</code><code class="plain">] == </code><code class="value">0x06</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"ARP\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_18-53-13.png" alt="images/download/attachments/17301746/image2021-8-11_18-53-13.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOW4p-e7k-aehOS4jlRDUOWMheeahOino-aekA">
        <h1 class="heading "><span>TCP&#24103;&#32467;&#26500;&#19982;TCP&#21253;&#30340;&#35299;&#26512;</span></h1>
<p   
>我们去了解IP包的时候，是从MAC包出发的，那么同样我们了解TCP包也需要去从IP包出发，首先我们知道整个整个IP包包含的数据中就有TCP/UDP包，想知道这个数据是属于什么协议，就要通过IP帧结构的协议字段，想要知道TCP/UDP包数据的大小，就要通过总长度减去首部长度获取。</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_18-25-22.png" alt="images/download/attachments/17301746/image2021-8-11_18-25-22.png" width="400"  />
    </p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVRDUOW4p-e7k-aehA">
        <h2 class="heading "><span>TCP&#24103;&#32467;&#26500;</span></h2>
<p   
>TCP帧结构如下图所示：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_18-57-46.png" alt="images/download/attachments/17301746/image2021-8-11_18-57-46.png" width="400"  />
    </p>
<p   
>这里出现了很多，我们没有见过的词，我们来了解一下几个常用的：</p>
<ol class=" "><li class=" "><p   
>源端口：发送方应用程序对应的端口；</p>
</li><li class=" "><p   
>目的端口：接收方应用程序对应的端口；</p>
</li><li class=" "><p   
>序列号： 这个我们已经在之前了解过了，就是我们所说的seq；</p>
</li><li class=" "><p   
>确认号： 这个我们也了解过了，就是我们所说的ack；</p>
</li><li class=" "><p   
>偏移：这个就类似于我们IP帧结构中的首部长度，1个单位4字节；</p>
</li><li class=" "><p   
>窗口：接收窗口的大小，表示接收端希望接受的字节数。</p>
</li></ol><p   
>对抓包来说比较重要的字段如下：</p>
<ol class=" "><li class=" "><p   
>源端口</p>
</li><li class=" "><p   
>目的端口</p>
</li><li class=" "><p   
>偏移</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVdpcmVzaGFya-aKk-WMheWIhuaekA">
        <h2 class="heading "><span>Wireshark&#25235;&#21253;&#20998;&#26512;</span></h2>
<p   
>我们可以通过Wireshark去抓包，随便选择一个包展开就可以看到这样的一个结构 ：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_20-55-34.png" alt="images/download/attachments/17301746/image2021-8-11_20-55-34.png" width="600"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS41">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> main(</code><code class="keyword">int</code><code class="plain"> argc, </code><code class="keyword">char</code><code class="plain">* argv[])</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    pcap_if_t* alldevsp = NULL;</code></div>
<div class="line"><code class="plain">    pcap_if_t* tmpdevsp = NULL;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> errbuf[PCAP_ERRBUF_SIZE] = {</code><code class="value">0</code><code class="plain">}; </code><code class="comments">// 错误信息</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 1. 遍历适配器</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> iRet = pcap_findalldevs(&amp;alldevsp, errbuf); </code><code class="comments">// 获取返回值</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (iRet != </code><code class="value">0</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_findalldevs error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    tmpdevsp = alldevsp;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">do</code><code class="plain"> </code></div>
<div class="line"><code class="plain">    {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Name: %s \nDesc: %s \n================\n\n"</code><code class="plain">, tmpdevsp-&gt;name, tmpdevsp-&gt;description);</code></div>
<div class="line"><code class="plain">    } </code><code class="keyword">while</code><code class="plain"> (tmpdevsp = tmpdevsp-&gt;next);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 2. 打开指定的适配器</code></div>
<div class="line"><code class="plain">    pcap_t* pcap = pcap_open(</code><code class="string">"\\Device\\NPF_{C7C05FAA-6043-4EB3-9059-329655AC6FB0}"</code><code class="plain">, </code><code class="value">65535</code><code class="plain">, </code><code class="value">1</code><code class="plain">, NULL, NULL, errbuf);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (!pcap) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"pcap_open error: %s \n"</code><code class="plain">, errbuf);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 3. 关闭适配器</code></div>
<div class="line"><code class="plain">    pcap_freealldevs(alldevsp);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 4. 捕获数据包</code></div>
<div class="line"><code class="plain">    pcap_loop(pcap, </code><code class="value">0</code><code class="plain">, Mypcap_handler, NULL);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">char</code><code class="plain">* MyStrCpy(</code><code class="keyword">char</code><code class="plain">* oStr, </code><code class="keyword">int</code><code class="plain"> index, </code><code class="keyword">int</code><code class="plain"> number) {</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain">* tmpStr = oStr;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain">* resStr = (</code><code class="keyword">char</code><code class="plain">*)malloc(number);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; number; i++) {</code></div>
<div class="line"><code class="plain">        *(resStr+i) = *(tmpStr+(index+i));</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">return</code><code class="plain"> resStr;</code></div>
<div class="line"><code class="plain">}</code></div>
<div class="line"> </div>
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 编写回调函数</code></div>
<div class="line"><code class="plain">    struct tm *ltime;</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">char</code><code class="plain"> timestr[</code><code class="value">16</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    time_t local_tv_sec;</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 将时间戳转换成可识别的格式</code></div>
<div class="line"><code class="plain">    local_tv_sec = pkt_header-&gt;ts.tv_sec;</code></div>
<div class="line"><code class="plain">    ltime = localtime(&amp;local_tv_sec);</code></div>
<div class="line"><code class="plain">    strftime(timestr, sizeof timestr, </code><code class="string">"%H:%M:%S"</code><code class="plain">, ltime);</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Time: %s, Caplen: %d, Len: %d \n"</code><code class="plain">, timestr, pkt_header-&gt;caplen, pkt_header-&gt;len);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"================MAC================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    u_char dstMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(</code><code class="keyword">int</code><code class="plain"> i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        dstMac[i] = *(pkt_data+i+</code><code class="value">0</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Dst Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, dstMac[</code><code class="value">0</code><code class="plain">], dstMac[</code><code class="value">1</code><code class="plain">], dstMac[</code><code class="value">2</code><code class="plain">], dstMac[</code><code class="value">3</code><code class="plain">], dstMac[</code><code class="value">4</code><code class="plain">], dstMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    u_char srcMac[</code><code class="value">6</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">6</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        srcMac[i] = *(pkt_data+i+</code><code class="value">6</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Src Mac: %02x:%02x:%02x:%02x:%02x:%02x \n"</code><code class="plain">, srcMac[</code><code class="value">0</code><code class="plain">], srcMac[</code><code class="value">1</code><code class="plain">], srcMac[</code><code class="value">2</code><code class="plain">], srcMac[</code><code class="value">3</code><code class="plain">], srcMac[</code><code class="value">4</code><code class="plain">], srcMac[</code><code class="value">5</code><code class="plain">]);</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    u_char type[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="keyword">for</code><code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">2</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">        type[i] = *(pkt_data+i+</code><code class="value">12</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"><code class="plain">    </code></div>
<div class="line"><code class="plain">    printf(</code><code class="string">"Type: "</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">0</code><code class="plain">] == </code><code class="value">0x08</code><code class="plain">) {    </code></div>
<div class="line"><code class="plain">        </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">1</code><code class="plain">] == </code><code class="value">0x00</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"IPv4\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"\n================IP================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            u_char versionAndHeaderLen = *(pkt_data+</code><code class="value">14</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            u_char version = versionAndHeaderLen &gt;&gt; </code><code class="value">4</code><code class="plain">; </code><code class="comments">// 版本</code></div>
<div class="line"><code class="plain">            u_char headerLen = versionAndHeaderLen &lt;&lt; </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            headerLen = headerLen &gt;&gt; </code><code class="value">4</code><code class="plain">; </code><code class="comments">// 首部长度</code></div>
<div class="line"><code class="plain">            u_char realHeaderLen = headerLen * </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain"> (version == </code><code class="value">0x04</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Version: IPv4 \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"HeaderLen: %d(%d Byte) \n"</code><code class="plain">, headerLen, realHeaderLen);</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            u_char allLen[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">2</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                allLen[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">2</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            u_short resLen = ntohs(*((u_short*)allLen));</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">            printf(</code><code class="string">"AllLen: %d Byte \n"</code><code class="plain">, resLen);</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            u_char protocol = *(pkt_data+</code><code class="value">14</code><code class="plain">+</code><code class="value">9</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">switch</code><code class="plain"> (protocol) {</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">1</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: ICMP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">2</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: IGMP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">6</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: TCP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">17</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: UDP \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">case</code><code class="plain"> </code><code class="value">89</code><code class="plain">:</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Protocol: OSPF \n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">break</code><code class="plain">;</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            u_char srcIP[</code><code class="value">4</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">4</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                srcIP[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">12</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Src IP: %d.%d.%d.%d\n"</code><code class="plain">, srcIP[</code><code class="value">0</code><code class="plain">], srcIP[</code><code class="value">1</code><code class="plain">], srcIP[</code><code class="value">2</code><code class="plain">], srcIP[</code><code class="value">3</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">            u_char dstIP[</code><code class="value">4</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">            </code><code class="keyword">for</code><code class="plain"> (i = </code><code class="value">0</code><code class="plain">; i &lt; </code><code class="value">4</code><code class="plain">; i++) {</code></div>
<div class="line"><code class="plain">                dstIP[i] = *(pkt_data+i+</code><code class="value">14</code><code class="plain">+</code><code class="value">16</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"Dst IP: %d.%d.%d.%d \n"</code><code class="plain">, dstIP[</code><code class="value">0</code><code class="plain">], dstIP[</code><code class="value">1</code><code class="plain">], dstIP[</code><code class="value">2</code><code class="plain">], dstIP[</code><code class="value">3</code><code class="plain">]);</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"\n================IP================\n\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            </code></div>
<div class="line"><code class="plain">            </code><code class="keyword">if</code><code class="plain"> (protocol == </code><code class="value">6</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"================TCP================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                u_char srcPort[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">for</code><code class="plain"> (</code><code class="keyword">int</code><code class="plain"> x = </code><code class="value">0</code><code class="plain">; x &lt; </code><code class="value">2</code><code class="plain">; x++) {</code></div>
<div class="line"><code class="plain">                    srcPort[x] = *(pkt_data+</code><code class="value">14</code><code class="plain">+realHeaderLen+x);</code></div>
<div class="line"><code class="plain">                }</code></div>
<div class="line"><code class="plain">                u_short resSrcPort = ntohs(*(u_short*)srcPort);</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Src Port: %d \n"</code><code class="plain">, resSrcPort);</code></div>
<div class="line"><code class="plain">                u_char dstPort[</code><code class="value">2</code><code class="plain">] = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">                </code><code class="keyword">for</code><code class="plain"> (x = </code><code class="value">0</code><code class="plain">; x &lt; </code><code class="value">2</code><code class="plain">; x++) {</code></div>
<div class="line"><code class="plain">                    dstPort[x] = *(pkt_data+</code><code class="value">14</code><code class="plain">+realHeaderLen+x);</code></div>
<div class="line"><code class="plain">                }</code></div>
<div class="line"><code class="plain">                u_short resDstPort = ntohs(*(u_short*)dstPort);</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Dst Port: %d \n"</code><code class="plain">, resDstPort);</code></div>
<div class="line"><code class="plain">                u_char offsetAndReserved = *(pkt_data+</code><code class="value">14</code><code class="plain">+realHeaderLen+</code><code class="value">12</code><code class="plain">);</code></div>
<div class="line"><code class="plain">                u_char offset = offsetAndReserved &gt;&gt; </code><code class="value">4</code><code class="plain">;</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"Offset: %d\n"</code><code class="plain">, offset);</code></div>
<div class="line"><code class="plain">                printf(</code><code class="string">"================TCP================\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">            }</code></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><code class="plain">        } </code><code class="keyword">else</code><code class="plain"> </code><code class="keyword">if</code><code class="plain"> (type[</code><code class="value">1</code><code class="plain">] == </code><code class="value">0x06</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">            printf(</code><code class="string">"ARP\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        }</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_22-7-47.png" alt="images/download/attachments/17301746/image2021-8-11_22-7-47.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeaooeS7vzM2MC9RUeeuoeWutuiOt-WPlue9kemAnw">
        <h1 class="heading "><span>&#27169;&#20223;360/QQ&#31649;&#23478;&#33719;&#21462;&#32593;&#36895;</span></h1>
<p   
>我们都用过360或者QQ管家，它一般会有个悬浮的窗口，然后实时的显示当前的上下行网速，我们就通过学习的知识来实现这个功能。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLee9kemAn-eahOWumuS5iQ">
        <h2 class="heading "><span>&#32593;&#36895;&#30340;&#23450;&#20041;</span></h2>
<p   
>一段时间内下载数据的大小除以持续时长就是网速：speed = len / time</p>
<p   
>那么如上公式中的下载数据的大小和持续时长如何获取呢？那就是通过之前所学习的回调函数的pcap_pkthdr结构体来获取。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS42">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> Mypcap_handler(u_char *user, </code><code class="keyword">const</code><code class="plain"> struct pcap_pkthdr *pkt_header, </code><code class="keyword">const</code><code class="plain"> u_char *pkt_data) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 5. 编写回调函数</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 初始化开始时间和结束时间</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 这里使用static关键词是为了避免重复初始化</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> timeval tBegin, tEnd = {</code><code class="value">0</code><code class="plain">};</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 初始化数据长度</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">static</code><code class="plain"> DWORD dataLen = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 结束时间为抓包时间</code></div>
<div class="line"><code class="plain">    tEnd = pkt_header-&gt;ts;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 数据长度递增</code></div>
<div class="line"><code class="plain">    dataLen += pkt_header-&gt;caplen;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 计算得出开始时间减去结束时间</code></div>
<div class="line"><code class="plain">    DWORD fTime = tEnd.tv_sec - tBegin.tv_sec + (tEnd.tv_usec - tBegin.tv_usec) / </code><code class="value">1000000</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 当时间大于1秒时，计算网速</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (fTime &gt; </code><code class="value">1</code><code class="plain">){</code></div>
<div class="line"><code class="plain">        </code><code class="keyword">float</code><code class="plain"> speed = dataLen / fTime;</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"Speed: %f K/S \n"</code><code class="plain">, speed/</code><code class="value">1024</code><code class="plain">);</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 将开始时间移到结束时间，提供下一次计算</code></div>
<div class="line"><code class="plain">        tBegin = tEnd;</code></div>
<div class="line"><code class="plain">        </code><code class="comments">// 初始化数据</code></div>
<div class="line"><code class="plain">        dataLen = </code><code class="value">0</code><code class="plain">;</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_22-43-16.png" alt="images/download/attachments/17301746/image2021-8-11_22-43-16.png" width="400"  />
    </p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeWKoOWvhueahOWfuuacrOWOn-eQhg">
        <h1 class="heading "><span>RSA&#21152;&#23494;&#30340;&#22522;&#26412;&#21407;&#29702;</span></h1>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeS4uuS7gOS5iOmcgOimgeWKoOWvhg">
        <h2 class="heading "><span>&#20026;&#20160;&#20040;&#38656;&#35201;&#21152;&#23494;</span></h2>
<p   
>网络上传输的数据很容易被抓包，如果不加密，网络数据就很容易窃取，诸如用户名、密码这些敏感的信息一旦丢失，将会造成巨大的损失。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeW4uOeUqOeahOWKoOWvhuaWueW8jw">
        <h2 class="heading "><span>&#24120;&#29992;&#30340;&#21152;&#23494;&#26041;&#24335;</span></h2>
<ol class=" "><li class=" "><p   
><strong class=" ">对称加密</strong>：加密方和解密方使用同一个密钥；<strong class=" ">优点</strong>：加密解密过程简单，高效；<strong class=" ">缺点</strong>：有一方泄密了，则整个加密就失去了意义。</p>
</li><li class=" "><p   
><strong class=" ">非对称加密</strong>：加密方和解密方使用不同的密钥；<strong class=" ">优点</strong>：解密的秘钥无法用加密的密钥来解密，即使加密方暴露出了密钥也没事，因为这个密钥只能加密，而无法解密，所以就提高了安全性；<strong class=" ">缺点</strong>：效率比较低下，过程比较繁琐。</p>
</li></ol><p   
><strong class=" ">RSA</strong>就属于非对称加密，也就是我们本章节所学的。</p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLei-heWKqeamguW_tQ">
        <h2 class="heading "><span>&#36741;&#21161;&#27010;&#24565;</span></h2>
<ol class=" "><li class=" "><p   
><strong class=" ">质数</strong>：是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
</li><li class=" "><p   
><strong class=" ">互为质数</strong>：一般指互质数，互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeWKoOWvhuWvhumSpeeahOiOt-WPlg">
        <h2 class="heading "><span>RSA&#21152;&#23494;&#23494;&#38053;&#30340;&#33719;&#21462;</span></h2>
<p   
>RSA加密密钥获取步骤如下所示：</p>
<ol class=" "><li class=" "><p   
>随机选取两个数p、q（满足互质数条件）；</p>
</li><li class=" "><p   
>按照公式获取公开模数：<u class=" "><strong class=" ">n = p * q</strong></u>，它的二进制位就是密钥长度；</p>
</li><li class=" "><p   
>按照公式获取：<u class=" "><strong class=" ">g = f(p,q) = (p-1)*(q-1)</strong></u>；</p>
</li><li class=" "><p   
>在1和g之间任意一个随机整数e（公开指数，满足1&lt;e&lt;g）；</p>
</li><li class=" "><p   
>由 <u class=" "><strong class=" ">e*d mod g = 1</strong></u> 关系式推导出来d（私有指数）</p>
</li><li class=" "><p   
>公开密钥 = (e, n) 用来加密</p>
</li><li class=" "><p   
>私有密钥 = (d, n) 用来解密</p>
</li></ol>    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeWKoOWvhuino-Wvhueul-azlQ">
        <h2 class="heading "><span>RSA&#21152;&#23494;&#35299;&#23494;&#31639;&#27861;</span></h2>
<p   
>设M为需要加密的明文数据，加密算法为：<u class=" "><strong class=" ">Encrypt_Message = M^e mod n</strong></u></p>
<p   
>设D为需要解密的密文数据，解密算法为：<u class=" "><strong class=" ">Decrypt_Message = D^d mod n</strong></u></p>
<p   
>过程可以借助RSA-Tool和Big Integer Calculator工具。</p>
    </div>
    </div>
    <div class="section section-1" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeW6k-eahOS9v-eUqA">
        <h1 class="heading "><span>RSA&#24211;&#30340;&#20351;&#29992;</span></h1>
<p   
>我们需要借助RSA库在代码上实现加密与解密，这个库是OPENSSL。</p>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWuieijheS4jumFjee9rg">
        <h2 class="heading "><span>&#23433;&#35013;&#19982;&#37197;&#32622;</span></h2>
<p   
>如果你去官方下载的话是下载到的源码，需要自己去编译打包，和WinPcap库一样，将对应路径填写到VC6的配置中去：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-11_23-49-59.png" alt="images/download/attachments/17301746/image2021-8-11_23-49-59.png" width="400"  />
    </p>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeW6k-S5i1JTQee7k-aehOS9k-WPikFQSQ">
        <h2 class="heading "><span>RSA&#24211;&#20043;RSA&#32467;&#26500;&#20307;&#21450;API</span></h2>
<p   
>RSA结构体如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">struct RSA</code></div>
<div class="line"><code class="plain">{</code></div>
<div class="line"><code class="plain">    BIGNUM *n;              </code><code class="comments">// public modulus</code></div>
<div class="line"><code class="plain">    BIGNUM *e;              </code><code class="comments">// public exponent</code></div>
<div class="line"><code class="plain">    BIGNUM *d;              </code><code class="comments">// private exponent</code></div>
<div class="line"><code class="plain">    BIGNUM *p;              </code><code class="comments">// secret prime factor</code></div>
<div class="line"><code class="plain">    BIGNUM *q;              </code><code class="comments">// secret prime factor</code></div>
<div class="line"><code class="plain">    BIGNUM *dmp1;           </code><code class="comments">// d mod (p-1)</code></div>
<div class="line"><code class="plain">    BIGNUM *dmq1;           </code><code class="comments">// d mod (q-1)</code></div>
<div class="line"><code class="plain">    BIGNUM *iqmp;           </code><code class="comments">// q^-1 mod p</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// ...</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>其对应的API：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 初始化一个RSA结构</code></div>
<div class="line"><code class="plain">RSA * RSA_new(</code><code class="keyword">void</code><code class="plain">);</code></div>
<div class="line"><code class="plain">  </code></div>
<div class="line"><code class="comments">// 释放一个RSA结构</code></div>
<div class="line"><code class="keyword">void</code><code class="plain"> RSA_free(RSA *rsa);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeW6k-S5i0JJR05VTeWPikFQSQ">
        <h2 class="heading "><span>RSA&#24211;&#20043;BIGNUM&#21450;API</span></h2>
<p   
>BIGNUM结构体如下：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">typedef struct bignum_st BIGNUM;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">struct bignum_st</code></div>
<div class="line"><code class="plain"> {</code></div>
<div class="line"><code class="plain">    BN_ULONG *d;               </code><code class="comments">/* Pointer to an array of 'BN_BITS2' bit  chunks. */</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> top;                   </code><code class="comments">/* Index of last used d +1. */</code></div>
<div class="line"><code class="plain">    </code><code class="comments">/* The next are internal book keeping for bn_expand. */</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> dmax;                  </code><code class="comments">/* Size of the d array. */</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> neg;                   </code><code class="comments">/* one if the number is negative */</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> flags;</code></div>
<div class="line"><code class="plain">};</code></div>
</div>
    </div>
<p   
>其对应的API：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="comments">// 新生成一个BIGNUM结构</code></div>
<div class="line"><code class="plain">BIGNUM *BN_new(</code><code class="keyword">void</code><code class="plain">);</code></div>
<div class="line"><code class="plain"> </code></div>
<div class="line"><code class="comments">// 释放一个BIGNUM结构</code></div>
<div class="line"><code class="keyword">void</code><code class="plain"> BN_free(BIGNUM *a);</code></div>
<div class="line"> </div>
<div class="line"><code class="comments">// 将16进制字符串转成大数</code></div>
<div class="line"><code class="keyword">int</code><code class="plain"> BN_hex2bn(BIGNUM **a, </code><code class="keyword">const</code><code class="plain"> </code><code class="keyword">char</code><code class="plain"> *str);</code></div>
</div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLVJTQeW6k-S5i-WKoOWvhuino-WvhuWHveaVsA">
        <h2 class="heading "><span>RSA&#24211;&#20043;&#21152;&#23494;&#35299;&#23494;&#20989;&#25968;</span></h2>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWFrOmSpeWKoOWvhuWHveaVsA">
        <h3 class="heading "><span>&#20844;&#38053;&#21152;&#23494;&#20989;&#25968;</span></h3>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> RSA_public_encrypt(</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> flen, </code><code class="comments">// 要加密信息长度</code></div>
<div class="line"><code class="plain">    unsigned </code><code class="keyword">char</code><code class="plain"> *from, </code><code class="comments">// 要加密信息</code></div>
<div class="line"><code class="plain">    unsigned </code><code class="keyword">char</code><code class="plain"> *to, </code><code class="comments">// 输出参数，加密后的信息</code></div>
<div class="line"><code class="plain">    RSA *rsa,</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> padding </code><code class="comments">// 采取的加密方案, 分为: RSA_PKCS1_PADDING、RSA_PKCS1_OAEP_PADDING、RSA_SSLV23_PADDING、RSA_NO_PADDING</code></div>
<div class="line"><code class="plain"> );</code></div>
</div>
    </div>
    </div>
    <div class="section section-3" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeengemSpeino-WvhuWHveaVsA">
        <h3 class="heading "><span>&#31169;&#38053;&#35299;&#23494;&#20989;&#25968;</span></h3>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">int</code><code class="plain"> RSA_private_decrypt(</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> flen, </code><code class="comments">// 要解密的信息长度</code></div>
<div class="line"><code class="plain">    unsigned </code><code class="keyword">char</code><code class="plain"> *from, </code><code class="comments">// 要解密的信息</code></div>
<div class="line"><code class="plain">    unsigned </code><code class="keyword">char</code><code class="plain"> *to, </code><code class="comments">// 输出参数，解密后的信息</code></div>
<div class="line"><code class="plain">    RSA *rsa,</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> padding </code><code class="comments">// 采取的解密方案，分为：RSA_PKCS1_PADDING、RSA_PKCS1_OAEP_PADDING、RSA_SSLV23_PADDING、RSA_NO_PADDING</code></div>
<div class="line"><code class="plain">);</code></div>
</div>
    </div>
    </div>
    </div>
    <div class="section section-2" id="src-17301746_safe-id-aWQt572R57uc57yW56iLLeWunumZheS7o-eggee8luWGmS43">
        <h2 class="heading "><span>&#23454;&#38469;&#20195;&#30721;&#32534;&#20889;</span></h2>
<p   
>首先我们需要包含一个头文件和两个库文件：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#include &lt;openssl/rsa.h&gt;</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"libeay32.lib"</code><code class="plain">)</code></div>
<div class="line"><code class="plain">#pragma comment(lib, </code><code class="string">"ssleay32.lib"</code><code class="plain">)</code></div>
</div>
    </div>
<p   
>然后就是定义E、D、N，这个我们根据RSA-Tool生成的填写进去即可：</p>
<p   
><img  class="confluence-embedded-image"  src="images/download/attachments/17301746/image2021-8-12_0-30-19.png" alt="images/download/attachments/17301746/image2021-8-12_0-30-19.png" width="400"  />
    </p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="plain">#define E </code><code class="string">"10001"</code></div>
<div class="line"><code class="plain">#define D </code><code class="string">"8008AA4D"</code></div>
<div class="line"><code class="plain">#define N </code><code class="string">"B83FD1C1"</code></div>
</div>
    </div>
<p   
>接着就是写自己的加密函数，解密函数同理可得：</p>
    <div  class="confbox programlisting" style="counter-reset: scroll-code-numbering 1">
                <div xmlns="http://www.w3.org/1999/xhtml" class="defaultnew syntaxhighlighter scroll-html-formatted-code" data-linenumbers="true" data-firstline="1">
<div class="line"><code class="keyword">void</code><code class="plain"> MyRSAEncrypt(</code><code class="keyword">const</code><code class="plain"> unsigned </code><code class="keyword">char</code><code class="plain">* pOrgData, </code><code class="keyword">int</code><code class="plain"> dataLen, unsigned </code><code class="keyword">char</code><code class="plain">* pEncryptBuf) {</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 初始化一个RSA结构</code></div>
<div class="line"><code class="plain">    RSA *pRsa = RSA_new();</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 初始化BIGNUM结构</code></div>
<div class="line"><code class="plain">    BIGNUM* pbn_e = BN_new();</code></div>
<div class="line"><code class="plain">    BIGNUM* pbn_n = BN_new();</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 将16进制字符串转成大数</code></div>
<div class="line"><code class="plain">    BN_hex2bn(&amp;pbn_e, E);</code></div>
<div class="line"><code class="plain">    BN_hex2bn(&amp;pbn_n, N);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// RSA结构成员赋值</code></div>
<div class="line"><code class="plain">    pRsa-&gt;e = pbn_e;</code></div>
<div class="line"><code class="plain">    pRsa-&gt;n = pbn_n;</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 公钥加密函数</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">int</code><code class="plain"> iRet = RSA_public_encrypt(dataLen, pOrgData, pEncryptBuf, pRsa, RSA_NO_PADDING);</code></div>
<div class="line"><code class="plain">    </code><code class="keyword">if</code><code class="plain"> (iRet == -</code><code class="value">1</code><code class="plain">) {</code></div>
<div class="line"><code class="plain">        printf(</code><code class="string">"RSA_public_encrypt Error!\n"</code><code class="plain">);</code></div>
<div class="line"><code class="plain">    }</code></div>
<div class="line"> </div>
<div class="line"><code class="plain">    </code><code class="comments">// 释放BIGNUM结构</code></div>
<div class="line"><code class="plain">    BN_free(pbn_e);</code></div>
<div class="line"><code class="plain">    BN_free(pbn_n);</code></div>
<div class="line"><code class="plain">    </code><code class="comments">// 释放RSA结构</code></div>
<div class="line"><code class="plain">    RSA_free(pRsa);</code></div>
<div class="line"><code class="plain">}</code></div>
</div>
    </div>
<p   
></p>
    </div>
    </div>
        </div>

    </article>


            <nav id="ht-post-nav">
                <a href="MFC.html" class="ht-post-nav-prev">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-prev" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-45.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>MFC</span>
        </a>
                <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="ht-post-nav-next">
            <svg width="22px" height="22px" viewBox="0 0 22 22" version="1.1" xmlns="http://www.w3.org/2000/svg"
                 xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                <g id="ht-icon-next" sketch:type="MSArtboardGroup">
                    <path fill="#000000" d="M16,8 L16,6 L6,6 L6,16 L8,16 L8,8 L16,8 Z" id="Rectangle-2"
                          sketch:type="MSShapeGroup"
                          transform="translate(11.000000, 11.000000) rotate(-225.000000) translate(-11.000000, -11.000000) "></path>
                </g>
            </svg>
            <span>&#25968;&#25454;&#24211;</span>
        </a>
    </nav>    
            
    <footer id="ht-footer">
    <a href="#" id="ht-jump-top" class="sp-aui-icon-small sp-aui-iconfont-arrows-up"></a>
</footer></div>

<div>
    <div id="ht-mq-detect"></div>
</div>

    <script src="js/lunr.js"></script>
    <script src="js/lunr-extras.js"></script>
    <script src="assets/js/scroll-search.js"></script>

    <script src="assets/js/expand-macro.js"></script>
</body>
</html>
